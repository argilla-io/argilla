{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Argilla","text":"<p>Argilla is a collaboration platform for AI engineers and domain experts that require high-quality outputs, full data ownership, and overall efficiency.</p> <p>Welcome to Argilla 2.x!</p> <p>To skip the introductions and go directly to installing and creating your first dataset, see Quickstart.</p> <p>Looking for Argilla 1.x?</p> <p>Looking for documentation for Argilla 1.x? Visit the latest release here.</p> <p>Migrate to Argilla 2.x</p> <p>Want to learn how to migrate from Argilla 1.x to 2.x? Take a look at our dedicated Migration Guide.</p> <ul> <li> <p>Get started in 5 minutes!</p> <p>Install <code>argilla</code> with <code>pip</code> and deploy a <code>Docker</code> locally or for free on Hugging Face to get up and running in minutes.</p> <p> Quickstart</p> </li> <li> <p>Educational guides</p> <p>Get familiar with basic and complex workflows for Argilla. From managing <code>Users</code>, <code>Workspaces</code>. <code>Datasets</code> and <code>Records</code> to fine-tuning a model.</p> <p> Learn more</p> </li> </ul>"},{"location":"#why-use-argilla","title":"Why use Argilla?","text":"<p>Whether you are working on monitoring and improving complex generative tasks involving LLM pipelines with RAG, or you are working on a predictive task for things like AB-testing of span- and text-classification models. Our versatile platform helps you ensure your data work pays off.</p> <p>Improve your AI output quality through data quality</p> <p>Compute is expensive and output quality is important. We help you focus on data, which tackles the root cause of both of these problems at once. Argilla helps you to achieve and keep high-quality standards for your data. This means you can improve the quality of your AI output.</p> <p>Take control of your data and models</p> <p>Most AI platforms are black boxes. Argilla is different. We believe that you should be the owner of both your data and your models. That's why we provide you with all the tools your team needs to manage your data and models in a way that suits you best.</p> <p>Improve efficiency by quickly iterating on the right data and models</p> <p>Gathering data is a time-consuming process. Argilla helps by providing a platform that allows you to interact with your data in a more engaging way. This means you can quickly and easily label your data with filters, AI feedback suggestions and semantic search. So you can focus on training your models and monitoring their performance.</p>"},{"location":"#what-do-people-build-with-argilla","title":"What do people build with Argilla?","text":"<p>Datasets and models</p> <p>Argilla is a tool that can be used to achieve and keep high-quality data standards with a focus on NLP and LLMs. Our community uses Argilla to create amazing open-source datasets and models, and we love contributions to open-source ourselves too.</p> <ul> <li>Our cleaned UltraFeedback dataset and the Notus and Notux models, where we improved benchmark and empirical human judgment for the Mistral and Mixtral models with cleaner data using human feedback.</li> <li>Our distilabeled Intel Orca DPO dataset and the improved OpenHermes model, show how we improve model performance by filtering out 50% of the original dataset through human and AI feedback.</li> </ul> <p>Projects and pipelines</p> <p>AI teams from companies like the Red Cross, Loris.ai and Prolific use Argilla to improve the quality and efficiency of AI projects. They shared their experiences in our AI community meetup.</p> <ul> <li>AI for good: the Red Cross presentation showcases how their experts and AI team collaborate by classifying and redirecting requests from refugees of the Ukrainian crisis to streamline the support processes of the Red Cross.</li> <li>Customer support: during the Loris meetup they showed how their AI team uses unsupervised and few-shot contrastive learning to help them quickly validate and gain labelled samples for a huge amount of multi-label classifiers.</li> <li>Research studies: the showcase from Prolific announced their integration with our platform. They use it to actively distribute data collection projects among their annotating workforce. This allows them to quickly and efficiently collect high-quality data for their research studies.</li> </ul>"},{"location":"community/","title":"Community","text":"<p>We are an open-source community-driven project not only focused on building a great product but also on building a great community, where you can get support, share your experiences, and contribute to the project! We would love to hear from you and help you get started with Argilla.</p> <ul> <li> <p>Discord</p> <p>In our Discord channels (#argilla-general and #argilla-help), you can get direct support from the community.</p> <p> Discord \u2197</p> </li> <li> <p>Community Meetup</p> <p>We host bi-weekly community meetups where you can listen in or present your work.</p> <p> Community Meetup \u2197</p> </li> <li> <p>Changelog</p> <p>The changelog is where you can find the latest updates and changes to the Argilla project.</p> <p> Changelog \u2197</p> </li> <li> <p>Roadmap</p> <p>We love to discuss our plans with the community. Feel encouraged to participate in our roadmap discussions.</p> <p> Roadmap \u2197</p> </li> </ul>"},{"location":"community/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"community/changelog/#200rc1","title":"2.0.0rc1","text":"<p>[!NOTE] This release for 2.0.0rc1 does not contain any changelog entries because it is the first release candidate for the 2.0.0 version. The following versions will contain the changelog entries again. For a general overview of the changes in the 2.0.0 version, please refer to our blog or our new documentation.</p>"},{"location":"community/changelog/#1290","title":"1.29.0","text":""},{"location":"community/changelog/#added","title":"Added","text":"<ul> <li>Added support for rating questions to include <code>0</code> as a valid value. (#4860)</li> <li>Added support for Python 3.12. (#4837)</li> <li>Added search by field in the <code>FeedbackDataset</code> UI search. (#4746)</li> <li>Added record metadata info in the <code>FeedbackDataset</code> UI. (#4851)</li> <li>Added highlight on search results in the <code>FeedbackDataset</code> UI. (#4747)</li> </ul>"},{"location":"community/changelog/#fixed","title":"Fixed","text":"<ul> <li>Fix wildcard import for the whole argilla module. (#4874)</li> <li>Fix issue when record does not have vectors related. (#4856)</li> <li>Fix issue on character level. (#4836)</li> </ul>"},{"location":"community/changelog/#1280","title":"1.28.0","text":""},{"location":"community/changelog/#added_1","title":"Added","text":"<ul> <li>Added suggestion multi score attribute. (#4730)</li> <li>Added order by suggestion first. (#4731)</li> <li>Added multi selection entity dropdown for span annotation overlap. (#4735)</li> <li>Added pre selection highlight for span annotation. (#4726)</li> <li>Added banner when persistent storage is not enabled. (#4744)</li> <li>Added support on Python SDK for new multi-label questions <code>labels_order</code> attribute. (#4757)</li> </ul>"},{"location":"community/changelog/#changed","title":"Changed","text":"<ul> <li>Changed the way how Hugging Face space and user is showed in sign in. (#4748)</li> </ul>"},{"location":"community/changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fixed Korean character reversed. (#4753)</li> </ul>"},{"location":"community/changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed requirements for version of wrapt library conflicting with Python 3.11 (#4693)</li> </ul>"},{"location":"community/changelog/#1270","title":"1.27.0","text":""},{"location":"community/changelog/#added_2","title":"Added","text":"<ul> <li>Added Allow overlap spans in the <code>FeedbackDataset</code>. (#4668)</li> <li>Added <code>allow_overlapping</code> parameter for span questions. (#4697)</li> <li>Added overall progress bar on <code>Datasets</code> table. (#4696)</li> <li>Added German language translation. (#4688)</li> </ul>"},{"location":"community/changelog/#changed_1","title":"Changed","text":"<ul> <li>New UI design for suggestions. (#4682)</li> </ul>"},{"location":"community/changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Improve performance for more than 250 labels. (#4702)</li> </ul>"},{"location":"community/changelog/#1261","title":"1.26.1","text":""},{"location":"community/changelog/#added_3","title":"Added","text":"<ul> <li>Added support for automatic detection of RTL languages. (#4686)</li> </ul>"},{"location":"community/changelog/#1260","title":"1.26.0","text":""},{"location":"community/changelog/#added_4","title":"Added","text":"<ul> <li>If you expand the labels of a <code>single or multi</code> label Question, the state is maintained during the entire annotation process. (#4630)</li> <li>Added support for span questions in the Python SDK. (#4617)</li> <li>Added support for span values in suggestions and responses. (#4623)</li> <li>Added <code>span</code> questions for <code>FeedbackDataset</code>. (#4622)</li> <li>Added <code>ARGILLA_CACHE_DIR</code> environment variable to configure the client cache directory. (#4509)</li> </ul>"},{"location":"community/changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Fixed contextualized workspaces. (#4665)</li> <li>Fixed prepare for training when passing <code>RankingValueSchema</code> instances to suggestions. (#4628)</li> <li>Fixed parsing ranking values in suggestions from HF datasets. (#4629)</li> <li>Fixed reading description from API response payload. (#4632)</li> <li>Fixed pulling (n*chunk_size)+1 records when using <code>ds.pull</code> or iterating over the dataset. (#4662)</li> <li>Fixed client's resolution of enum values when calling the Search and Metrics api, to support Python &gt;=3.11 enum handling. (#4672)</li> </ul>"},{"location":"community/changelog/#1250","title":"1.25.0","text":"<p>[!NOTE] For changes in the argilla-server module, visit the argilla-server release notes</p>"},{"location":"community/changelog/#added_5","title":"Added","text":"<ul> <li>Reorder labels in <code>dataset settings page</code> for single/multi label questions (#4598)</li> <li>Added pandas v2 support using the python SDK. (#4600)</li> </ul>"},{"location":"community/changelog/#removed","title":"Removed","text":"<ul> <li>Removed <code>missing</code> response for status filter. Use <code>pending</code> instead. (#4533)</li> </ul>"},{"location":"community/changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Fixed FloatMetadataProperty: value is not a valid float (#4570)</li> <li>Fixed redirect to <code>user-settings</code> instead of 404 <code>user_settings</code> (#4609)</li> </ul>"},{"location":"community/changelog/#1240","title":"1.24.0","text":"<p>[!NOTE] This release does not contain any new features, but it includes a major change in the <code>argilla-server</code> dependency. The package is using the <code>argilla-server</code> dependency defined here. (#4537)</p>"},{"location":"community/changelog/#changed_2","title":"Changed","text":"<ul> <li>The package is using the <code>argilla-server</code> dependency defined here. (#4537)</li> </ul>"},{"location":"community/changelog/#1231","title":"1.23.1","text":""},{"location":"community/changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Fixed Responsive view for Feedback Datasets. (#4579)</li> </ul>"},{"location":"community/changelog/#1230","title":"1.23.0","text":""},{"location":"community/changelog/#added_6","title":"Added","text":"<ul> <li>Added bulk annotation by filter criteria. (#4516)</li> <li>Automatically fetch new datasets on focus tab. (#4514)</li> <li>API v1 responses returning <code>Record</code> schema now always include <code>dataset_id</code> as attribute. (#4482)</li> <li>API v1 responses returning <code>Response</code> schema now always include <code>record_id</code> as attribute. (#4482)</li> <li>API v1 responses returning <code>Question</code> schema now always include <code>dataset_id</code> attribute. (#4487)</li> <li>API v1 responses returning <code>Field</code> schema now always include <code>dataset_id</code> attribute. (#4488)</li> <li>API v1 responses returning <code>MetadataProperty</code> schema now always include <code>dataset_id</code> attribute. (#4489)</li> <li>API v1 responses returning <code>VectorSettings</code> schema now always include <code>dataset_id</code> attribute. (#4490)</li> <li>Added <code>pdf_to_html</code> function to <code>.html_utils</code> module that convert PDFs to dataURL to be able to render them in tha Argilla UI. (#4481)</li> <li>Added <code>ARGILLA_AUTH_SECRET_KEY</code> environment variable. (#4539)</li> <li>Added <code>ARGILLA_AUTH_ALGORITHM</code> environment variable. (#4539)</li> <li>Added <code>ARGILLA_AUTH_TOKEN_EXPIRATION</code> environment variable. (#4539)</li> <li>Added <code>ARGILLA_AUTH_OAUTH_CFG</code> environment variable. (#4546)</li> <li>Added OAuth2 support for HuggingFace Hub. (#4546)</li> </ul>"},{"location":"community/changelog/#deprecated","title":"Deprecated","text":"<ul> <li>Deprecated <code>ARGILLA_LOCAL_AUTH_*</code> environment variables. Will be removed in the release v1.25.0. (#4539)</li> </ul>"},{"location":"community/changelog/#changed_3","title":"Changed","text":"<ul> <li>Changed regex pattern for <code>username</code> attribute in <code>UserCreate</code>. Now uppercase letters are allowed. (#4544)</li> </ul>"},{"location":"community/changelog/#removed_1","title":"Removed","text":"<ul> <li>Remove sending <code>Authorization</code> header from python SDK requests. (#4535)</li> </ul>"},{"location":"community/changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Fixed keyboard shortcut for label questions. (#4530)</li> </ul>"},{"location":"community/changelog/#1220","title":"1.22.0","text":""},{"location":"community/changelog/#added_7","title":"Added","text":"<ul> <li>Added Bulk annotation support. (#4333)</li> <li>Restore filters from feedback dataset settings. ([#4461])(https://github.com/argilla-io/argilla/pull/4461)</li> <li>Warning on feedback dataset settings when leaving page with unsaved changes. (#4461)</li> <li>Added pydantic v2 support using the python SDK. (#4459)</li> <li>Added <code>vector_settings</code> to the <code>__repr__</code> method of the <code>FeedbackDataset</code> and <code>RemoteFeedbackDataset</code>. (#4454)</li> <li>Added integration for <code>sentence-transformers</code> using <code>SentenceTransformersExtractor</code> to configure <code>vector_settings</code> in <code>FeedbackDataset</code> and <code>FeedbackRecord</code>. (#4454)</li> </ul>"},{"location":"community/changelog/#changed_4","title":"Changed","text":"<ul> <li>Module <code>argilla.cli.server</code> definitions have been moved to <code>argilla.server.cli</code> module. (#4472)</li> <li>[breaking] Changed <code>vector_settings_by_name</code> for generic <code>property_by_name</code> usage, which will return <code>None</code> instead of raising an error. (#4454)</li> <li>The constant definition <code>ES_INDEX_REGEX_PATTERN</code> in module <code>argilla._constants</code> is now private. (#4472)</li> <li><code>nan</code> values in metadata properties will raise a 422 error when creating/updating records. (#4300)</li> <li><code>None</code> values are now allowed in metadata properties. (#4300)</li> <li>Refactor and add <code>width</code>, <code>height</code>, <code>autoplay</code> and <code>loop</code> attributes as optional args in <code>to_html</code> functions. (#4481)</li> </ul>"},{"location":"community/changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Paginating to a new record, automatically scrolls down to selected form area. (#4333)</li> </ul>"},{"location":"community/changelog/#deprecated_1","title":"Deprecated","text":"<ul> <li>The <code>missing</code> response status for filtering records is deprecated and will be removed in the release v1.24.0. Use <code>pending</code> instead. (#4433)</li> </ul>"},{"location":"community/changelog/#removed_2","title":"Removed","text":"<ul> <li>The deprecated <code>python -m argilla database</code> command has been removed. (#4472)</li> </ul>"},{"location":"community/changelog/#1210","title":"1.21.0","text":""},{"location":"community/changelog/#added_8","title":"Added","text":"<ul> <li>Added new draft queue for annotation view (#4334)</li> <li>Added annotation metrics module for the <code>FeedbackDataset</code> (<code>argilla.client.feedback.metrics</code>). (#4175).</li> <li>Added strategy to handle and translate errors from the server for <code>401</code> HTTP status code` (#4362)</li> <li>Added integration for <code>textdescriptives</code> using <code>TextDescriptivesExtractor</code> to configure <code>metadata_properties</code> in <code>FeedbackDataset</code> and <code>FeedbackRecord</code>. (#4400). Contributed by @m-newhauser</li> <li>Added <code>POST /api/v1/me/responses/bulk</code> endpoint to create responses in bulk for current user. (#4380)</li> <li>Added list support for term metadata properties. (Closes #4359)</li> <li>Added new CLI task to reindex datasets and records into the search engine. (#4404)</li> <li>Added <code>httpx_extra_kwargs</code> argument to <code>rg.init</code> and <code>Argilla</code> to allow passing extra arguments to <code>httpx.Client</code> used by <code>Argilla</code>. (#4440)</li> <li>Added <code>ResponseStatusFilter</code> enum in <code>__init__</code> imports of Argilla (#4118). Contributed by @Piyush-Kumar-Ghosh.</li> </ul>"},{"location":"community/changelog/#changed_5","title":"Changed","text":"<ul> <li>More productive and simpler shortcut system (#4215)</li> <li>Move <code>ArgillaSingleton</code>, <code>init</code> and <code>active_client</code> to a new module <code>singleton</code>. (#4347)</li> <li>Updated <code>argilla.load</code> functions to also work with <code>FeedbackDataset</code>s. (#4347)</li> <li>[breaking] Updated <code>argilla.delete</code> functions to also work with <code>FeedbackDataset</code>s. It now raises an error if the dataset does not exist. (#4347)</li> <li>Updated <code>argilla.list_datasets</code> functions to also work with <code>FeedbackDataset</code>s. (#4347)</li> </ul>"},{"location":"community/changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Fixed error in <code>TextClassificationSettings.from_dict</code> method in which the <code>label_schema</code> created was a list of <code>dict</code> instead of a list of <code>str</code>. (#4347)</li> <li>Fixed total records on pagination component (#4424)</li> </ul>"},{"location":"community/changelog/#removed_3","title":"Removed","text":"<ul> <li>Removed <code>draft</code> auto save for annotation view (#4334)</li> </ul>"},{"location":"community/changelog/#1200","title":"1.20.0","text":""},{"location":"community/changelog/#added_9","title":"Added","text":"<ul> <li>Added <code>GET /api/v1/datasets/:dataset_id/records/search/suggestions/options</code> endpoint to return suggestion available options for searching. (#4260)</li> <li>Added <code>metadata_properties</code> to the <code>__repr__</code> method of the <code>FeedbackDataset</code> and <code>RemoteFeedbackDataset</code>.(#4192).</li> <li>Added <code>get_model_kwargs</code>, <code>get_trainer_kwargs</code>, <code>get_trainer_model</code>, <code>get_trainer_tokenizer</code> and <code>get_trainer</code> -methods to the <code>ArgillaTrainer</code> to improve interoperability across frameworks. (#4214).</li> <li>Added additional formatting checks to the <code>ArgillaTrainer</code> to allow for better interoperability of <code>defaults</code> and <code>formatting_func</code> usage. (#4214).</li> <li>Added a warning to the <code>update_config</code>-method of <code>ArgillaTrainer</code> to emphasize if the <code>kwargs</code> were updated correctly. (#4214).</li> <li>Added <code>argilla.client.feedback.utils</code> module with <code>html_utils</code> (this mainly includes <code>video/audio/image_to_html</code> that convert media to dataURL to be able to render them in tha Argilla UI and <code>create_token_highlights</code> to highlight tokens in a custom way. Both work on TextQuestion and TextField with use_markdown=True) and <code>assignments</code> (this mainly includes <code>assign_records</code> to assign records according to a number of annotators and records, an overlap and the shuffle option; and <code>assign_workspace</code> to assign and create if needed a workspace according to the record assignment). (#4121)</li> </ul>"},{"location":"community/changelog/#fixed_10","title":"Fixed","text":"<ul> <li>Fixed error in <code>ArgillaTrainer</code>, with numerical labels, using <code>RatingQuestion</code> instead of <code>RankingQuestion</code> (#4171)</li> <li>Fixed error in <code>ArgillaTrainer</code>, now we can train for <code>extractive_question_answering</code> using a validation sample (#4204)</li> <li>Fixed error in <code>ArgillaTrainer</code>, when training for <code>sentence-similarity</code> it didn't work with a list of values per record (#4211)</li> <li>Fixed error in the unification strategy for <code>RankingQuestion</code> (#4295)</li> <li>Fixed <code>TextClassificationSettings.labels_schema</code> order was not being preserved. Closes #3828 (#4332)</li> <li>Fixed error when requesting non-existing API endpoints. Closes #4073 (#4325)</li> <li>Fixed error when passing <code>draft</code> responses to create records endpoint. (#4354)</li> </ul>"},{"location":"community/changelog/#changed_6","title":"Changed","text":"<ul> <li>[breaking] Suggestions <code>agent</code> field only accepts now some specific characters and a limited length. (#4265)</li> <li>[breaking] Suggestions <code>score</code> field only accepts now float values in the range <code>0</code> to <code>1</code>. (#4266)</li> <li>Updated <code>POST /api/v1/dataset/:dataset_id/records/search</code> endpoint to support optional <code>query</code> attribute. (#4327)</li> <li>Updated <code>POST /api/v1/dataset/:dataset_id/records/search</code> endpoint to support <code>filter</code> and <code>sort</code> attributes. (#4327)</li> <li>Updated <code>POST /api/v1/me/datasets/:dataset_id/records/search</code> endpoint to support optional <code>query</code> attribute. (#4270)</li> <li>Updated <code>POST /api/v1/me/datasets/:dataset_id/records/search</code> endpoint to support <code>filter</code> and <code>sort</code> attributes. (#4270)</li> <li>Changed the logging style while pulling and pushing <code>FeedbackDataset</code> to Argilla from <code>tqdm</code> style to <code>rich</code>. (#4267). Contributed by @zucchini-nlp.</li> <li>Updated <code>push_to_argilla</code> to print <code>repr</code> of the pushed <code>RemoteFeedbackDataset</code> after push and changed <code>show_progress</code> to True by default. (#4223)</li> <li>Changed <code>models</code> and <code>tokenizer</code> for the <code>ArgillaTrainer</code> to explicitly allow for changing them when needed. (#4214).</li> </ul>"},{"location":"community/changelog/#1190","title":"1.19.0","text":""},{"location":"community/changelog/#added_10","title":"Added","text":"<ul> <li>Added <code>POST /api/v1/datasets/:dataset_id/records/search</code> endpoint to search for records without user context, including responses by all users. (#4143)</li> <li>Added <code>POST /api/v1/datasets/:dataset_id/vectors-settings</code> endpoint for creating vector settings for a dataset. (#3776)</li> <li>Added <code>GET /api/v1/datasets/:dataset_id/vectors-settings</code> endpoint for listing the vectors settings for a dataset. (#3776)</li> <li>Added <code>DELETE /api/v1/vectors-settings/:vector_settings_id</code> endpoint for deleting a vector settings. (#3776)</li> <li>Added <code>PATCH /api/v1/vectors-settings/:vector_settings_id</code> endpoint for updating a vector settings. (#4092)</li> <li>Added <code>GET /api/v1/records/:record_id</code> endpoint to get a specific record. (#4039)</li> <li>Added support to include vectors for <code>GET /api/v1/datasets/:dataset_id/records</code> endpoint response using <code>include</code> query param. (#4063)</li> <li>Added support to include vectors for <code>GET /api/v1/me/datasets/:dataset_id/records</code> endpoint response using <code>include</code> query param. (#4063)</li> <li>Added support to include vectors for <code>POST /api/v1/me/datasets/:dataset_id/records/search</code> endpoint response using <code>include</code> query param. (#4063)</li> <li>Added <code>show_progress</code> argument to <code>from_huggingface()</code> method to make the progress bar for parsing records process optional.(#4132).</li> <li>Added a progress bar for parsing records process to <code>from_huggingface()</code> method with <code>trange</code> in <code>tqdm</code>.(#4132).</li> <li>Added to sort by <code>inserted_at</code> or <code>updated_at</code> for datasets with no metadata. (4147)</li> <li>Added <code>max_records</code> argument to <code>pull()</code> method for <code>RemoteFeedbackDataset</code>.(#4074)</li> <li>Added functionality to push your models to the Hugging Face hub with <code>ArgillaTrainer.push_to_huggingface</code> (#3976). Contributed by @Racso-3141.</li> <li>Added <code>filter_by</code> argument to <code>ArgillaTrainer</code> to filter by <code>response_status</code> (#4120).</li> <li>Added <code>sort_by</code> argument to <code>ArgillaTrainer</code> to sort by <code>metadata</code> (#4120).</li> <li>Added <code>max_records</code> argument to <code>ArgillaTrainer</code> to limit record used for training (#4120).</li> <li>Added <code>add_vector_settings</code> method to local and remote <code>FeedbackDataset</code>. (#4055)</li> <li>Added <code>update_vectors_settings</code> method to local and remote <code>FeedbackDataset</code>. (#4122)</li> <li>Added <code>delete_vectors_settings</code> method to local and remote <code>FeedbackDataset</code>. (#4130)</li> <li>Added <code>vector_settings_by_name</code> method to local and remote <code>FeedbackDataset</code>. (#4055)</li> <li>Added <code>find_similar_records</code> method to local and remote <code>FeedbackDataset</code>. (#4023)</li> <li>Added <code>ARGILLA_SEARCH_ENGINE</code> environment variable to configure the search engine to use. (#4019)</li> </ul>"},{"location":"community/changelog/#changed_7","title":"Changed","text":"<ul> <li>[breaking] Remove support for Elasticsearch &lt; 8.5 and OpenSearch &lt; 2.4. (#4173)</li> <li>[breaking] Users working with OpenSearch engines must use version &gt;=2.4 and set <code>ARGILLA_SEARCH_ENGINE=opensearch</code>. (#4019 and #4111)</li> <li>[breaking] Changed <code>FeedbackDataset.*_by_name()</code> methods to return <code>None</code> when no match is found (#4101).</li> <li>[breaking] <code>limit</code> query parameter for <code>GET /api/v1/datasets/:dataset_id/records</code> endpoint is now only accepting values greater or equal than <code>1</code> and less or equal than <code>1000</code>. (#4143)</li> <li>[breaking] <code>limit</code> query parameter for <code>GET /api/v1/me/datasets/:dataset_id/records</code> endpoint is now only accepting values greater or equal than <code>1</code> and less or equal than <code>1000</code>. (#4143)</li> <li>Update <code>GET /api/v1/datasets/:dataset_id/records</code> endpoint to fetch record using the search engine. (#4142)</li> <li>Update <code>GET /api/v1/me/datasets/:dataset_id/records</code> endpoint to fetch record using the search engine. (#4142)</li> <li>Update <code>POST /api/v1/datasets/:dataset_id/records</code> endpoint to allow to create records with <code>vectors</code> (#4022)</li> <li>Update <code>PATCH /api/v1/datasets/:dataset_id</code> endpoint to allow updating <code>allow_extra_metadata</code> attribute. (#4112)</li> <li>Update <code>PATCH /api/v1/datasets/:dataset_id/records</code> endpoint to allow to update records with <code>vectors</code>. (#4062)</li> <li>Update <code>PATCH /api/v1/records/:record_id</code> endpoint to allow to update record with <code>vectors</code>. (#4062)</li> <li>Update <code>POST /api/v1/me/datasets/:dataset_id/records/search</code> endpoint to allow to search records with vectors. (#4019)</li> <li>Update <code>BaseElasticAndOpenSearchEngine.index_records</code> method to also index record vectors. (#4062)</li> <li>Update <code>FeedbackDataset.__init__</code> to allow passing a list of vector settings. (#4055)</li> <li>Update <code>FeedbackDataset.push_to_argilla</code> to also push vector settings. (#4055)</li> <li>Update <code>FeedbackDatasetRecord</code> to support the creation of records with vectors. (#4043)</li> <li>Using cosine similarity to compute similarity between vectors. (#4124)</li> </ul>"},{"location":"community/changelog/#fixed_11","title":"Fixed","text":"<ul> <li>Fixed svg images out of screen with too large images (#4047)</li> <li>Fixed creating records with responses from multiple users. Closes #3746 and #3808 (#4142)</li> <li>Fixed deleting or updating responses as an owner for annotators. (Commit 403a66d)</li> <li>Fixed passing user_id when getting records by id. (Commit 98c7927)</li> <li>Fixed non-basic tags serialized when pushing a dataset to the Hugging Face Hub. Closes #4089 (#4200)</li> </ul>"},{"location":"community/changelog/#1180","title":"1.18.0","text":""},{"location":"community/changelog/#added_11","title":"Added","text":"<ul> <li>New <code>GET /api/v1/datasets/:dataset_id/metadata-properties</code> endpoint for listing dataset metadata properties. (#3813)</li> <li>New <code>POST /api/v1/datasets/:dataset_id/metadata-properties</code> endpoint for creating dataset metadata properties. (#3813)</li> <li>New <code>PATCH /api/v1/metadata-properties/:metadata_property_id</code> endpoint allowing the update of a specific metadata property. (#3952)</li> <li>New <code>DELETE /api/v1/metadata-properties/:metadata_property_id</code> endpoint for deletion of a specific metadata property. (#3911)</li> <li>New <code>GET /api/v1/metadata-properties/:metadata_property_id/metrics</code> endpoint to compute metrics for a specific metadata property. (#3856)</li> <li>New <code>PATCH /api/v1/records/:record_id</code> endpoint to update a record. (#3920)</li> <li>New <code>PATCH /api/v1/dataset/:dataset_id/records</code> endpoint to bulk update the records of a dataset. (#3934)</li> <li>Missing validations to <code>PATCH /api/v1/questions/:question_id</code>. Now <code>title</code> and <code>description</code> are using the same validations used to create questions. (#3967)</li> <li>Added <code>TermsMetadataProperty</code>, <code>IntegerMetadataProperty</code> and <code>FloatMetadataProperty</code> classes allowing to define metadata properties for a <code>FeedbackDataset</code>. (#3818)</li> <li>Added <code>metadata_filters</code> to <code>filter_by</code> method in <code>RemoteFeedbackDataset</code> to filter based on metadata i.e. <code>TermsMetadataFilter</code>, <code>IntegerMetadataFilter</code>, and <code>FloatMetadataFilter</code>. (#3834)</li> <li>Added a validation layer for both <code>metadata_properties</code> and <code>metadata_filters</code> in their schemas and as part of the <code>add_records</code> and <code>filter_by</code> methods, respectively. (#3860)</li> <li>Added <code>sort_by</code> query parameter to listing records endpoints that allows to sort the records by <code>inserted_at</code>, <code>updated_at</code> or metadata property. (#3843)</li> <li>Added <code>add_metadata_property</code> method to both <code>FeedbackDataset</code> and <code>RemoteFeedbackDataset</code> (i.e. <code>FeedbackDataset</code> in Argilla). (#3900)</li> <li>Added fields <code>inserted_at</code> and <code>updated_at</code> in <code>RemoteResponseSchema</code>. (#3822)</li> <li>Added support for <code>sort_by</code> for <code>RemoteFeedbackDataset</code> i.e. a <code>FeedbackDataset</code> uploaded to Argilla. (#3925)</li> <li>Added <code>metadata_properties</code> support for both <code>push_to_huggingface</code> and <code>from_huggingface</code>. (#3947)</li> <li>Add support for update records (<code>metadata</code>) from Python SDK. (#3946)</li> <li>Added <code>delete_metadata_properties</code> method to delete metadata properties. (#3932)</li> <li>Added <code>update_metadata_properties</code> method to update <code>metadata_properties</code>. (#3961)</li> <li>Added automatic model card generation through <code>ArgillaTrainer.save</code> (#3857)</li> <li>Added <code>FeedbackDataset</code> <code>TaskTemplateMixin</code> for pre-defined task templates. (#3969)</li> <li>A maximum limit of 50 on the number of options a ranking question can accept. (#3975)</li> <li>New <code>last_activity_at</code> field to <code>FeedbackDataset</code> exposing when the last activity for the associated dataset occurs. (#3992)</li> </ul>"},{"location":"community/changelog/#changed_8","title":"Changed","text":"<ul> <li><code>GET /api/v1/datasets/{dataset_id}/records</code>, <code>GET /api/v1/me/datasets/{dataset_id}/records</code> and <code>POST /api/v1/me/datasets/{dataset_id}/records/search</code> endpoints to return the <code>total</code> number of records. (#3848, #3903)</li> <li>Implemented <code>__len__</code> method for filtered datasets to return the number of records matching the provided filters. (#3916)</li> <li>Increase the default max result window for Elasticsearch created for Feedback datasets. (#3929)</li> <li>Force elastic index refresh after records creation. (#3929)</li> <li>Validate metadata fields for filtering and sorting in the Python SDK. (#3993)</li> <li>Using metadata property name instead of id for indexing data in search engine index. (#3994)</li> </ul>"},{"location":"community/changelog/#fixed_12","title":"Fixed","text":"<ul> <li>Fixed response schemas to allow <code>values</code> to be <code>None</code> i.e. when a record is discarded the <code>response.values</code> are set to <code>None</code>. (#3926)</li> </ul>"},{"location":"community/changelog/#1170","title":"1.17.0","text":""},{"location":"community/changelog/#added_12","title":"Added","text":"<ul> <li>Added fields <code>inserted_at</code> and <code>updated_at</code> in <code>RemoteResponseSchema</code> (#3822).</li> <li>Added automatic model card generation through <code>ArgillaTrainer.save</code> (#3857).</li> <li>Added task templates to the <code>FeedbackDataset</code> (#3973).</li> </ul>"},{"location":"community/changelog/#changed_9","title":"Changed","text":"<ul> <li>Updated <code>Dockerfile</code> to use multi stage build (#3221 and #3793).</li> <li>Updated active learning for text classification notebooks to use the most recent small-text version (#3831).</li> <li>Changed argilla dataset name in the active learning for text classification notebooks to be consistent with the default names in the huggingface spaces (#3831).</li> <li>FeedbackDataset API methods have been aligned to be accessible through the several implementations (#3937).</li> <li>The <code>unify_responses</code> support for remote datasets (#3937).</li> </ul>"},{"location":"community/changelog/#fixed_13","title":"Fixed","text":"<ul> <li>Fix field not shown in the order defined in the dataset settings. Closes #3959 (#3984)</li> <li>Updated active learning for text classification notebooks to pass ids of type int to <code>TextClassificationRecord</code> (#3831).</li> <li>Fixed record fields validation that was preventing from logging records with optional fields (i.e. <code>required=True</code>) when the field value was <code>None</code> (#3846).</li> <li>Always set <code>pretrained_model_name_or_path</code> attribute as string in <code>ArgillaTrainer</code> (#3914).</li> <li>The <code>inserted_at</code> and <code>updated_at</code> attributes are create using the <code>utcnow</code> factory to avoid unexpected race conditions on timestamp creation (#3945)</li> <li>Fixed <code>configure_dataset_settings</code> when providing the workspace via the arg <code>workspace</code> (#3887).</li> <li>Fixed saving of models trained with <code>ArgillaTrainer</code> with a <code>peft_config</code> parameter (#3795).</li> <li>Fixed backwards compatibility on <code>from_huggingface</code> when loading a <code>FeedbackDataset</code> from the Hugging Face Hub that was previously dumped using another version of Argilla, starting at 1.8.0, when it was first introduced (#3829).</li> <li>Fixed wrong <code>__repr__</code> problem for <code>TrainingTask</code>. (#3969)</li> <li>Fixed wrong key return error <code>prepare_for_training_with_*</code> for <code>TrainingTask</code>. (#3969)</li> </ul>"},{"location":"community/changelog/#deprecated_2","title":"Deprecated","text":"<ul> <li>Function <code>rg.configure_dataset</code> is deprecated in favour of <code>rg.configure_dataset_settings</code>. The former will be removed in version 1.19.0</li> </ul>"},{"location":"community/changelog/#1160","title":"1.16.0","text":""},{"location":"community/changelog/#added_13","title":"Added","text":"<ul> <li>Added <code>ArgillaTrainer</code> integration with sentence-transformers, allowing fine tuning for sentence similarity (#3739)</li> <li>Added <code>ArgillaTrainer</code> integration with <code>TrainingTask.for_question_answering</code> (#3740)</li> <li>Added <code>Auto save record</code> to save automatically the current record that you are working on (#3541)</li> <li>Added <code>ArgillaTrainer</code> integration with OpenAI, allowing fine tuning for chat completion (#3615)</li> <li>Added <code>workspaces list</code> command to list Argilla workspaces (#3594).</li> <li>Added <code>datasets list</code> command to list Argilla datasets (#3658).</li> <li>Added <code>users create</code> command to create users (#3667).</li> <li>Added <code>whoami</code> command to get current user (#3673).</li> <li>Added <code>users delete</code> command to delete users (#3671).</li> <li>Added <code>users list</code> command to list users (#3688).</li> <li>Added <code>workspaces delete-user</code> command to remove a user from a workspace (#3699).</li> <li>Added <code>datasets list</code> command to list Argilla datasets (#3658).</li> <li>Added <code>users create</code> command to create users (#3667).</li> <li>Added <code>users delete</code> command to delete users (#3671).</li> <li>Added <code>workspaces create</code> command to create an Argilla workspace (#3676).</li> <li>Added <code>datasets push-to-hub</code> command to push a <code>FeedbackDataset</code> from Argilla into the HuggingFace Hub (#3685).</li> <li>Added <code>info</code> command to get info about the used Argilla client and server (#3707).</li> <li>Added <code>datasets delete</code> command to delete a <code>FeedbackDataset</code> from Argilla (#3703).</li> <li>Added <code>created_at</code> and <code>updated_at</code> properties to <code>RemoteFeedbackDataset</code> and <code>FilteredRemoteFeedbackDataset</code> (#3709).</li> <li>Added handling <code>PermissionError</code> when executing a command with a logged in user with not enough permissions (#3717).</li> <li>Added <code>workspaces add-user</code> command to add a user to workspace (#3712).</li> <li>Added <code>workspace_id</code> param to <code>GET /api/v1/me/datasets</code> endpoint (#3727).</li> <li>Added <code>workspace_id</code> arg to <code>list_datasets</code> in the Python SDK (#3727).</li> <li>Added <code>argilla</code> script that allows to execute Argilla CLI using the <code>argilla</code> command (#3730).</li> <li>Added support for passing already initialized <code>model</code> and <code>tokenizer</code> instances to the <code>ArgillaTrainer</code> (#3751)</li> <li>Added <code>server_info</code> function to check the Argilla server information (also accessible via <code>rg.server_info</code>) (#3772).</li> </ul>"},{"location":"community/changelog/#changed_10","title":"Changed","text":"<ul> <li>Move <code>database</code> commands under <code>server</code> group of commands (#3710)</li> <li><code>server</code> commands only included in the CLI app when <code>server</code> extra requirements are installed (#3710).</li> <li>Updated <code>PUT /api/v1/responses/{response_id}</code> to replace <code>values</code> stored with received <code>values</code> in request (#3711).</li> <li>Display a <code>UserWarning</code> when the <code>user_id</code> in <code>Workspace.add_user</code> and <code>Workspace.delete_user</code> is the ID of an user with the owner role as they don't require explicit permissions (#3716).</li> <li>Rename <code>tasks</code> sub-package to <code>cli</code> (#3723).</li> <li>Changed <code>argilla database</code> command in the CLI to now be accessed via <code>argilla server database</code>, to be deprecated in the upcoming release (#3754).</li> <li>Changed <code>visible_options</code> (of label and multi label selection questions) validation in the backend to check that the provided value is greater or equal than/to 3 and less or equal than/to the number of provided options (#3773).</li> </ul>"},{"location":"community/changelog/#fixed_14","title":"Fixed","text":"<ul> <li>Fixed <code>remove user modification in text component on clear answers</code> (#3775)</li> <li>Fixed <code>Highlight raw text field in dataset feedback task</code> (#3731)</li> <li>Fixed <code>Field title too long</code> (#3734)</li> <li>Fixed error messages when deleting a <code>DatasetForTextClassification</code> (#3652)</li> <li>Fixed <code>Pending queue</code> pagination problems when during data annotation (#3677)</li> <li>Fixed <code>visible_labels</code> default value to be 20 just when <code>visible_labels</code> not provided and <code>len(labels) &gt; 20</code>, otherwise it will either be the provided <code>visible_labels</code> value or <code>None</code>, for <code>LabelQuestion</code> and <code>MultiLabelQuestion</code> (#3702).</li> <li>Fixed <code>DatasetCard</code> generation when <code>RemoteFeedbackDataset</code> contains suggestions (#3718).</li> <li>Add missing <code>draft</code> status in <code>ResponseSchema</code> as now there can be responses with <code>draft</code> status when annotating via the UI (#3749).</li> <li>Searches when queried words are distributed along the record fields (#3759).</li> <li>Fixed Python 3.11 compatibility issue with <code>/api/datasets</code> endpoints due to the <code>TaskType</code> enum replacement in the endpoint URL (#3769).</li> <li>Fixed <code>RankingValueSchema</code> and <code>FeedbackRankingValueModel</code> schemas to allow <code>rank=None</code> when <code>status=draft</code> (#3781).</li> </ul>"},{"location":"community/changelog/#1151","title":"1.15.1","text":""},{"location":"community/changelog/#fixed_15","title":"Fixed","text":"<ul> <li>Fixed <code>Text component</code> text content sanitization behavior just for markdown to prevent disappear the text(#3738)</li> <li>Fixed <code>Text component</code> now you need to press Escape to exit the text area (#3733)</li> <li>Fixed <code>SearchEngine</code> was creating the same number of primary shards and replica shards for each <code>FeedbackDataset</code> (#3736).</li> </ul>"},{"location":"community/changelog/#1150","title":"1.15.0","text":""},{"location":"community/changelog/#added_14","title":"Added","text":"<ul> <li>Added <code>Enable to update guidelines and dataset settings for Feedback Datasets directly in the UI</code> (#3489)</li> <li>Added <code>ArgillaTrainer</code> integration with TRL, allowing for easy supervised finetuning, reward modeling, direct preference optimization and proximal policy optimization (#3467)</li> <li>Added <code>formatting_func</code> to <code>ArgillaTrainer</code> for <code>FeedbackDataset</code> datasets add a custom formatting for the data (#3599).</li> <li>Added <code>login</code> function in <code>argilla.client.login</code> to login into an Argilla server and store the credentials locally (#3582).</li> <li>Added <code>login</code> command to login into an Argilla server (#3600).</li> <li>Added <code>logout</code> command to logout from an Argilla server (#3605).</li> <li>Added <code>DELETE /api/v1/suggestions/{suggestion_id}</code> endpoint to delete a suggestion given its ID (#3617).</li> <li>Added <code>DELETE /api/v1/records/{record_id}/suggestions</code> endpoint to delete several suggestions linked to the same record given their IDs (#3617).</li> <li>Added <code>response_status</code> param to <code>GET /api/v1/datasets/{dataset_id}/records</code> to be able to filter by <code>response_status</code> as previously included for <code>GET /api/v1/me/datasets/{dataset_id}/records</code> (#3613).</li> <li>Added <code>list</code> classmethod to <code>ArgillaMixin</code> to be used as <code>FeedbackDataset.list()</code>, also including the <code>workspace</code> to list from as arg (#3619).</li> <li>Added <code>filter_by</code> method in <code>RemoteFeedbackDataset</code> to filter based on <code>response_status</code> (#3610).</li> <li>Added <code>list_workspaces</code> function (to be used as <code>rg.list_workspaces</code>, but <code>Workspace.list</code> is preferred) to list all the workspaces from an user in Argilla (#3641).</li> <li>Added <code>list_datasets</code> function (to be used as <code>rg.list_datasets</code>) to list the <code>TextClassification</code>, <code>TokenClassification</code>, and <code>Text2Text</code> datasets in Argilla (#3638).</li> <li>Added <code>RemoteSuggestionSchema</code> to manage suggestions in Argilla, including the <code>delete</code> method to delete suggestios from Argilla via <code>DELETE /api/v1/suggestions/{suggestion_id}</code> (#3651).</li> <li>Added <code>delete_suggestions</code> to <code>RemoteFeedbackRecord</code> to remove suggestions from Argilla via <code>DELETE /api/v1/records/{record_id}/suggestions</code> (#3651).</li> </ul>"},{"location":"community/changelog/#changed_11","title":"Changed","text":"<ul> <li>Changed <code>Optional label for * mark for required question</code> (#3608)</li> <li>Updated <code>RemoteFeedbackDataset.delete_records</code> to use batch delete records endpoint (#3580).</li> <li>Included <code>allowed_for_roles</code> for some <code>RemoteFeedbackDataset</code>, <code>RemoteFeedbackRecords</code>, and <code>RemoteFeedbackRecord</code> methods that are only allowed for users with roles <code>owner</code> and <code>admin</code> (#3601).</li> <li>Renamed <code>ArgillaToFromMixin</code> to <code>ArgillaMixin</code> (#3619).</li> <li>Move <code>users</code> CLI app under <code>database</code> CLI app (#3593).</li> <li>Move server <code>Enum</code> classes to <code>argilla.server.enums</code> module (#3620).</li> </ul>"},{"location":"community/changelog/#fixed_16","title":"Fixed","text":"<ul> <li>Fixed <code>Filter by workspace in breadcrumbs</code> (#3577)</li> <li>Fixed <code>Filter by workspace in datasets table</code> (#3604)</li> <li>Fixed <code>Query search highlight</code> for Text2Text and TextClassification (#3621)</li> <li>Fixed <code>RatingQuestion.values</code> validation to raise a <code>ValidationError</code> when values are out of range i.e. [1, 10] (#3626).</li> </ul>"},{"location":"community/changelog/#removed_4","title":"Removed","text":"<ul> <li>Removed <code>multi_task_text_token_classification</code> from <code>TaskType</code> as not used (#3640).</li> <li>Removed <code>argilla_id</code> in favor of <code>id</code> from <code>RemoteFeedbackDataset</code> (#3663).</li> <li>Removed <code>fetch_records</code> from <code>RemoteFeedbackDataset</code> as now the records are lazily fetched from Argilla (#3663).</li> <li>Removed <code>push_to_argilla</code> from <code>RemoteFeedbackDataset</code>, as it just works when calling it through a <code>FeedbackDataset</code> locally, as now the updates of the remote datasets are automatically pushed to Argilla (#3663).</li> <li>Removed <code>set_suggestions</code> in favor of <code>update(suggestions=...)</code> for both <code>FeedbackRecord</code> and <code>RemoteFeedbackRecord</code>, as all the updates of any \"updateable\" attribute of a record will go through <code>update</code> instead (#3663).</li> <li>Remove unused <code>owner</code> attribute for client Dataset data model (#3665)</li> </ul>"},{"location":"community/changelog/#1141","title":"1.14.1","text":""},{"location":"community/changelog/#fixed_17","title":"Fixed","text":"<ul> <li>Fixed PostgreSQL database not being updated after <code>begin_nested</code> because of missing <code>commit</code> (#3567).</li> </ul>"},{"location":"community/changelog/#fixed_18","title":"Fixed","text":"<ul> <li>Fixed <code>settings</code> could not be provided when updating a <code>rating</code> or <code>ranking</code> question (#3552).</li> </ul>"},{"location":"community/changelog/#1140","title":"1.14.0","text":""},{"location":"community/changelog/#added_15","title":"Added","text":"<ul> <li>Added <code>PATCH /api/v1/fields/{field_id}</code> endpoint to update the field title and markdown settings (#3421).</li> <li>Added <code>PATCH /api/v1/datasets/{dataset_id}</code> endpoint to update dataset name and guidelines (#3402).</li> <li>Added <code>PATCH /api/v1/questions/{question_id}</code> endpoint to update question title, description and some settings (depending on the type of question) (#3477).</li> <li>Added <code>DELETE /api/v1/records/{record_id}</code> endpoint to remove a record given its ID (#3337).</li> <li>Added <code>pull</code> method in <code>RemoteFeedbackDataset</code> (a <code>FeedbackDataset</code> pushed to Argilla) to pull all the records from it and return it as a local copy as a <code>FeedbackDataset</code> (#3465).</li> <li>Added <code>delete</code> method in <code>RemoteFeedbackDataset</code> (a <code>FeedbackDataset</code> pushed to Argilla) (#3512).</li> <li>Added <code>delete_records</code> method in <code>RemoteFeedbackDataset</code>, and <code>delete</code> method in <code>RemoteFeedbackRecord</code> to delete records from Argilla (#3526).</li> </ul>"},{"location":"community/changelog/#changed_12","title":"Changed","text":"<ul> <li>Improved efficiency of weak labeling when dataset contains vectors (#3444).</li> <li>Added <code>ArgillaDatasetMixin</code> to detach the Argilla-related functionality from the <code>FeedbackDataset</code> (#3427)</li> <li>Moved <code>FeedbackDataset</code>-related <code>pydantic.BaseModel</code> schemas to <code>argilla.client.feedback.schemas</code> instead, to be better structured and more scalable and maintainable (#3427)</li> <li>Update CLI to use database async connection (#3450).</li> <li>Limit rating questions values to the positive range [1, 10] (#3451).</li> <li>Updated <code>POST /api/users</code> endpoint to be able to provide a list of workspace names to which the user should be linked to (#3462).</li> <li>Updated Python client <code>User.create</code> method to be able to provide a list of workspace names to which the user should be linked to (#3462).</li> <li>Updated <code>GET /api/v1/me/datasets/{dataset_id}/records</code> endpoint to allow getting records matching one of the response statuses provided via query param (#3359).</li> <li>Updated <code>POST /api/v1/me/datasets/{dataset_id}/records</code> endpoint to allow searching records matching one of the response statuses provided via query param (#3359).</li> <li>Updated <code>SearchEngine.search</code> method to allow searching records matching one of the response statuses provided (#3359).</li> <li>After calling <code>FeedbackDataset.push_to_argilla</code>, the methods <code>FeedbackDataset.add_records</code> and <code>FeedbackRecord.set_suggestions</code> will automatically call Argilla with no need of calling <code>push_to_argilla</code> explicitly (#3465).</li> <li>Now calling <code>FeedbackDataset.push_to_huggingface</code> dumps the <code>responses</code> as a <code>List[Dict[str, Any]]</code> instead of <code>Sequence</code> to make it more readable via \ud83e\udd17<code>datasets</code> (#3539).</li> </ul>"},{"location":"community/changelog/#fixed_19","title":"Fixed","text":"<ul> <li>Fixed issue with <code>bool</code> values and <code>default</code> from Jinja2 while generating the HuggingFace <code>DatasetCard</code> from <code>argilla_template.md</code> (#3499).</li> <li>Fixed <code>DatasetConfig.from_yaml</code> which was failing when calling <code>FeedbackDataset.from_huggingface</code> as the UUIDs cannot be deserialized automatically by <code>PyYAML</code>, so UUIDs are neither dumped nor loaded anymore (#3502).</li> <li>Fixed an issue that didn't allow the Argilla server to work behind a proxy (#3543).</li> <li><code>TextClassificationSettings</code> and <code>TokenClassificationSettings</code> labels are properly parsed to strings both in the Python client and in the backend endpoint (#3495).</li> <li>Fixed <code>PUT /api/v1/datasets/{dataset_id}/publish</code> to check whether at least one field and question has <code>required=True</code> (#3511).</li> <li>Fixed <code>FeedbackDataset.from_huggingface</code> as <code>suggestions</code> were being lost when there were no <code>responses</code> (#3539).</li> <li>Fixed <code>QuestionSchema</code> and <code>FieldSchema</code> not validating <code>name</code> attribute (#3550).</li> </ul>"},{"location":"community/changelog/#deprecated_3","title":"Deprecated","text":"<ul> <li>After calling <code>FeedbackDataset.push_to_argilla</code>, calling <code>push_to_argilla</code> again won't do anything since the dataset is already pushed to Argilla (#3465).</li> <li>After calling <code>FeedbackDataset.push_to_argilla</code>, calling <code>fetch_records</code> won't do anything since the records are lazily fetched from Argilla (#3465).</li> <li>After calling <code>FeedbackDataset.push_to_argilla</code>, the Argilla ID is no longer stored in the attribute/property <code>argilla_id</code> but in <code>id</code> instead (#3465).</li> </ul>"},{"location":"community/changelog/#1133","title":"1.13.3","text":""},{"location":"community/changelog/#fixed_20","title":"Fixed","text":"<ul> <li>Fixed <code>ModuleNotFoundError</code> caused because the <code>argilla.utils.telemetry</code> module used in the <code>ArgillaTrainer</code> was importing an optional dependency not installed by default (#3471).</li> <li>Fixed <code>ImportError</code> caused because the <code>argilla.client.feedback.config</code> module was importing <code>pyyaml</code> optional dependency not installed by default (#3471).</li> </ul>"},{"location":"community/changelog/#1132","title":"1.13.2","text":""},{"location":"community/changelog/#fixed_21","title":"Fixed","text":"<ul> <li>The <code>suggestion_type_enum</code> ENUM data type created in PostgreSQL didn't have any value (#3445).</li> </ul>"},{"location":"community/changelog/#1131","title":"1.13.1","text":""},{"location":"community/changelog/#fixed_22","title":"Fixed","text":"<ul> <li>Fix database migration for PostgreSQL (See #3438)</li> </ul>"},{"location":"community/changelog/#1130","title":"1.13.0","text":""},{"location":"community/changelog/#added_16","title":"Added","text":"<ul> <li>Added <code>GET /api/v1/users/{user_id}/workspaces</code> endpoint to list the workspaces to which a user belongs (#3308 and #3343).</li> <li>Added <code>HuggingFaceDatasetMixin</code> for internal usage, to detach the <code>FeedbackDataset</code> integrations from the class itself, and use Mixins instead (#3326).</li> <li>Added <code>GET /api/v1/records/{record_id}/suggestions</code> API endpoint to get the list of suggestions for the responses associated to a record (#3304).</li> <li>Added <code>POST /api/v1/records/{record_id}/suggestions</code> API endpoint to create a suggestion for a response associated to a record (#3304).</li> <li>Added support for <code>RankingQuestionStrategy</code>, <code>RankingQuestionUnification</code> and the <code>.for_text_classification</code> method for the <code>TrainingTaskMapping</code> (#3364)</li> <li>Added <code>PUT /api/v1/records/{record_id}/suggestions</code> API endpoint to create or update a suggestion for a response associated to a record (#3304 &amp; 3391).</li> <li>Added <code>suggestions</code> attribute to <code>FeedbackRecord</code>, and allow adding and retrieving suggestions from the Python client (#3370)</li> <li>Added <code>allowed_for_roles</code> Python decorator to check whether the current user has the required role to access the decorated function/method for <code>User</code> and <code>Workspace</code> (#3383)</li> <li>Added API and Python Client support for workspace deletion (Closes #3260)</li> <li>Added <code>GET /api/v1/me/workspaces</code> endpoint to list the workspaces of the current active user (#3390)</li> </ul>"},{"location":"community/changelog/#changed_13","title":"Changed","text":"<ul> <li>Updated output payload for <code>GET /api/v1/datasets/{dataset_id}/records</code>, <code>GET /api/v1/me/datasets/{dataset_id}/records</code>, <code>POST /api/v1/me/datasets/{dataset_id}/records/search</code> endpoints to include the suggestions of the records based on the value of the <code>include</code> query parameter (#3304).</li> <li>Updated <code>POST /api/v1/datasets/{dataset_id}/records</code> input payload to add suggestions (#3304).</li> <li>The <code>POST /api/datasets/:dataset-id/:task/bulk</code> endpoints don't create the dataset if does not exists (Closes #3244)</li> <li>Added Telemetry support for <code>ArgillaTrainer</code> (closes #3325)</li> <li><code>User.workspaces</code> is no longer an attribute but a property, and is calling <code>list_user_workspaces</code> to list all the workspace names for a given user ID (#3334)</li> <li>Renamed <code>FeedbackDatasetConfig</code> to <code>DatasetConfig</code> and export/import from YAML as default instead of JSON (just used internally on <code>push_to_huggingface</code> and <code>from_huggingface</code> methods of <code>FeedbackDataset</code>) (#3326).</li> <li>The protected metadata fields support other than textual info - existing datasets must be reindex. See docs for more detail (Closes #3332).</li> <li>Updated <code>Dockerfile</code> parent image from <code>python:3.9.16-slim</code> to <code>python:3.10.12-slim</code> (#3425).</li> <li>Updated <code>quickstart.Dockerfile</code> parent image from <code>elasticsearch:8.5.3</code> to <code>argilla/argilla-server:${ARGILLA_VERSION}</code> (#3425).</li> </ul>"},{"location":"community/changelog/#removed_5","title":"Removed","text":"<ul> <li>Removed support to non-prefixed environment variables. All valid env vars start with <code>ARGILLA_</code> (See #3392).</li> </ul>"},{"location":"community/changelog/#fixed_23","title":"Fixed","text":"<ul> <li>Fixed <code>GET /api/v1/me/datasets/{dataset_id}/records</code> endpoint returning always the responses for the records even if <code>responses</code> was not provided via the <code>include</code> query parameter (#3304).</li> <li>Values for protected metadata fields are not truncated (Closes #3331).</li> <li>Big number ids are properly rendered in UI (Closes #3265)</li> <li>Fixed <code>ArgillaDatasetCard</code> to include the values/labels for all the existing questions (#3366)</li> </ul>"},{"location":"community/changelog/#deprecated_4","title":"Deprecated","text":"<ul> <li>Integer support for record id in text classification, token classification and text2text datasets.</li> </ul>"},{"location":"community/changelog/#1121","title":"1.12.1","text":""},{"location":"community/changelog/#fixed_24","title":"Fixed","text":"<ul> <li>Using <code>rg.init</code> with default <code>argilla</code> user skips setting the default workspace if not available. (Closes #3340)</li> <li>Resolved wrong import structure for <code>ArgillaTrainer</code> and <code>TrainingTaskMapping</code> (Closes #3345)</li> <li>Pin pydantic dependency to version &lt; 2 (Closes 3348)</li> </ul>"},{"location":"community/changelog/#1120","title":"1.12.0","text":""},{"location":"community/changelog/#added_17","title":"Added","text":"<ul> <li>Added <code>RankingQuestionSettings</code> class allowing to create ranking questions in the API using <code>POST /api/v1/datasets/{dataset_id}/questions</code> endpoint (#3232)</li> <li>Added <code>RankingQuestion</code> in the Python client to create ranking questions (#3275).</li> <li>Added <code>Ranking</code> component in feedback task question form (#3177 &amp; #3246).</li> <li>Added <code>FeedbackDataset.prepare_for_training</code> method for generaring a framework-specific dataset with the responses provided for <code>RatingQuestion</code>, <code>LabelQuestion</code> and <code>MultiLabelQuestion</code> (#3151).</li> <li>Added <code>ArgillaSpaCyTransformersTrainer</code> class for supporting the training with <code>spacy-transformers</code> (#3256).</li> </ul>"},{"location":"community/changelog/#docs","title":"Docs","text":"<ul> <li>Added instructions for how to run the Argilla frontend in the developer docs (#3314).</li> </ul>"},{"location":"community/changelog/#changed_14","title":"Changed","text":"<ul> <li>All docker related files have been moved into the <code>docker</code> folder (#3053).</li> <li><code>release.Dockerfile</code> have been renamed to <code>Dockerfile</code> (#3133).</li> <li>Updated <code>rg.load</code> function to raise a <code>ValueError</code> with a explanatory message for the cases in which the user tries to use the function to load a <code>FeedbackDataset</code> (#3289).</li> <li>Updated <code>ArgillaSpaCyTrainer</code> to allow re-using <code>tok2vec</code> (#3256).</li> </ul>"},{"location":"community/changelog/#fixed_25","title":"Fixed","text":"<ul> <li>Check available workspaces on Argilla on <code>rg.set_workspace</code> (Closes #3262)</li> </ul>"},{"location":"community/changelog/#1110","title":"1.11.0","text":""},{"location":"community/changelog/#fixed_26","title":"Fixed","text":"<ul> <li>Replaced <code>np.float</code> alias by <code>float</code> to avoid <code>AttributeError</code> when using <code>find_label_errors</code> function with <code>numpy&gt;=1.24.0</code> (#3214).</li> <li>Fixed <code>format_as(\"datasets\")</code> when no responses or optional respones in <code>FeedbackRecord</code>, to set their value to what \ud83e\udd17 Datasets expects instead of just <code>None</code> (#3224).</li> <li>Fixed <code>push_to_huggingface()</code> when <code>generate_card=True</code> (default behaviour), as we were passing a sample record to the <code>ArgillaDatasetCard</code> class, and <code>UUID</code>s introduced in 1.10.0 (#3192), are not JSON-serializable (#3231).</li> <li>Fixed <code>from_argilla</code> and <code>push_to_argilla</code> to ensure consistency on both field and question re-construction, and to ensure <code>UUID</code>s are properly serialized as <code>str</code>, respectively (#3234).</li> <li>Refactored usage of <code>import argilla as rg</code> to clarify package navigation (#3279).</li> </ul>"},{"location":"community/changelog/#docs_1","title":"Docs","text":"<ul> <li>Fixed URLs in Weak Supervision with Sentence Tranformers tutorial #3243.</li> <li>Fixed library buttons' formatting on Tutorials page (#3255).</li> <li>Modified styling of error code outputs in notebooks (#3270).</li> <li>Added ElasticSearch and OpenSearch versions (#3280).</li> <li>Removed template notebook from table of contents (#3271).</li> <li>Fixed tutorials with <code>pip install argilla</code> to not use older versions of the package (#3282).</li> </ul>"},{"location":"community/changelog/#added_18","title":"Added","text":"<ul> <li>Added <code>metadata</code> attribute to the <code>Record</code> of the <code>FeedbackDataset</code> (#3194)</li> <li>New <code>users update</code> command to update the role for an existing user (#3188)</li> <li>New <code>Workspace</code> class to allow users manage their Argilla workspaces and the users assigned to those workspaces via the Python client (#3180)</li> <li>Added <code>User</code> class to let users manage their Argilla users via the Python client (#3169).</li> <li>Added an option to display <code>tqdm</code> progress bar to <code>FeedbackDataset.push_to_argilla</code> when looping over the records to upload (#3233).</li> </ul>"},{"location":"community/changelog/#changed_15","title":"Changed","text":"<ul> <li>The role system now support three different roles <code>owner</code>, <code>admin</code> and <code>annotator</code> (#3104)</li> <li><code>admin</code> role is scoped to workspace-level operations (#3115)</li> <li>The <code>owner</code> user is created among the default pool of users in the quickstart, and the default user in the server has now <code>owner</code> role (#3248), reverting (#3188).</li> </ul>"},{"location":"community/changelog/#deprecated_5","title":"Deprecated","text":"<ul> <li>As of Python 3.7 end-of-life (EOL) on 2023-06-27, Argilla will no longer support Python 3.7 (#3188). More information at https://peps.python.org/pep-0537/</li> </ul>"},{"location":"community/changelog/#1100","title":"1.10.0","text":""},{"location":"community/changelog/#added_19","title":"Added","text":"<ul> <li>Added search component for feedback datasets (#3138)</li> <li>Added markdown support for feedback dataset guidelines (#3153)</li> <li>Added Train button for feedback datasets (#3170)</li> </ul>"},{"location":"community/changelog/#changed_16","title":"Changed","text":"<ul> <li>Updated <code>SearchEngine</code> and <code>POST /api/v1/me/datasets/{dataset_id}/records/search</code> to return the <code>total</code> number of records matching the search query (#3166)</li> </ul>"},{"location":"community/changelog/#fixed_27","title":"Fixed","text":"<ul> <li>Replaced Enum for string value in URLs for client API calls (Closes #3149)</li> <li>Resolve breaking issue with <code>ArgillaSpanMarkerTrainer</code> for Named Entity Recognition with <code>span_marker</code> v1.1.x onwards.</li> <li>Move <code>ArgillaDatasetCard</code> import under <code>@requires_version</code> decorator, so that the <code>ImportError</code> on <code>huggingface_hub</code> is handled properly (#3174)</li> <li>Allow flow <code>FeedbackDataset.from_argilla</code> -&gt; <code>FeedbackDataset.push_to_argilla</code> under different dataset names and/or workspaces (#3192)</li> </ul>"},{"location":"community/changelog/#docs_2","title":"Docs","text":"<ul> <li>Resolved typos in the docs (#3240).</li> <li>Fixed mention of master branch (#3254).</li> </ul>"},{"location":"community/changelog/#190","title":"1.9.0","text":""},{"location":"community/changelog/#added_20","title":"Added","text":"<ul> <li>Added boolean <code>use_markdown</code> property to <code>TextFieldSettings</code> model.</li> <li>Added boolean <code>use_markdown</code> property to <code>TextQuestionSettings</code> model.</li> <li>Added new status <code>draft</code> for the <code>Response</code> model.</li> <li>Added <code>LabelSelectionQuestionSettings</code> class allowing to create label selection (single-choice) questions in the API (#3005)</li> <li>Added <code>MultiLabelSelectionQuestionSettings</code> class allowing to create multi-label selection (multi-choice) questions in the API (#3010).</li> <li>Added <code>POST /api/v1/me/datasets/{dataset_id}/records/search</code> endpoint (#3068).</li> <li>Added new components in feedback task Question form: MultiLabel (#3064) and SingleLabel (#3016).</li> <li>Added docstrings to the <code>pydantic.BaseModel</code>s defined at <code>argilla/client/feedback/schemas.py</code> (#3137)</li> <li>Added the information about executing tests in the developer documentation ([#3143]).</li> </ul>"},{"location":"community/changelog/#changed_17","title":"Changed","text":"<ul> <li>Updated <code>GET /api/v1/me/datasets/:dataset_id/metrics</code> output payload to include the count of responses with <code>draft</code> status.</li> <li>Added <code>LabelSelectionQuestionSettings</code> class allowing to create label selection (single-choice) questions in the API.</li> <li>Added <code>MultiLabelSelectionQuestionSettings</code> class allowing to create multi-label selection (multi-choice) questions in the API.</li> <li>Database setup for unit tests. Now the unit tests use a different database than the one used by the local Argilla server (Closes #2987).</li> <li>Updated <code>alembic</code> setup to be able to autogenerate revision/migration scripts using SQLAlchemy metadata from Argilla server models (#3044)</li> <li>Improved <code>DatasetCard</code> generation on <code>FeedbackDataset.push_to_huggingface</code> when <code>generate_card=True</code>, following the official HuggingFace Hub template, but suited to <code>FeedbackDataset</code>s from Argilla (#3110)</li> </ul>"},{"location":"community/changelog/#fixed_28","title":"Fixed","text":"<ul> <li>Disallow <code>fields</code> and <code>questions</code> in <code>FeedbackDataset</code> with the same name (#3126).</li> <li>Fixed broken links in the documentation and updated the development branch name from <code>development</code> to <code>develop</code> ([#3145]).</li> </ul>"},{"location":"community/changelog/#180","title":"1.8.0","text":""},{"location":"community/changelog/#added_21","title":"Added","text":"<ul> <li><code>/api/v1/datasets</code> new endpoint to list and create datasets (#2615).</li> <li><code>/api/v1/datasets/{dataset_id}</code> new endpoint to get and delete datasets (#2615).</li> <li><code>/api/v1/datasets/{dataset_id}/publish</code> new endpoint to publish a dataset (#2615).</li> <li><code>/api/v1/datasets/{dataset_id}/questions</code> new endpoint to list and create dataset questions (#2615)</li> <li><code>/api/v1/datasets/{dataset_id}/fields</code> new endpoint to list and create dataset fields (#2615)</li> <li><code>/api/v1/datasets/{dataset_id}/questions/{question_id}</code> new endpoint to delete a dataset questions (#2615)</li> <li><code>/api/v1/datasets/{dataset_id}/fields/{field_id}</code> new endpoint to delete a dataset field (#2615)</li> <li><code>/api/v1/workspaces/{workspace_id}</code> new endpoint to get workspaces by id (#2615)</li> <li><code>/api/v1/responses/{response_id}</code> new endpoint to update and delete a response (#2615)</li> <li><code>/api/v1/datasets/{dataset_id}/records</code> new endpoint to create and list dataset records (#2615)</li> <li><code>/api/v1/me/datasets</code> new endpoint to list user visible datasets (#2615)</li> <li><code>/api/v1/me/dataset/{dataset_id}/records</code> new endpoint to list dataset records with user responses (#2615)</li> <li><code>/api/v1/me/datasets/{dataset_id}/metrics</code> new endpoint to get the dataset user metrics (#2615)</li> <li><code>/api/v1/me/records/{record_id}/responses</code> new endpoint to create record user responses (#2615)</li> <li>showing new feedback task datasets in datasets list ([#2719])</li> <li>new page for feedback task ([#2680])</li> <li>show feedback task metrics ([#2822])</li> <li>user can delete dataset in dataset settings page ([#2792])</li> <li>Support for <code>FeedbackDataset</code> in Python client (parent PR #2615, and nested PRs: [#2949], [#2827], [#2943], [#2945], [#2962], and [#3003])</li> <li>Integration with the HuggingFace Hub ([#2949])</li> <li>Added <code>ArgillaPeftTrainer</code> for text and token classificaiton #2854</li> <li>Added <code>predict_proba()</code> method to <code>ArgillaSetFitTrainer</code></li> <li>Added <code>ArgillaAutoTrainTrainer</code> for Text Classification #2664</li> <li>New <code>database revisions</code> command showing database revisions info</li> </ul>"},{"location":"community/changelog/#fixes","title":"Fixes","text":"<ul> <li>Avoid rendering html for invalid html strings in Text2text ([#2911]https://github.com/argilla-io/argilla/issues/2911)</li> </ul>"},{"location":"community/changelog/#changed_18","title":"Changed","text":"<ul> <li>The <code>database migrate</code> command accepts a <code>--revision</code> param to provide specific revision id</li> <li><code>tokens_length</code> metrics function returns empty data (#3045)</li> <li><code>token_length</code> metrics function returns empty data (#3045)</li> <li><code>mention_length</code> metrics function returns empty data (#3045)</li> <li><code>entity_density</code> metrics function returns empty data (#3045)</li> </ul>"},{"location":"community/changelog/#deprecated_6","title":"Deprecated","text":"<ul> <li>Using Argilla with Python 3.7 runtime is deprecated and support will be removed from version 1.11.0 (#2902)</li> <li><code>tokens_length</code> metrics function has been deprecated and will be removed in 1.10.0 (#3045)</li> <li><code>token_length</code> metrics function has been deprecated and will be removed in 1.10.0 (#3045)</li> <li><code>mention_length</code> metrics function has been deprecated and will be removed in 1.10.0 (#3045)</li> <li><code>entity_density</code> metrics function has been deprecated and will be removed in 1.10.0 (#3045)</li> </ul>"},{"location":"community/changelog/#removed_6","title":"Removed","text":"<ul> <li>Removed mention <code>density</code>, <code>tokens_length</code> and <code>chars_length</code> metrics from token classification metrics storage (#3045)</li> <li>Removed token <code>char_start</code>, <code>char_end</code>, <code>tag</code>, and <code>score</code> metrics from token classification metrics storage (#3045)</li> <li>Removed tags-related metrics from token classification metrics storage (#3045)</li> </ul>"},{"location":"community/changelog/#170","title":"1.7.0","text":""},{"location":"community/changelog/#added_22","title":"Added","text":"<ul> <li>add <code>max_retries</code> and <code>num_threads</code> parameters to <code>rg.log</code> to run data logging request concurrently with backoff retry policy. See #2458 and #2533</li> <li><code>rg.load</code> accepts <code>include_vectors</code> and <code>include_metrics</code> when loading data. Closes #2398</li> <li>Added <code>settings</code> param to <code>prepare_for_training</code> (#2689)</li> <li>Added <code>prepare_for_training</code> for <code>openai</code> (#2658)</li> <li>Added <code>ArgillaOpenAITrainer</code> (#2659)</li> <li>Added <code>ArgillaSpanMarkerTrainer</code> for Named Entity Recognition (#2693)</li> <li>Added <code>ArgillaTrainer</code> CLI support. Closes (#2809)</li> </ul>"},{"location":"community/changelog/#fixes_1","title":"Fixes","text":"<ul> <li>fix image alignment on token classification</li> </ul>"},{"location":"community/changelog/#changed_19","title":"Changed","text":"<ul> <li>Argilla quickstart image dependencies are externalized into <code>quickstart.requirements.txt</code>. See #2666</li> <li>bulk endpoints will upsert data when record <code>id</code> is present. Closes #2535</li> <li>moved from <code>click</code> to <code>typer</code> CLI support. Closes (#2815)</li> <li>Argilla server docker image is built with PostgreSQL support. Closes #2686</li> <li>The <code>rg.log</code> computes all batches and raise an error for all failed batches.</li> <li>The default batch size for <code>rg.log</code> is now 100.</li> </ul>"},{"location":"community/changelog/#fixed_29","title":"Fixed","text":"<ul> <li><code>argilla.training</code> bugfixes and unification (#2665)</li> <li>Resolved several small bugs in the <code>ArgillaTrainer</code>.</li> </ul>"},{"location":"community/changelog/#deprecated_7","title":"Deprecated","text":"<ul> <li>The <code>rg.log_async</code> function is deprecated and will be removed in next minor release.</li> </ul>"},{"location":"community/changelog/#160","title":"1.6.0","text":""},{"location":"community/changelog/#added_23","title":"Added","text":"<ul> <li><code>ARGILLA_HOME_PATH</code> new environment variable (#2564).</li> <li><code>ARGILLA_DATABASE_URL</code> new environment variable (#2564).</li> <li>Basic support for user roles with <code>admin</code> and <code>annotator</code> (#2564).</li> <li><code>id</code>, <code>first_name</code>, <code>last_name</code>, <code>role</code>, <code>inserted_at</code> and <code>updated_at</code> new user fields (#2564).</li> <li><code>/api/users</code> new endpoint to list and create users (#2564).</li> <li><code>/api/users/{user_id}</code> new endpoint to delete users (#2564).</li> <li><code>/api/workspaces</code> new endpoint to list and create workspaces (#2564).</li> <li><code>/api/workspaces/{workspace_id}/users</code> new endpoint to list workspace users (#2564).</li> <li><code>/api/workspaces/{workspace_id}/users/{user_id}</code> new endpoint to create and delete workspace users (#2564).</li> <li><code>argilla.tasks.users.migrate</code> new task to migrate users from old YAML file to database (#2564).</li> <li><code>argilla.tasks.users.create</code> new task to create a user (#2564).</li> <li><code>argilla.tasks.users.create_default</code> new task to create a user with default credentials (#2564).</li> <li><code>argilla.tasks.database.migrate</code> new task to execute database migrations (#2564).</li> <li><code>release.Dockerfile</code> and <code>quickstart.Dockerfile</code> now creates a default <code>argilladata</code> volume to persist data (#2564).</li> <li>Add user settings page. Closes #2496</li> <li>Added <code>Argilla.training</code> module with support for <code>spacy</code>, <code>setfit</code>, and <code>transformers</code>. Closes #2504</li> </ul>"},{"location":"community/changelog/#fixes_2","title":"Fixes","text":"<ul> <li>Now the <code>prepare_for_training</code> method is working when <code>multi_label=True</code>. Closes #2606</li> </ul>"},{"location":"community/changelog/#changed_20","title":"Changed","text":"<ul> <li><code>ARGILLA_USERS_DB_FILE</code> environment variable now it's only used to migrate users from YAML file to database (#2564).</li> <li><code>full_name</code> user field is now deprecated and <code>first_name</code> and <code>last_name</code> should be used instead (#2564).</li> <li><code>password</code> user field now requires a minimum of <code>8</code> and a maximum of <code>100</code> characters in size (#2564).</li> <li><code>quickstart.Dockerfile</code> image default users from <code>team</code> and <code>argilla</code> to <code>admin</code> and <code>annotator</code> including new passwords and API keys (#2564).</li> <li>Datasets to be managed only by users with <code>admin</code> role (#2564).</li> <li>The list of rules is now accessible while metrics are computed. Closes#2117</li> <li>Style updates for weak labeling and adding feedback toast when delete rules. See #2626 and #2648</li> </ul>"},{"location":"community/changelog/#removed_7","title":"Removed","text":"<ul> <li><code>email</code> user field (#2564).</li> <li><code>disabled</code> user field (#2564).</li> <li>Support for private workspaces (#2564).</li> <li><code>ARGILLA_LOCAL_AUTH_DEFAULT_APIKEY</code> and <code>ARGILLA_LOCAL_AUTH_DEFAULT_PASSWORD</code> environment variables. Use <code>python -m argilla.tasks.users.create_default</code> instead (#2564).</li> <li>The old headers for <code>API Key</code> and <code>workspace</code> from python client</li> <li>The default value for old <code>API Key</code> constant. Closes #2251</li> </ul>"},{"location":"community/changelog/#151-2023-03-30","title":"1.5.1 - 2023-03-30","text":""},{"location":"community/changelog/#fixes_3","title":"Fixes","text":"<ul> <li>Copying datasets between workspaces with proper owner/workspace info. Closes #2562</li> <li>Copy dataset with empty workspace to the default user workspace 905d4de</li> <li>Using elasticsearch config to request backend version. Closes #2311</li> <li>Remove sorting by score in labels. Closes #2622</li> </ul>"},{"location":"community/changelog/#changed_21","title":"Changed","text":"<ul> <li>Update field name in metadata for image url. See #2609</li> <li>Improvements in tutorial doc cards. Closes #2216</li> </ul>"},{"location":"community/changelog/#150-2023-03-21","title":"1.5.0 - 2023-03-21","text":""},{"location":"community/changelog/#added_24","title":"Added","text":"<ul> <li>Add the fields to retrieve when loading the data from argilla. <code>rg.load</code> takes too long because of the vector field, even when users don't need it. Closes #2398</li> <li>Add new page and components for dataset settings. Closes #2442</li> <li>Add ability to show image in records (for TokenClassification and TextClassification) if an URL is passed in metadata with the key _image_url</li> <li>Non-searchable fields support in metadata. #2570</li> <li>Add record ID references to the prepare for training methods. Closes #2483</li> <li>Add tutorial on Image Classification. #2420</li> <li>Add Train button, visible for \"admin\" role, with code snippets from a selection of libraries. Closes [#2591] (https://github.com/argilla-io/argilla/pull/2591)</li> </ul>"},{"location":"community/changelog/#changed_22","title":"Changed","text":"<ul> <li>Labels are now centralized in a specific vuex ORM called GlobalLabel Model, see https://github.com/argilla-io/argilla/issues/2210. This model is the same for TokenClassification and TextClassification (so both task have labels with color_id and shortcuts parameters in the vuex ORM)</li> <li>The shortcuts improvement for labels #2339 have been moved to the vuex ORM in dataset settings feature #2444</li> <li>Update \"Define a labeling schema\" section in docs.</li> <li>The record inputs are sorted alphabetically in UI by default. #2581</li> <li>The record inputs are fully visible when pagination size is one and the height of collapsed area size is bigger for laptop screen. #2587</li> </ul>"},{"location":"community/changelog/#fixes_4","title":"Fixes","text":"<ul> <li>Allow URL to be clickable in Jupyter notebook again. Closes #2527</li> </ul>"},{"location":"community/changelog/#removed_8","title":"Removed","text":"<ul> <li>Removing some data scan deprecated endpoints used by old clients. This change will break compatibility with client <code>&lt;v1.3.0</code></li> <li>Stop using old scan deprecated endpoints in python client. This logic will break client compatibility with server version <code>&lt;1.3.0</code></li> <li>Remove the previous way to add labels through the dataset page. Now labels can be added only through dataset settings page.</li> </ul>"},{"location":"community/contributor/","title":"How to contribute?","text":"<p>Thank you for investing your time in contributing to the project! Any contribution you make will be reflected in the most recent version of Argilla \ud83e\udd29.</p> New to contributing in general? <p>If you're a new contributor, read the README to get an overview of the project. In addition, here are some resources to help you get started with open-source contributions:</p> <ul> <li>Discord: You are welcome to join the Argilla Discord community, where you can keep in touch with other users, contributors and the Argilla team. In the following section, you can find more information on how to get started in Discord.</li> <li>Git: This is a very useful tool to keep track of the changes in your files. Using the command-line interface (CLI), you can make your contributions easily. For that, you need to have it installed and updated on your computer.</li> <li>GitHub: It is a platform and cloud-based service that uses git and allows developers to collaborate on projects. To contribute to Argilla, you'll need to create an account. Check the Contributor Workflow with Git and Github for more info.</li> <li>Developer Documentation: To collaborate, you'll need to set up an efficient environment. Check the developer documentation to know how to do it.</li> <li>Schedule a meeting with our developer advocate: If you have more questions, do not hesitate to contact our developer advocate and schedule a meeting.</li> </ul>"},{"location":"community/contributor/#first-contact-in-discord","title":"First Contact in Discord","text":"<p>Discord is a handy tool for more casual conversations and to answer day-to-day questions. As part of Hugging Face, we have set up some Argilla channels on the server. Click here to join the Hugging Face Discord community effortlessly.</p> <p>When part of the Hugging Face Discord, you can select \"Channels &amp; roles\" and select \"Argilla\" along with any of the other groups that are interesting to you. \"Argilla\" will cover anything about argilla and distilabel. You can join the following channels:</p> <ul> <li>#argilla-general: \ud83d\udce3 Stay up-to-date and general discussions.</li> <li>#argilla-help: \ud83d\ude4b\u200d\u2640\ufe0f Need assistance? We're always here to help. Select the appropriate label (argilla or distilabel) for your issue and post it.</li> </ul> <p>So now there is only one thing left to do: introduce yourself and talk to the community. You'll always be welcome! \ud83e\udd17\ud83d\udc4b</p>"},{"location":"community/contributor/#contributor-workflow-with-git-and-github","title":"Contributor Workflow with Git and GitHub","text":"<p>If you're working with Argilla and suddenly a new idea comes to your mind or you find an issue that can be improved, it's time to actively participate and contribute to the project!</p>"},{"location":"community/contributor/#report-an-issue","title":"Report an issue","text":"<p>If you spot a problem, search if an issue already exists. You can use the <code>Label</code> filter. If that is the case, participate in the conversation. If it does not exist, create an issue by clicking on <code>New Issue</code>.</p> <p></p> <p>This will show various templates, choose the one that best suits your issue.</p> <p></p> <p>Below, you can see an example of the <code>Feature request</code> template. Once you choose one, you will need to fill in it following the guidelines. Try to be as clear as possible. In addition, you can assign yourself to the issue and add or choose the right labels. Finally, click on <code>Submit new issue</code>.</p> <p></p>"},{"location":"community/contributor/#work-with-a-fork","title":"Work with a fork","text":""},{"location":"community/contributor/#fork-the-argilla-repository","title":"Fork the Argilla repository","text":"<p>After having reported the issue, you can start working on it. For that, you will need to create a fork of the project. To do that, click on the <code>Fork</code> button.</p> <p></p> <p>Now, fill in the information. Remember to uncheck the <code>Copy develop branch only</code> if you are going to work in or from another branch (for instance, to fix documentation the <code>main</code> branch is used). Then, click on <code>Create fork</code>.</p> <p></p> <p>Now, you will be redirected to your fork. You can see that you are in your fork because the name of the repository will be your <code>username/argilla</code>, and it will indicate <code>forked from argilla-io/argilla</code>.</p>"},{"location":"community/contributor/#clone-your-forked-repository","title":"Clone your forked repository","text":"<p>In order to make the required adjustments, clone the forked repository to your local machine. Choose the destination folder and run the following command:</p> <pre><code>git clone https://github.com/[your-github-username]/argilla.git\ncd argilla\n</code></pre> <p>To keep your fork\u2019s main/develop branch up to date with our repo, add it as an upstream remote branch. For more info, check the documentation.</p> <pre><code>git remote add upstream https://github.com/argilla-io/argilla.git\n</code></pre>"},{"location":"community/contributor/#create-a-new-branch","title":"Create a new branch","text":"<p>For each issue you're addressing, it's advisable to create a new branch. GitHub offers a straightforward method to streamline this process.</p> <p>\u26a0\ufe0f Never work directly on the <code>main</code> or <code>develop</code> branch. Always create a new branch for your changes.</p> <p>Navigate to your issue and on the right column, select <code>Create a branch</code>.</p> <p></p> <p>After the new window pops up, the branch will be named after the issue, include a prefix such as feature/, bug/, or docs/ to facilitate quick recognition of the issue type. In the <code>Repository destination</code>, pick your fork ( [your-github-username]/argilla), and then select <code>Change branch source</code> to specify the source branch for creating the new one. Complete the process by clicking <code>Create branch</code>.</p> <p>\ud83e\udd14 Remember that the <code>main</code> branch is only used to work with the documentation. For any other changes, use the <code>develop</code> branch.</p> <p></p> <p>Now, locally change to the new branch you just created.</p> <pre><code>git fetch origin\ngit checkout [branch-name]\n</code></pre>"},{"location":"community/contributor/#use-changelogmd","title":"Use CHANGELOG.md","text":"<p>If you are working on a new feature, it is a good practice to make note of it for others to keep up with the changes. For that, we utilize the <code>CHANGELOG.md</code> file in the root directory. This file is used to list changes made in each version of the project and there are headers that we use to denote each type of change.</p> <ul> <li>Added: for new features.</li> <li>Changed: for changes in existing functionality.</li> <li>Deprecated: for soon-to-be removed features.</li> <li>Removed: for now removed features.</li> <li>Fixed: for any bug fixes.</li> <li>Security: in case of vulnerabilities.</li> </ul> <p>A sample addition would be:</p> <pre><code>- Fixed the key errors for the `init` method ([#NUMBER_OF_PR](LINK_TO_PR)). Contributed by @github_handle.\n</code></pre> <p>You can have a look at the CHANGELOG.md file to see more cases and examples.</p>"},{"location":"community/contributor/#make-changes-and-push-them","title":"Make changes and push them","text":"<p>Make the changes you want in your local repository, and test that everything works and you are following the guidelines. Check the documentation for more information about the development.</p> <p>Once you have finished, you can check the status of your repository and synchronize with the upstreaming repo with the following command:</p> <pre><code># Check the status of your repository\ngit status\n\n# Synchronize with the upstreaming repo\ngit checkout [branch-name]\ngit rebase [default-branch]\n</code></pre> <p>If everything is right, we need to commit and push the changes to your fork. For that, run the following commands:</p> <pre><code># Add the changes to the staging area\ngit add filename\n\n# Commit the changes by writing a proper message\ngit commit -m \"commit-message\"\n\n# Push the changes to your fork\ngit push origin [branch-name]\n</code></pre> <p>When pushing, you will be asked to enter your GitHub login credentials. Once the push is complete, all local commits will be on your GitHub repository.</p>"},{"location":"community/contributor/#create-a-pull-request","title":"Create a pull request","text":"<p>Come back to GitHub, navigate to the original repository where you created your fork, and click on <code>Compare &amp; pull request</code>.</p> <p></p> <p>First, click on <code>compare across forks</code> and select the right repositories and branches.</p> <p>In the base repository, keep in mind to select either <code>main</code> or <code>develop</code> based on the modifications made. In the head repository, indicate your forked repository and the branch corresponding to the issue.</p> <p></p> <p>Then, fill in the pull request template. You should add a prefix to the PR name as we did with the branch above. If you are working on a new feature, you can name your PR as <code>feat: TITLE</code>. If your PR consists of a solution for a bug, you can name your PR as <code>bug: TITLE</code> And, if your work is for improving the documentation, you can name your PR as <code>docs: TITLE</code>.</p> <p>In addition, on the right side, you can select a reviewer (for instance, if you discussed the issue with a member of the Argilla team) and assign the pull request to yourself. It is highly advisable to add labels to PR as well. You can do this again by the labels section right to the screen. For instance, if you are addressing a bug, add the <code>bug</code> label or if the PR is related to the documentation, add the <code>documentation</code> label. This way, PRs can be easily filtered.</p> <p>Finally, fill in the template carefully and follow the guidelines. Remember to link the original issue and enable the checkbox to allow maintainer edits so the branch can be updated for a merge. Then, click on <code>Create pull request</code>.</p>"},{"location":"community/contributor/#review-your-pull-request","title":"Review your pull request","text":"<p>Once you submit your PR, a team member will review your proposal. We may ask questions, request additional information or ask for changes to be made before a PR can be merged, either using suggested changes or pull request comments.</p> <p>You can apply the changes directly through the UI (check the files changed and click on the right-corner three dots, see image below) or from your fork, and then commit them to your branch. The PR will be updated automatically and the suggestions will appear as outdated.</p> <p></p> <p>If you run into any merge issues, check out this git tutorial to help you resolve merge conflicts and other issues.</p>"},{"location":"community/contributor/#your-pr-is-merged","title":"Your PR is merged!","text":"<p>Congratulations \ud83c\udf89\ud83c\udf8a We thank you \ud83e\udd29</p> <p>Once your PR is merged, your contributions will be publicly visible on the Argilla GitHub.</p> <p>Additionally, we will include your changes in the next release based on our development branch.</p>"},{"location":"community/contributor/#additional-resources","title":"Additional resources","text":"<p>Here are some helpful resources for your reference.</p> <ul> <li>Configuring Discord, a guide to learn how to get started with Discord.</li> <li>Pro Git, a book to learn Git.</li> <li>Git in VSCode, a guide to learn how to easily use Git in VSCode.</li> <li>GitHub Skills, an interactive course to learn GitHub.</li> </ul>"},{"location":"community/popular_issues/","title":"Issue dashboard","text":"Most engaging open issuesLatest issues open by the communityPlanned issues for upcoming releases Rank Issue Reactions Comments 1 1607 - Support for hierarchical multilabel text classification (taxonomy) \ud83d\udc4d 4 \ud83d\udcac 15 2 4637 - [FEATURE] Label breakdown in Feedback dataset stats \ud83d\udc4d 4 \ud83d\udcac 3 3 4658 - Active listeners for Feedback Dataset \ud83d\udc4d 4 \ud83d\udcac 2 4 4867 - [FEATURE] Add dependencies to support dev mode on HF Spaces \ud83d\udc4d 3 \ud83d\udcac 4 5 4964 - [DOCS] Improvements to docker-compose getting started installation guide \ud83d\udc4d 3 \ud83d\udcac 3 6 3338 - [FEATURE] Add conversation support to Feedback \ud83d\udc4d 2 \ud83d\udcac 10 7 1800 - Add comments/notes to annotation datasets to share with teammates.  \ud83d\udc4d 2 \ud83d\udcac 6 8 1837 - Custom Record UI Templates \ud83d\udc4d 2 \ud83d\udcac 4 9 1630 - Accepting several predictions/annotations for the same record \ud83d\udc4d 2 \ud83d\udcac 2 10 4823 - [FEATURE] <code>ImageField</code> \ud83d\udc4d 2 \ud83d\udcac 1 Rank Issue Author 1 \ud83d\udfe2 5175 - Not possible to set API URL in custom docker compose deployments in version <code>1.29.0</code> by stphnthiel 2 \ud83d\udfe2 5167 - [BUG-python/deployment] Huggingface Space crashed  by fangguo1 3 \ud83d\udfe2 5134 - [DOCS]  I cannot create the space in hugging face in this multiclass doc by micuentadecasa 4 \ud83d\udfe2 5133 - [BUG-python/deployment] by HPeterr 5 \ud83d\udfe2 5123 - [BUG-python/deployment] <code>KeyError: 'text'</code> when running <code>metric.compute(\"alpha\")</code> on a <code>FeedbackDataset</code> by mpjuhasz 6 \ud83d\udfe3 5122 - [BUG-python/deployment] Issue adding records by MoritzLaurer 7 \ud83d\udfe2 5121 - [BUG-python/deployment] Confusion about dataset_argilla.exists() / .delete() / .create() by MoritzLaurer 8 \ud83d\udfe3 5103 - [FEATURE] by Harry-gill 9 \ud83d\udfe3 5098 - [BUG-python/deployment] Argilla==2.0.0rc1, TypeError: init() got an unexpected keyword argument 'extra_headers' by MoritzLaurer 10 \ud83d\udfe3 5097 - [BUG-UI/UX] Issues with argilla/argilla-template-space-with-oauth space by MoritzLaurer Rank Issue Milestone 1 \ud83d\udfe2 5177 - [FEATURE] Migrate 'media to html' utility methods to v2 sdk v2.0.0 2 \ud83d\udfe2 5157 - [ENHANCEMENT] Move the resource existence to  the <code>rg.Argilla</code> client v2.0.0 3 \ud83d\udfe2 5144 - [DOCS] fix <code>pip install argilla&lt;2</code> within the old argilla docs. v2.0.0 4 \ud83d\udfe2 5104 - [FEATURE] relax <code>typer</code> constraints v2.0.0 5 \ud83d\udfe2 5091 - [DOCS] Document how to setup HF OAuth v2.0.0 6 \ud83d\udfe2 5016 - [BUG] Search API for search all responses generating error v2.0.0 7 \ud83d\udfe2 4732 - [FEATURE] Support Bulk view for<code>SpanQuestion</code> v2.0.0 8 \ud83d\udfe2 4827 - [FEATURE] New UI for datasets page v2.0.0 9 \ud83d\udfe2 4951 - [DOCS] Add tutorials pages to new documentation v2.1.0 10 \ud83d\udfe2 4950 - [DOCS] Add integrations to new documentation v2.1.0 <p>Last update: 2024-07-08</p>"},{"location":"getting_started/faq/","title":"FAQs","text":"What is Argilla? <p>Argilla is a collaboration platform for AI engineers and domain experts that require high-quality outputs, full data ownership, and overall efficiency. It is designed to help you achieve and keep high-quality data standards, store your training data, store the results of your models, evaluate their performance, and improve the data through human and AI feedback.</p> Does Argilla cost money? <p>No. Argilla is an open-source project and is free to use. You can deploy Argilla on your own infrastructure or use our cloud offering.</p> What data types does Argilla support? <p>Text data, mostly. Argilla natively supports textual data, however, we do support rich text, which means you can represent different types of data in Argilla as long as you can convert it to text. For example, you can store images, audio, video, and any other type of data as long as you can convert it to their base64 representation or render them as HTML in for example an IFrame.</p> Does Argilla train models? <p>No. Argilla is a collaboration platform to achieve and keep high-quality data standards. You can use Argilla to store your training data, store the results of your models, evaluate their performance and improve the data. For training models, you can use any machine learning framework or library that you prefer even though we recommend starting with Hugging Face Transformers.</p> Does Argilla provide annotation workforces? <p>Yes, kind of. We don't provide annotation workforce in-house but we do have partnerships with workforce providers that ensure ethical practices and secure work environments. Feel free to schedule a meeting here or contact us via email.</p> How does Argilla differ from competitors like Lilac, Snorkel, Prodigy and Scale? <p>Argilla distinguishes itself for its focus on specific use cases and human-in-the-loop approaches. While it does offer programmatic features, Argilla\u2019s core value lies in actively involving human experts in the tool-building process, setting it apart from other competitors.</p> <p>Furthermore, Argilla places particular emphasis on smooth integration with other tools in the community, particularly within the realms of MLOps and NLP. So, its compatibility with popular frameworks like spaCy and Hugging Face makes it exceptionally user-friendly and accessible.</p> <p>Finally, platforms like Snorkel, Prodigy or Scale, while more comprehensive, often require a significant commitment. Argilla, on the other hand, works more as a component within the MLOps ecosystem, allowing users to begin with specific use cases and then scale up as needed. This flexibility is particularly beneficial for users and customers who prefer to start small and expand their applications over time, as opposed to committing to an all-encompassing platform from the outset.</p> What is the difference between Argilla 2.0 and the legacy datasets in 1.0? <p>Argilla 1.0 relied on 3 main task datasets: <code>DatasetForTextClassification</code>, <code>DatasetForTokenClassification</code>, and <code>DatasetForText2Text</code>. These tasks were designed to be simple, easy to use and high in functionality but they were limited in adaptability. With the introduction of Large Language Models (LLMs) and the increasing complexity of NLP tasks, we realized that we needed to expand the capabilities of Argilla to support more advanced feedback mechanisms which led to the introduction of the <code>FeedbackDataset</code>. Compared to its predecessor it was high in adaptability but still limited in functionality. After having ported all of the functionality of the legacy tasks to the new <code>FeedbackDataset</code>, we decided to deprecate the legacy tasks in favor of a brand new SDK with the <code>FeedbackDataset</code> at its core.</p>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#install-the-sdk-with-pip","title":"Install the SDK with pip","text":"<pre><code>pip install argilla --pre\n</code></pre>"},{"location":"getting_started/installation/#run-the-argilla-server","title":"Run the Argilla server","text":"<p>If you have already deployed Argilla Server, you can skip this step. Otherwise, you can quickly deploy it in two different ways:</p> <ul> <li>Using a HF Space.</li> </ul> <p>Note</p> <p>As this is a release candidate version, you'll need to manually change the version in the HF Space Files &gt; Dockerfile to <code>argilla/argilla-quickstart:v2.0.0rc2</code>.</p> <ul> <li>Locally with Docker.</li> </ul> <pre><code>docker run -d --name quickstart -p 6900:6900 argilla/argilla-quickstart:v2.0.0rc2\n</code></pre>"},{"location":"getting_started/installation/#connect-to-the-argilla-server","title":"Connect to the Argilla server","text":"<p>Get your <code>&lt;api_url&gt;</code>:</p> <ul> <li>If you are using HF Spaces, it should be constructed as follows: <code>https://[your-owner-name]-[your_space_name].hf.space</code></li> <li>If you are using Docker, it is the URL shown in your browser (by default <code>http://localhost:6900</code>)</li> </ul> <p>Get your <code>&lt;api_key&gt;</code> in <code>My Settings</code> in the Argilla UI (by default owner.apikey).</p> <p>Note</p> <p>Make sure to replace <code>&lt;api_url&gt;</code> and <code>&lt;api_key&gt;</code> with your actual values. If you are using a private HF Space, you need to specify your <code>HF_TOKEN</code> which can be found here.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(\n    api_url=\"&lt;api_url&gt;\",\n    api_key=\"&lt;api_key&gt;\",\n    # headers={\"Authorization\": f\"Bearer {HF_TOKEN}\"}\n)\n</code></pre>"},{"location":"getting_started/installation/#developer-documentation","title":"Developer documentation","text":"<p>If you want to contribute to the development of the SDK, you can follow the instructions below.</p>"},{"location":"getting_started/installation/#installation_1","title":"Installation","text":"<p>To install the development dependencies, run the following commands:</p> <pre><code># Install pdm (https://github.com/pdm-project/pdm)\npip install pdm\n\n# Install the package in editable mode\npip install -e .\n\n# Install the development dependencies with pdm\npdm install --dev\n</code></pre>"},{"location":"getting_started/installation/#generating-documentation","title":"Generating documentation","text":"<p>To generate the docs you will need to install the development dependencies, and run the following command to create the development server with <code>mkdocs</code>:</p> <pre><code>mkdocs serve\n</code></pre> <p>You will find the built documentation in <code>http://localhost:8000/argilla-python/</code>.</p>"},{"location":"getting_started/quickstart/","title":"Quickstart","text":"<p>This guide provides a quick overview of the Argilla SDK and how to create your first dataset.</p>"},{"location":"getting_started/quickstart/#setting-up-your-argilla-project","title":"Setting up your Argilla project","text":""},{"location":"getting_started/quickstart/#install-the-sdk-with-pip","title":"Install the SDK with pip","text":"<p>To work with Argilla datasets, you need to use the Argilla SDK. You can install the SDK with pip as follows:</p> <pre><code>pip install argilla --pre\n</code></pre>"},{"location":"getting_started/quickstart/#run-the-argilla-server","title":"Run the Argilla server","text":"<p>If you have already deployed Argilla Server, you can skip this step. Otherwise, you can quickly deploy it in two different ways:</p> <ul> <li>Remotely using a HF Space.</li> </ul> <p>Note</p> <p>As this is a release candidate version, you'll need to manually change the version in the HF Space Files &gt; Dockerfile to <code>argilla/argilla-quickstart:v2.0.0rc2</code>.</p> <ul> <li>Locally using Docker.</li> </ul> <pre><code>docker run -d --name quickstart -p 6900:6900 argilla/argilla-quickstart:v2.0.0rc2\n</code></pre>"},{"location":"getting_started/quickstart/#connect-to-the-argilla-server","title":"Connect to the Argilla server","text":"<p>Get your <code>&lt;api_url&gt;</code>:</p> <ul> <li>If you are using Hugging Face Spaces, the URL should be constructed as follows: <code>https://[your-owner-name]-[your_space_name].hf.space</code></li> <li>If you are using Docker, the URL is the URL shown in your browser (by default <code>http://localhost:6900</code>)</li> </ul> <p>Get your <code>&lt;api_key&gt;</code> in <code>My Settings</code> in the Argilla UI (by default <code>owner.apikey</code>).</p> <p>Note</p> <p>Make sure to replace <code>&lt;api_url&gt;</code> and <code>&lt;api_key&gt;</code> with your actual values. If you are using a private Hugging Face Space, you need to specify your <code>HF_TOKEN</code> which can be found here.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(\n    api_url=\"&lt;api_url&gt;\",\n    api_key=\"&lt;api_key&gt;\"\n    # headers={\"Authorization\": f\"Bearer {HF_TOKEN}\"}\n)\n</code></pre>"},{"location":"getting_started/quickstart/#create-your-first-dataset","title":"Create your first dataset","text":"<p>To create a dataset with a simple text classification task, first, you need to define the dataset settings.</p> <pre><code>settings = rg.Settings(\n    guidelines=\"Classify the reviews as positive or negative.\",\n    fields=[\n        rg.TextField(\n            name=\"review\",\n            title=\"Text from the review\",\n            use_markdown=False,\n        ),\n    ],\n    questions=[\n        rg.LabelQuestion(\n            name=\"my_label\",\n            title=\"In which category does this article fit?\",\n            labels=[\"positive\", \"negative\"],\n        )\n    ],\n)\n</code></pre> <p>Now you can create the dataset with the settings you defined. Publish the dataset to make it available in the UI and add the records.</p> <p>Note</p> <p>The <code>workspace</code> parameter is optional. If you don't specify it, the dataset will be created in the default workspace <code>admin</code>.</p> <pre><code>dataset = rg.Dataset(\n    name=f\"my_first_dataset\",\n    settings=settings,\n    client=client,\n)\ndataset.create()\n</code></pre>"},{"location":"getting_started/quickstart/#add-records-to-your-dataset","title":"Add records to your dataset","text":"<p>Retrieve the data to be added to the dataset. We will use the IMDB dataset from the Hugging Face Datasets library.</p> <pre><code>pip install -qqq datasets\n</code></pre> <pre><code>from datasets import load_dataset\n\ndata = load_dataset(\"imdb\", split=\"train[:100]\").to_list()\n</code></pre> <p>Now you can add the data to your dataset. Use a <code>mapping</code> to indicate which keys/columns in the source data correspond to the Argilla dataset fields.</p> <pre><code>dataset.records.log(records=data, mapping={\"text\": \"review\"})\n</code></pre> <p>\ud83c\udf89 You have successfully created your first dataset with Argilla. You can now access it in the Argilla UI and start annotating the records.</p>"},{"location":"getting_started/quickstart/#more-references","title":"More references","text":"<ul> <li>Installation guide</li> <li>How-to guides</li> <li>API reference</li> </ul>"},{"location":"how_to_guides/","title":"How-to guides","text":"<p>These are the how-to guides for the Argilla SDK. They provide step-by-step instructions for common scenarios, including detailed explanations and code samples.</p> <ul> <li> <p>Manage users and credentials</p> <p>Learn what they are and how to manage (create, read and delete) <code>Users</code> in Argilla.</p> <p> How-to guide</p> </li> <li> <p>Manage workspaces</p> <p>Learn what they are and how to manage (create, read and delete) <code>Workspaces</code> in Argilla.</p> <p> How-to guide</p> </li> <li> <p>Manage and create datasets</p> <p>Learn what they are and how to manage (create, read and delete) <code>Datasets</code> and customize them using the <code>Settings</code> for <code>Fields</code>, <code>Questions</code>,  <code>Metadata</code> and <code>Vectors</code>.</p> <p> How-to guide</p> </li> <li> <p>Add, update, and delete records</p> <p>Learn what they are and how to add, update and delete the values for a <code>Record</code>, which are made up of <code>Metadata</code>, <code>Vectors</code>, <code>Suggestions</code> and <code>Responses</code>.</p> <p> How-to guide</p> </li> <li> <p>Query, filter and export records</p> <p>Learn how to query and filter a <code>Dataset</code> and export their <code>Records</code>.</p> <p> How-to guide</p> </li> <li> <p>Migrate to Argilla V2</p> <p>Learn how to migrate your legacy datasets from Argilla 1.x to 2.x.</p> <p> How-to guide</p> </li> </ul>"},{"location":"how_to_guides/annotate/","title":"Annotate your dataset","text":"<p>To experience the UI features firsthand, you can take a look at the Demo \u2197.</p> <p>Argilla UI offers many functions to help you manage your annotation workflow, aiming to provide the most flexible approach to fit the wide variety of use cases handled by the community.</p>"},{"location":"how_to_guides/annotate/#annotation-interface-overview","title":"Annotation interface overview","text":""},{"location":"how_to_guides/annotate/#flexible-layout","title":"Flexible layout","text":"<p>The UI is responsive with two columns for larger devices and one column for smaller devices. This enables you to annotate data using your mobile phone for simple datasets (i.e., not very long text and 1-2 questions) or resize your screen to get a more compact UI.</p> HeaderLeft paneRight paneLeft bottom panelRight bottom panel <p>At the right side of the navigation breadcrumb, you can customize the dataset settings and edit your profile.</p> <p>This area displays the control panel on the top. The control panel is used for performing keyword-based search, applying filters, and sorting the results.</p> <p>Below the control panel, the record card(s) are displayed one by one (Focus view) or in a vertical list (Bulk view).</p> <p>This is where you annotate your dataset. Simply fill it out as a form, then choose to <code>Submit</code>, <code>Save as Draft</code>, or <code>Discard</code>.</p> <p>This expandable area displays the annotation guidelines. The annotation guidelines can be edited by owner and admin roles in the dataset settings.</p> <p>This expandable area displays your annotation progress.</p>"},{"location":"how_to_guides/annotate/#shortcuts","title":"Shortcuts","text":"<p>The Argilla UI includes a range of shortcuts. For the main actions (submit, discard, save as draft and selecting labels) the keys are showed in the corresponding button.</p> <p>To learn how to move from one question to another or between records using the keyboard, take a look at the table below.</p> <p>Shortcuts provide a smoother annotation experience, especially with datasets using a single question (Label, MultiLabel, Rating, or Ranking).</p> Available shortcuts Action Keys Activate form \u21e5 Tab Move between questions \u2193 Down arrow\u00a0or\u00a0\u2191 Up arrow Select and unselect label 1,\u00a02,\u00a03 Move between labels or ranking options \u21e5 Tab\u00a0or\u00a0\u21e7 Shift\u00a0\u21e5 Tab Select rating and rank 1,\u00a02,\u00a03 Fit span to character selection Hold\u00a0\u21e7 Shift Activate text area \u21e7 Shift\u00a0\u21b5 Enter Exit text area Esc Discard \u232b Backspace Save draft (Mac os) \u2318 Cmd\u00a0S Save draft (Other) Ctrl\u00a0S Submit \u21b5 Enter Move between pages \u2192 Right arrow\u00a0or\u00a0\u2190 Left arrow"},{"location":"how_to_guides/annotate/#view-by-status","title":"View by status","text":"<p>The view selector is set by default on Pending.</p> <p>If you are starting an annotation effort, all the records are initially kept in the Pending view. Once you start annotating, the records will move to the other queues: Draft, Submitted, Discarded.</p> <ul> <li>Pending: The records without a response.</li> <li>Draft: The records with partial responses. They can be submitted or discarded later. You can\u2019t move them back to the pending queue.</li> <li>Discarded: The records may or may not have responses. They can be edited but you can\u2019t move them back to the pending queue.</li> <li>Submitted: The records have been fully annotated and have already been submitted.</li> </ul>"},{"location":"how_to_guides/annotate/#suggestions","title":"Suggestions","text":"<p>If your dataset includes model predictions, you will see them represented by a sparkle icon <code>\u2728</code> in the label or value button. We call them \u201cSuggestions\u201d and they appear in the form as pre-filled responses. If confidence scores have been included by the dataset admin, they will be shown alongside with the label. Additionally, admins can choose to always show suggested labels at the beginning of the list. This can be configured from the dataset settings.</p> <p>If you agree with the suggestions, you just need to click on the <code>Submit</code> button, and they will be considered as your response. If the suggestion is incorrect, you can modify it and submit your final response.</p>"},{"location":"how_to_guides/annotate/#focus-view","title":"Focus view","text":"<p>This is the default view to annotate your dataset linearly, displaying one record after another.</p> <p>Tip</p> <p>You should use this view if you have a large number of required questions or need a strong focus on the record content to be labelled. This is also the recommended view for annotating a dataset sample to avoid potential biases introduced by using filters, search, sorting and bulk labelling.</p> <p>Once you submit your first response, the next record will appear automatically. To see again your submitted response, just click on <code>Prev</code>.</p> <p>Navigating through the records</p> <p>To navigate through the records, you can use the\u00a0<code>Prev</code>, shown as\u00a0<code>&lt;</code>, and\u00a0<code>Next</code>,\u00a0<code>&gt;</code> buttons on top of the record card.</p> <p>Each time the page is fully refreshed, the records with modified statuses (Pending to Discarded, Pending to Save as Draft, Pending to Submitted) are sent to the corresponding queue. The control panel displays the status selector, which is set to Pending by default.</p>"},{"location":"how_to_guides/annotate/#bulk-view","title":"Bulk view","text":"<p>The bulk view is designed to speed up the annotation and get a quick overview of the whole dataset.</p> <p>The bulk view displays the records in a vertical list. Once this view is active, some functions from the control panel will activate to optimize the view. You can define the number of records to display by page between <code>10</code>, <code>25</code>, <code>50</code>, <code>100</code> and whether records are shown with a fixed (<code>Collapse records</code>) or their natural height (<code>Expand records</code>).</p> <p>Tip</p> <p>You should use this to quickly explore a dataset. This view is also recommended if you have a good understanding of the domain and want to apply your knowledge based on things like similarity and keyword search, filters, and suggestion score thresholds. For a datasets with a large number of required questions or very long fields, the focus view would be more suitable.</p> <p>With multiple questions, think about using the bulk view to annotate massively one question. Then, you can complete the annotation per record from the draft queue.</p> <p>Note</p> <p>Please note that suggestions are not shown in bulk view (except for Spans) and that you will need to save as a draft when you are not providing responses to all required questions.</p>"},{"location":"how_to_guides/annotate/#annotation-progress","title":"Annotation progress","text":"<p>The global progress of the annotation task from all users is displayed in the dataset list. This is indicated in the\u00a0<code>Global progress</code>\u00a0column, which shows the number of records still to be annotated, along with a progress bar. The progress bar displays the percentage and number of records submitted, conflicting (i.e., those with both submitted and discarded responses), discarded and pending by hovering your mouse over it.</p> <p>You can track your annotation progress in real time from the righ-bottom panel inside the dataset page. This means that, while you are annotating, the progress bar updates as you submit or discard a record. Expanding the panel, the distribution of\u00a0<code>Pending</code>,\u00a0<code>Draft</code>, <code>Submitted</code>\u00a0and\u00a0<code>Discarded</code>\u00a0responses is displayed in a donut chart.</p>"},{"location":"how_to_guides/annotate/#use-search-filters-and-sort","title":"Use search, filters, and sort","text":"<p>The UI offers various features designed for data exploration and understanding. Combining these features with bulk labelling can save you and your team hours of time.</p> <p>Tip</p> <p>You should use this when you are familiar with your data and have large volumes to annotate based on verified beliefs and experience.</p>"},{"location":"how_to_guides/annotate/#search","title":"Search","text":"<p>From the control panel at the top of the left pane, you can search by keyword across the entire dataset. If you have more than one field in your records, you may specify if the search is to be performed \u201cAll\u201d fields or on a specific one. Matched results are highlighted in color.</p>"},{"location":"how_to_guides/annotate/#order-by-record-semantic-similarity","title":"Order by record semantic similarity","text":"<p>You can retrieve records based on their similarity to another record if vectors have been added to the dataset.</p> <p>Note</p> <p>Check these guides to know how to add vectors to your\u00a0dataset and\u00a0records.</p> <p>To use the search by semantic similarity function, click on <code>Find similar</code> within the record you wish to use as a reference. If multiple vectors are available, select the desired vector. You can also choose whether to retrieve the most or least similar records.</p> <p>The retrieved records are then ordered by similarity, with the similarity score displayed on each record card.</p> <p>While the semantic search is active, you can update the selected vector or adjust the order of similarity, and specify the number of desired results.</p> <p>To cancel the search, click on the cross icon next to the reference record.</p>"},{"location":"how_to_guides/annotate/#filter-and-sort-by-metadata-responses-and-suggestions","title":"Filter and sort by metadata, responses, and suggestions","text":""},{"location":"how_to_guides/annotate/#filter","title":"Filter","text":"<p>If the dataset contains metadata, responses and suggestions, click on\u00a0Filter in the control panel to display the available filters. You can select multiple filters and combine them.</p> <p>Note</p> <p>Record info including metadata is visible from the ellipsis menu in the record card.</p> <p>From the <code>Metadata</code> dropdown, type and select the property. You can set a range for integer and float properties, and select specific values for term metadata.</p> <p>Note</p> <p>Note that if a metadata property was set to <code>visible_for_annotators=False</code> this metadata property will only appear in the metadata filter for users with the <code>admin</code> or <code>owner</code> role.</p> <p>From the <code>Responses</code> dropdown, type and select the question. You can set a range for rating questions and select specific values for label, multi-label, and span questions.</p> <p>Note</p> <p>The text and ranking questions are not available for filtering.</p> <p>From the Suggestions dropdown, filter the suggestions by\u00a0<code>Suggestion values</code>,\u00a0<code>Score</code>\u00a0, or\u00a0<code>Agent</code>.\u00a0</p>"},{"location":"how_to_guides/annotate/#sort","title":"Sort","text":"<p>You can sort your records according to one or several attributes.</p> <p>The insertion time and last update are general to all records.</p> <p>The suggestion scores, response, and suggestion values for rating questions and metadata properties are available only when they were provided.</p>"},{"location":"how_to_guides/annotate/#annotate-in-teams","title":"Annotate in teams","text":"<p>Note</p> <p>Argilla 2.1 will come with automatic task distribution, which will allow you to distribute the work across several users more efficiently.</p>"},{"location":"how_to_guides/annotate/#edit-guidelines-in-the-settings","title":"Edit guidelines in the settings","text":"<p>As an\u00a0<code>owner</code> or\u00a0<code>admin</code>, you can edit the guidelines as much as you need from the icon\u00a0settings on the header. Markdown format is enabled.</p> <p>Tip</p> <p>If you want further guidance on good practices for guidelines during the project development, check this blog post.</p>"},{"location":"how_to_guides/dataset/","title":"Dataset management","text":"<p>This guide provides an overview of datasets, explaining the basics of how to set them up and manage them in Argilla.</p> <p>A dataset is a collection of records that you can configure for labelers to provide feedback using the UI. Depending on the specific requirements of your task, you may need various types of feedback. You can customize the dataset to include different kinds of questions, so the first step will be to define the aim of your project and the kind of data and feedback you will need. With this information, you can start configuring a dataset by defining fields, questions, metadata, vectors, and guidelines through settings.</p> Question: Who can manage datasets? <p>Only users with the <code>owner</code> role can manage (create, retrieve, update and delete) all the datasets.</p> <p>The users with the <code>admin</code> role can manage (create, retrieve, update and delete) the datasets in the workspaces they have access to.</p> <p>Main Classes</p> <code>rg.Dataset</code><code>rg.Settings</code> <pre><code>rg.Dataset(\n    name=\"name\",\n    workspace=\"workspace\",\n    settings=settings,\n    client=client\n)\n</code></pre> <p>Check the Dataset - Python Reference to see the attributes, arguments, and methods of the <code>Dataset</code> class in detail.</p> <pre><code>rg.Settings(\n    fields=[rg.TextField(name=\"text\")],\n    questions=[\n        rg.LabelQuestion(\n            name=\"label\",\n            labels=[\"label_1\", \"label_2\", \"label_3\"]\n        )\n    ],\n    metadata=[rg.TermsMetadataProperty(name=\"metadata\")],\n    vectors=[rg.VectorField(name=\"vector\", dimensions=10)],\n    guidelines=\"guidelines\",\n    allow_extra_metadata=True,\n)\n</code></pre> <p>Check the Settings - Python Reference to see the attributes, arguments, and methods of the <code>Settings</code> class in detail.</p>"},{"location":"how_to_guides/dataset/#create-a-dataset","title":"Create a dataset","text":"<p>To create a dataset, you can define it in the <code>Dataset</code> class and then call the <code>create</code> method that will send the dataset to the server so that it can be visualized in the UI. If the dataset does not appear in the UI, you may need to click the refresh button to update the view. For further configuration of the dataset, you can refer to the settings section.</p> <p>The created dataset will be empty, to add the records refer to this how-to guide.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nsettings = rg.Settings(\n    guidelines=\"These are some guidelines.\",\n    fields=[\n        rg.TextField(\n            name=\"text\",\n        ),\n    ],\n    questions=[\n        rg.LabelQuestion(\n            name=\"label\",\n            labels=[\"label_1\", \"label_2\", \"label_3\"]\n        ),\n    ],\n)\n\ndataset = rg.Dataset(\n    name=\"my_dataset\",\n    workspace=\"my_workspace\",\n    settings=settings,\n    client=client,\n)\n\ndataset.create()\n</code></pre> <p>Accessing attributes</p> <p>Access the attributes of a dataset by calling them directly on the <code>dataset</code> object. For example, <code>dataset.id</code>, <code>dataset.name</code> or <code>dataset.settings</code>. You can similarly access the fields, questions, metadata, vectors and guidelines. For instance, <code>dataset.fields</code> or <code>dataset.questions</code>.</p>"},{"location":"how_to_guides/dataset/#create-multiple-datasets-with-the-same-settings","title":"Create multiple datasets with the same settings","text":"<p>To create multiple datasets with the same settings, define the settings once and pass it to each dataset.</p> <pre><code>import argilla as rg\n\nsettings = rg.Settings(\n    guidelines=\"Select the sentiment of the prompt.\",\n    fields=[rg.TextField(name=\"prompt\", use_markdown=True)],\n    questions=[rg.LabelQuestion(name=\"sentiment\", labels=[\"positive\", \"negative\"])],\n)\n\ndataset1 = rg.Dataset(name=\"sentiment_analysis_1\", settings=settings)\ndataset2 = rg.Dataset(name=\"sentiment_analysis_2\", settings=settings)\n\n# Create the datasets on the server\ndataset1.create()\ndataset2.create()\n</code></pre>"},{"location":"how_to_guides/dataset/#create-a-dataset-with-settings-from-an-existing-dataset","title":"Create a dataset with settings from an existing dataset","text":"<p>To create a new dataset with settings from an existing dataset, get the settings from the existing dataset and pass it to the new dataset.</p> <pre><code>import argilla as rg\n\n# Get the settings from an existing dataset\nexisting_dataset = client.datasets(\"sentiment_analysis\")\n\n# Create a new dataset with the same settings\ndataset = rg.Dataset(name=\"sentiment_analysis_copy\", settings=existing_dataset.settings)\n\n# Create the dataset on the server\ndataset.create()\n</code></pre>"},{"location":"how_to_guides/dataset/#define-dataset-settings","title":"Define dataset settings","text":""},{"location":"how_to_guides/dataset/#fields","title":"Fields","text":"<p>The fields in a dataset consist of one or more data items requiring annotation. Currently, Argilla only supports plain text and markdown through the <code>TextField</code>, though we plan to introduce additional field types in future updates.</p> <p>A field is defined in the <code>TextField</code> class that has the following arguments:</p> <ul> <li><code>name</code>: The name of the field.</li> <li><code>title</code> (optional): The name of the field, as it will be displayed in the UI. Defaults to the <code>name</code> value.</li> <li><code>required</code> (optional): Whether the field is required or not. Defaults to <code>True</code>. At least one field must be required.</li> <li><code>use_markdown</code> (optional): Specify whether you want markdown rendered in the UI. Defaults to <code>False</code>. If you set it to True, you will be able to use all the Markdown features for text formatting, including LaTex formulas and embedding multimedia content and PDFs.</li> </ul> <p>Note</p> <p>The order of the fields in the UI follows the order in which these are added to the fields attribute in the Python SDK.</p> <p><pre><code>rg.TextField(\n    name=\"text\",\n    title=\"Text\",\n    required=True,\n    use_markdown=False\n)\n</code></pre> </p>"},{"location":"how_to_guides/dataset/#questions","title":"Questions","text":"<p>To collect feedback for your dataset, you need to formulate questions that annotators will be asked to answer. Currently, Argilla supports the following types of questions: <code>LabelQuestion</code>, <code>MultiLabelQuestion</code>, <code>RankingQuestion</code>, <code>RatingQuestion</code>, <code>SpanQuestion</code>, and <code>TextQuestion</code>.</p> LabelMulti-labelRankingRatingSpanText <p>A <code>LabelQuestion</code> asks annotators to choose a unique label from a list of options. This type is useful for text classification tasks. In the UI, they will have a rounded shape. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>labels</code>: A list of strings with the options for these questions. If you'd like the text of the labels to be different in the UI and internally, you can pass a dictionary instead where the key is the internal name and the value will be the text displayed in the UI.</li> </ul> <p><pre><code>rg.LabelQuestion(\n    name=\"label\",\n    title=\"Is the response relevant for the given prompt?\",\n    description=\"Select the one that applies.\",\n    required=True,\n    labels={\"YES\": \"Yes\", \"NO\": \"No\"}, # or [\"YES\", \"NO\"]\n)\n</code></pre> </p> <p>A <code>MultiLabelQuestion</code> asks annotators to choose all applicable labels from a list of options. This type is useful for multi-label text classification tasks. In the UI, they will have a squared shape. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>labels</code>: A list of strings with the options for these questions. If you'd like the text of the labels to be different in the UI and internally, you can pass a dictionary instead where the key is the internal name and the value will be the text displayed in the UI.</li> <li><code>visible_labels</code> (optional): The number of labels that will be visible at first sight in the UI. By default, the UI will show 20 labels and collapse the rest. Set your preferred number to change this limit or set <code>visible_labels=None</code> to show all options.</li> </ul> <p><pre><code>rg.MultiLabelQuestion(\n    name=\"multi_label\",\n    title=\"Does the response include any of the following?\",\n    description=\"Select all that apply.\",\n    required=True,\n    labels={\n        \"hate\": \"Hate Speech\",\n        \"sexual\": \"Sexual content\",\n        \"violent\": \"Violent content\",\n        \"pii\": \"Personal information\",\n        \"untruthful\": \"Untruthful info\",\n        \"not_english\": \"Not English\",\n        \"inappropriate\": \"Inappropriate content\"\n    }, # or [\"hate\", \"sexual\", \"violent\", \"pii\", \"untruthful\", \"not_english\", \"inappropriate\"]\n    visible_labels=4\n)\n</code></pre> </p> <p>A <code>RankingQuestion</code> asks annotators to order a list of options. It is useful to gather information on the preference or relevance of a set of options. Ties are allowed and all options will need to be ranked. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>values</code>: A list of strings with the options they will need to rank. If you'd like the text of the options to be different in the UI and internally, you can pass a dictionary instead where the key is the internal name and the value is the text to display in the UI.</li> </ul> <pre><code>rg.RankingQuestion(\n    name=\"ranking\",\n    title=\"Order replies based on your preference\",\n    description=\"1 = best, 3 = worst. Ties are allowed.\",\n    required=True,\n    values={\n        \"reply-1\": \"Reply 1\",\n        \"reply-2\": \"Reply 2\",\n        \"reply-3\": \"Reply 3\"\n    } # or [\"reply-1\", \"reply-2\", \"reply-3\"]\n)\n</code></pre> <p></p> <p>A <code>RatingQuestion</code> asks annotators to select one option from a list of integer values. This type is useful for collecting numerical scores. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>values</code>: A list of unique integers representing the scores that annotators can select from should be defined within the range [1, 10].</li> </ul> <pre><code>rg.RatingQuestion(\n    name=\"rating\",\n    title=\"How satisfied are you with the response?\",\n    description=\"1 = very unsatisfied, 10 = very satisfied\",\n    required=True,\n    values=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n)\n</code></pre> <p></p> <p>A <code>SpanQuestion</code> asks annotators to select a portion of the text of a specific field and apply a label to it. This type of question is useful for named entity recognition or information extraction tasks. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value, but capitalized.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>labels</code>: A list of strings with the options for these questions. If you'd like the text of the labels to be different in the UI and internally, you can pass a dictionary instead where the key is the internal name and the value will be the text to display in the UI.</li> <li><code>field</code>: This question is always attached to a specific field. You should pass a string with the name of the field where the labels of the <code>SpanQuestion</code> should be used.</li> <li><code>allow_overlapping</code>: This value specifies whether overlapped spans are allowed or not. Defaults to <code>False</code>.</li> <li><code>visible_labels</code> (optional): The number of labels that will be visible at first sight in the UI. By default, the UI will show 20 labels and collapse the rest. Set your preferred number to change this limit or set <code>visible_labels=None</code> to show all options.</li> </ul> <pre><code>rg.SpanQuestion(\n    name=\"span\",\n    title=\"Select the entities in the text\",\n    description=\"Select the entities in the text\",\n    required=True,\n    labels={\n        \"PERSON\": \"Person\",\n        \"ORG\": \"Organization\",\n        \"LOC\": \"Location\",\n        \"MISC\": \"Miscellaneous\"\n    },\n    field=\"text\",\n    allow_overlapping=False,\n    visible_labels=None\n)\n</code></pre> <p></p> <p>A <code>TextQuestion</code> offers to annotators a free-text area where they can enter any text. This type is useful for collecting natural language data, such as corrections or explanations. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the question.</li> <li><code>title</code> (optional): The name of the question, as it will be displayed in the UI. Defaults to the <code>name</code> value, but capitalized.</li> <li><code>description</code> (optional): The text to be displayed in the question tooltip in the UI. You can use it to give more context or information to annotators.</li> <li><code>required</code> (optional): Whether the question is required or not. Defaults to <code>True</code>. At least one question must be required.</li> <li><code>use_markdown</code> (optional): Define whether the field should render markdown text. Defaults to <code>False</code>. If you set it to <code>True</code>, you will be able to use all the Markdown features for text formatting, as well as embed multimedia content and PDFs.</li> </ul> <pre><code>rg.TextQuestion(\n    name=\"text\",\n    title=\"Please provide feedback on the response\",\n    description=\"Please provide feedback on the response\",\n    required=True,\n    use_markdown=True\n)\n</code></pre> <p></p>"},{"location":"how_to_guides/dataset/#metadata","title":"Metadata","text":"<p>Metadata properties allow you to configure the use of metadata information for the filtering and sorting features available in the UI and Python SDK. There exist three types of metadata you can add: <code>TermsMetadataProperty</code>, <code>IntegerMetadataProperty</code> and <code>FloatMetadataProperty</code>.</p> TermsIntegerFloat <p>A <code>TermsMetadataProperty</code> allows to add a list of strings as metadata options. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the metadata property.</li> <li><code>title</code> (optional): The name of the metadata property, as it will be displayed in the UI. Defaults to the <code>name</code> value, but capitalized.</li> <li><code>options</code> (optional): You can pass a list of valid values for this metadata property, in case you want to run any validation.</li> </ul> <p><pre><code>rg.TermsMetadataProperty(\n    name=\"terms\",\n    title=\"Annotation groups\",\n    options=[\"group-a\", \"group-b\", \"group-c\"]\n)\n</code></pre> </p> <p>An <code>IntegerMetadataProperty</code> allows to add integer values as metadata. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the metadata property.</li> <li><code>title</code> (optional): The name of the metadata property, as it will be displayed in the UI. Defaults to the <code>name</code> value, but capitalized.</li> <li><code>min</code> (optional): You can pass a minimum valid value. If none is provided, the minimum value will be computed from the values provided in the records.</li> <li><code>max</code> (optional): You can pass a maximum valid value. If none is provided, the maximum value will be computed from the values provided in the records.</li> </ul> <p><pre><code>rg.IntegerMetadataProperty(\n    name=\"integer\",\n    title=\"length-input\",\n    min=42,\n    max=1984,\n)\n</code></pre> </p> <p>A <code>FloatMetadataProperty</code> allows to add float values as metadata. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the metadata property.</li> <li><code>title</code> (optional): The name of the metadata property, as it will be displayed in the UI. Defaults to the <code>name</code> value, but capitalized.</li> <li><code>min</code> (optional): You can pass a minimum valid value. If none is provided, the minimum value will be computed from the values provided in the records.</li> <li><code>max</code> (optional): You can pass a maximum valid value. If none is provided, the maximum value will be computed from the values provided in the records.</li> </ul> <p><pre><code>rg.FloatMetadataProperty(\n    name=\"float\",\n    title=\"Reading ease\",\n    min=-92.29914,\n    max=119.6975,\n)\n</code></pre> </p>"},{"location":"how_to_guides/dataset/#vectors","title":"Vectors","text":"<p>To use the similarity search in the UI and the Python SDK, you will need to configure vectors using the <code>VectorField</code> class. It has the following configuration:</p> <ul> <li><code>name</code>: The name of the vector.</li> <li><code>title</code> (optional): A name for the vector to display in the UI for better readability.</li> <li><code>dimensions</code>: The dimensions of the vectors used in this setting.</li> </ul> <p><pre><code>rg.VectorField(\n    name=\"my_vector\",\n    title=\"My Vector\",\n    dimensions=768\n),\n</code></pre> </p>"},{"location":"how_to_guides/dataset/#guidelines","title":"Guidelines","text":"<p>Once you have decided on the data to show and the questions to ask, it's important to provide clear guidelines to the annotators. These guidelines help them understand the task and answer the questions consistently. You can provide guidelines in two ways:</p> <ul> <li> <p>In the dataset guidelines: this is added as an argument when you create your dataset in the Python SDK. It will appear in the dataset settings in the UI. <pre><code>guidelines = \"In this dataset, you will find a collection of records that show a category, an instruction, a context and a response to that instruction. [...]\"\n</code></pre> </p> </li> <li> <p>As question descriptions: these are added as an argument when you create questions in the Python SDK. This text will appear in a tooltip next to the question in the UI. </p> </li> </ul> <p>It is good practice to use at least the dataset guidelines if not both methods. Question descriptions should be short and provide context to a specific question. They can be a summary of the guidelines to that question, but often that is not sufficient to align the whole annotation team. In the guidelines, you can include a description of the project, details on how to answer each question with examples, instructions on when to discard a record, etc.</p> <p>Tip</p> <p>If you want further guidance on good practices for guidelines during the project development, check our blog post.</p>"},{"location":"how_to_guides/dataset/#list-datasets","title":"List datasets","text":"<p>You can list all the datasets available in a workspace using the <code>datasets</code> attribute of the <code>Workspace</code> class. You can also use <code>len(workspace.datasets)</code> to get the number of datasets in a workspace.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndatasets = workspace.datasets\n\nfor dataset in datasets:\n    print(dataset)\n</code></pre>"},{"location":"how_to_guides/dataset/#retrieve-a-dataset","title":"Retrieve a dataset","text":"<p>You can retrieve a dataset by calling the <code>datasets</code> method on the <code>Argilla</code> class and passing the name of the dataset as an argument. By default, this method attempts to retrieve the dataset from the first workspace. If the dataset is in a different workspace, you must specify either the workspace name or id as an argument.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\n# Retrieve the dataset from the first workspace\nretrieved_dataset = client.datasets(name=\"my_dataset\")\n\n# Retrieve the dataset from the specified workspace\nretrieved_dataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n</code></pre>"},{"location":"how_to_guides/dataset/#check-dataset-existence","title":"Check dataset existence","text":"<p>You can check if a retrieved dataset exists by calling the <code>exists</code> method on the <code>Dataset</code> class. This method returns a boolean value.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\ndataset = client.datasets(name=\"my_dataset\")\n\ndataset_existed = dataset.exists()\n</code></pre>"},{"location":"how_to_guides/dataset/#update-a-dataset","title":"Update a dataset","text":"<p>You can update a dataset by calling the <code>update</code> method on the <code>Dataset</code> class and passing the new settings as an argument.</p> <p>Note</p> <p>Keep in mind that once your dataset is published, only the guidelines can be updated.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\ndataset_to_update = client.datasets(name=\"my_dataset\")\n\nsettings_to_update = rg.Settings(\n    guidelines=\"These are some updated guidelines.\",\n    fields=[\n        rg.TextField(\n            name=\"text\",\n        ),\n    ],\n    questions=[\n        rg.LabelQuestion(\n            name=\"label\",\n            labels=[\"label_4\", \"label_5\", \"label_6\"]\n        ),\n    ],\n)\n\ndataset_to_update.settings = settings_to_update\n\ndataset_updated = dataset_to_update.update()\n</code></pre>"},{"location":"how_to_guides/dataset/#delete-a-dataset","title":"Delete a dataset","text":"<p>You can delete an existing dataset by calling the <code>delete</code> method on the <code>Dataset</code> class.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\ndataset_to_delete = client.datasets(name=\"my_dataset\")\n\ndataset_deleted = dataset_to_delete.delete()\n</code></pre>"},{"location":"how_to_guides/migrate_from_legacy_datasets/","title":"Migrate your legacy datasets to Argilla V2","text":"<p>This guide will help you migrate task specific datasets to Argilla V2. These do not include the <code>FeedbackDataset</code> which is just an interim naming convention for the latest extensible dataset. Task specific datasets are datasets that are used for a specific task, such as text classification, token classification, etc. If you would like to learn about the backstory of SDK this migration, please refer to the SDK migration blog post.</p> <p>Note</p> <p>Legacy Datasets include: <code>DatasetForTextClassification</code>, <code>DatasetForTokenClassification</code>, and <code>DatasetForText2Text</code>.</p> <p><code>FeedbackDataset</code>'s do not need to be migrated as they are already in the Argilla V2 format.</p> <p>To follow this guide, you will need to have the following prerequisites:</p> <ul> <li>An argilla 1.* server instance running with legacy datasets.</li> <li>An argilla &gt;=1.29 server instance running. If you don't have one, you can create one by following the Argilla installation guide.</li> <li>The <code>argilla</code> sdk package installed in your environment.</li> </ul> <p>If your current legacy datasets are on a server with Argilla release after 1.29, you could chose to recreate your legacy datasets as new datasets on the same server. You could then upgrade the server to Argilla 2.0 and carry on working their. Your legacy datasets will not be visible on the new server, but they will remain in storage layers if you need to access them.</p>"},{"location":"how_to_guides/migrate_from_legacy_datasets/#steps","title":"Steps","text":"<p>The guide will take you through three steps:</p> <ol> <li>Retrieve the legacy dataset from the Argilla V1 server using the new <code>argilla</code> package.</li> <li>Define the new dataset in the Argilla V2 format.</li> <li>Upload the dataset records to the new Argilla V2 dataset format and attributes.</li> </ol>"},{"location":"how_to_guides/migrate_from_legacy_datasets/#step-1-retrieve-the-legacy-dataset","title":"Step 1: Retrieve the legacy dataset","text":"<p>Connect to the Argilla V1 server via the new <code>argilla</code> package. First, you should install an extra dependency: <pre><code>pip install \"argilla[legacy]\"\n</code></pre></p> <p>Now, you can use the <code>v1</code> module to connect to the Argilla V1 server. <pre><code>import argilla.v1 as rg_v1\n\n# Initialize the API with an Argilla server less than 2.0\napi_url = \"&lt;your-url&gt;\"\napi_key = \"&lt;your-api-key&gt;\"\nrg_v1.init(api_url, api_key)\n</code></pre></p> <p>Next, load the dataset settings and records from the Argilla V1 server:</p> <pre><code>dataset_name = \"news-programmatic-labeling\"\nworkspace = \"demo\"\n\nsettings_v1 = rg_v1.load_dataset_settings(dataset_name, workspace)\nrecords_v1 = rg_v1.load(dataset_name, workspace)\nhf_dataset = records_v1.to_datasets()\n</code></pre> <p>Your legacy dataset is now loaded into the <code>hf_dataset</code> object.</p>"},{"location":"how_to_guides/migrate_from_legacy_datasets/#step-2-define-the-new-dataset","title":"Step 2: Define the new dataset","text":"<p>Define the new dataset in the Argilla V2 format. The new dataset format is defined in the <code>argilla</code> package. You can create a new dataset with the <code>Settings</code> and <code>Dataset</code> classes:</p> <p>First, instantiate the <code>Argilla</code> class to connect to the Argilla V2 server:</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla()\n</code></pre> <p>Next, define the new dataset settings:</p> <pre><code>settings = rg.Settings(\n    fields=[\n        rg.TextField(name=\"text\"), # (1)\n    ],\n    questions=[\n        rg.LabelQuestion(name=\"label\", labels=settings_v1.label_schema), # (2)\n    ],\n    metadata=[\n        rg.TermsMetadataProperty(name=\"split\"), # (3)\n    ],\n    vectors=[\n        rg.VectorField(name='mini-lm-sentence-transformers', dimensions=384), # (4)\n    ],\n)\n</code></pre> <ol> <li> <p>The default name for text classification is <code>text</code>, but we should provide all names included in <code>record.inputs</code>.</p> </li> <li> <p>The basis question for text classification is a <code>LabelQuestion</code> for single-label or <code>MultiLabelQuestion</code> for multi-label classification.</p> </li> <li> <p>Here, we need to provide all relevant metadata fields.</p> </li> <li> <p>The vectors fields available in the dataset.</p> </li> </ol> <p>Finally, create the new dataset on the Argilla V2 server:</p> <pre><code>dataset = rg.Dataset(name=dataset_name, settings=settings)\ndataset.create()\n</code></pre> <p>Note</p> <p>If a dataset with the same name already exists, the <code>create</code> method will raise an exception. You can check if the dataset exists and delete it before creating a new one.</p> <pre><code>dataset = client.datasets(name=dataset_name)\n\nif dataset.exists():\n    dataset.delete()\n</code></pre>"},{"location":"how_to_guides/migrate_from_legacy_datasets/#step-3-upload-the-dataset-records","title":"Step 3: Upload the dataset records","text":"<p>To upload the records to the new server, we will need to convert the records from the Argilla V1 format to the Argilla V2 format. The new <code>argilla</code> sdk package uses a generic <code>Record</code> class, but legacy datasets have specific record classes. We will need to convert the records to the generic <code>Record</code> class.</p> <p>Here are a set of example functions to convert the records for single-label and multi-label classification. You can modify these functions to suit your dataset.</p> For single-label classificationFor multi-label classificationFor token classificationFor Text generation <pre><code>def map_to_record_for_single_label(data: dict, users_by_name: dict, current_user: rg.User) -&gt; rg.Record:\n    \"\"\" This function maps a text classification record dictionary to the new Argilla record.\"\"\"\n    suggestions = []\n    responses = []\n\n    if prediction := data.get(\"prediction\"):\n        label, score = prediction[0].values()\n        agent = data[\"prediction_agent\"]\n        suggestions.append(rg.Suggestion(question_name=\"label\", value=label, score=score, agent=agent))\n\n    if annotation := data.get(\"annotation\"):\n        user_id = users_by_name.get(data[\"annotation_agent\"], current_user).id\n        responses.append(rg.Response(question_name=\"label\", value=annotation, user_id=user_id))\n\n    vectors = (data.get(\"vectors\") or {})\n    return rg.Record(\n        id=data[\"id\"],\n        fields=data[\"inputs\"],\n        # The inputs field should be a dictionary with the same keys as the `fields` in the settings\n        metadata=data[\"metadata\"],\n        # The metadata field should be a dictionary with the same keys as the `metadata` in the settings\n        vectors=[rg.Vector(name=name, values=value) for name, value in vectors.items()],\n        suggestions=suggestions,\n        responses=responses,\n    )\n</code></pre> <pre><code>def map_to_record_for_multi_label(data: dict, users_by_name: dict, current_user: rg.User) -&gt; rg.Record:\n    \"\"\" This function maps a text classification record dictionary to the new Argilla record.\"\"\"\n    suggestions = []\n    responses = []\n\n    if prediction := data.get(\"prediction\"):\n        labels, scores = zip(*[(pred[\"label\"], pred[\"score\"]) for pred in prediction])\n        agent = data[\"prediction_agent\"]\n        suggestions.append(rg.Suggestion(question_name=\"labels\", value=labels, score=scores, agent=agent))\n\n    if annotation := data.get(\"annotation\"):\n        user_id = users_by_name.get(data[\"annotation_agent\"], current_user).id\n        responses.append(rg.Response(question_name=\"label\", value=annotation, user_id=user_id))\n\n    vectors = data.get(\"vectors\") or {}\n    return rg.Record(\n        id=data[\"id\"],\n        fields=data[\"inputs\"],\n        # The inputs field should be a dictionary with the same keys as the `fields` in the settings\n        metadata=data[\"metadata\"],\n        # The metadata field should be a dictionary with the same keys as the `metadata` in the settings\n        vectors=[rg.Vector(name=name, values=value) for name, value in vectors.items()],\n        suggestions=suggestions,\n        responses=responses,\n    )\n</code></pre> <pre><code>def map_to_record_for_span(data: dict, users_by_name: dict, current_user: rg.User) -&gt; rg.Record:\n    \"\"\" This function maps a token classification record dictionary to the new Argilla record.\"\"\"\n    suggestions = []\n    responses = []\n\n    if prediction := data.get(\"prediction\"):\n        scores = [span[\"score\"] for span in prediction]\n        agent = data[\"prediction_agent\"]\n        suggestions.append(rg.Suggestion(question_name=\"spans\", value=prediction, score=scores, agent=agent))\n\n    if annotation := data.get(\"annotation\"):\n        user_id = users_by_name.get(data[\"annotation_agent\"], current_user).id\n        responses.append(rg.Response(question_name=\"spans\", value=annotation, user_id=user_id))\n\n    vectors = data.get(\"vectors\") or {}\n    return rg.Record(\n        id=data[\"id\"],\n        fields={\"text\": data[\"text\"]},\n        # The inputs field should be a dictionary with the same keys as the `fields` in the settings\n        metadata=data[\"metadata\"],\n        # The metadata field should be a dictionary with the same keys as the `metadata` in the settings\n        vectors=[rg.Vector(name=name, values=value) for name, value in vectors.items()],\n        # The vectors field should be a dictionary with the same keys as the `vectors` in the settings\n        suggestions=suggestions,\n        responses=responses,\n    )\n</code></pre> <pre><code>def map_to_record_for_text_generation(data: dict, users_by_name: dict, current_user: rg.User) -&gt; rg.Record:\n    \"\"\" This function maps a text2text record dictionary to the new Argilla record.\"\"\"\n    suggestions = []\n    responses = []\n\n    if prediction := data.get(\"prediction\"):\n        first = prediction[0]\n        agent = data[\"prediction_agent\"]\n        suggestions.append(\n            rg.Suggestion(question_name=\"text_generation\", value=first[\"text\"], score=first[\"score\"], agent=agent)\n        )\n\n    if annotation := data.get(\"annotation\"):\n        # From data[annotation]\n        user_id = users_by_name.get(data[\"annotation_agent\"], current_user).id\n        responses.append(rg.Response(question_name=\"text_generation\", value=annotation, user_id=user_id))\n\n    vectors = (data.get(\"vectors\") or {})\n    return rg.Record(\n        id=data[\"id\"],\n        fields={\"text\": data[\"text\"]},\n        # The inputs field should be a dictionary with the same keys as the `fields` in the settings\n        metadata=data[\"metadata\"],\n        # The metadata field should be a dictionary with the same keys as the `metadata` in the settings\n        vectors=[rg.Vector(name=name, values=value) for name, value in vectors.items()],\n        # The vectors field should be a dictionary with the same keys as the `vectors` in the settings\n        suggestions=suggestions,\n        responses=responses,\n    )\n</code></pre> <p>The functions above depend on the <code>users_by_name</code> dictionary and the <code>current_user</code> object to assign responses to users, we need to load the existing users. You can retrieve the users from the Argilla V2 server and the current user as follows:</p> <pre><code># For\nusers_by_name = {user.username: user for user in client.users}\ncurrent_user = client.me\n</code></pre> <p>Finally, upload the records to the new dataset using the <code>log</code> method and map functions.</p> <p><pre><code>records = []\n\nfor data in hf_records:\n    records.append(map_to_record_for_single_label(data, users_by_name, current_user))\n\n# Upload the records to the new dataset\ndataset.records.log(records)\n</code></pre> You have now successfully migrated your legacy dataset to Argilla V2. For more guides on how to use the Argilla SDK, please refer to the How to guides.</p>"},{"location":"how_to_guides/query_export/","title":"Query, filter, and export records","text":"<p>This guide provides an overview of how to query and filter a dataset in Argilla and export records.</p> <p>You can search for records in your dataset by querying or filtering. The query focuses on the content of the text field, while the filter is used to filter the records based on conditions. You can use them independently or combine multiple filters to create complex search queries. You can also export records from a dataset either as a single dictionary or a list of dictionaries.</p> <p>Main Classes</p> <code>rg.query</code><code>rg.Filter</code> <pre><code>rg.Query(\n    query=\"query\",\n    filter=filter\n)\n</code></pre> <p>Check the Query - Python Reference to see the attributes, arguments, and methods of the <code>Query</code> class in detail.</p> <pre><code>rg.Filter(\n    [\n        (\"field\", \"==\", \"value\"),\n    ]\n)\n</code></pre> <p>Check the Filter - Python Reference to see the attributes, arguments, and methods of the <code>Filter</code> class in detail.</p>"},{"location":"how_to_guides/query_export/#query-with-search-terms","title":"Query with search terms","text":"<p>To search for records with terms, you can use the <code>Dataset.records</code> attribute with a query string. The search terms are used to search for records that contain the terms in the text field. You can search a single term or various terms, in the latter, all of them should appear in the record to be retrieved.</p> Single search termMultiple search term <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nquery = rg.Query(query=\"my_term\")\n\nqueried_records = list(dataset.records(query=query))\n</code></pre> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nquery = rg.Query(query=\"my_term1 my_term2\")\n\nqueried_records = list(dataset.records(query=query))\n</code></pre>"},{"location":"how_to_guides/query_export/#filter-by-conditions","title":"Filter by conditions","text":"<p>You can use the <code>Filter</code> class to define the conditions and pass them to the <code>Dataset.records</code> attribute to fetch records based on the conditions. Conditions include \"==\", \"&gt;=\", \"&lt;=\", or \"in\". Conditions can be combined with dot notation to filter records based on metadata, suggestions, or responses. You can use a single condition or multiple conditions to filter records.</p> operator description <code>==</code> The <code>field</code> value is equal to the <code>value</code> <code>&gt;=</code> The <code>field</code> value is greater than or equal to the <code>value</code> <code>&lt;=</code> The <code>field</code> value is less than or equal to the <code>value</code> <code>in</code> TThe <code>field</code> value is included in a list of values Single conditionMultiple conditions <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nfilter_label = rg.Filter((\"label\", \"==\", \"positive\"))\n\nfiltered_records = list(dataset.records(query=rg.Query(filter=filter_label)))\n</code></pre> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nfilters = rg.Filter(\n    [\n        (\"label.suggestion\", \"==\", \"positive\"),\n        (\"metadata.count\", \"&gt;=\", 10),\n        (\"metadata.count\", \"&lt;=\", 20),\n        (\"label\", \"in\", [\"positive\", \"negative\"])\n    ]\n)\n\nfiltered_records = list(dataset.records(\n    query=rg.Query(filter=filters)),\n    with_suggestions=True\n)\n</code></pre>"},{"location":"how_to_guides/query_export/#filter-by-status","title":"Filter by status","text":"<p>You can filter records based on their status. The status can be <code>pending</code>, <code>draft</code>, <code>submitted</code>, or <code>discarded</code>.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nstatus_filter = rg.Query(\n    filter=rg.Filter((\"response.status\", \"==\", \"submitted\"))\n)\n\nfiltered_records = list(dataset.records(status_filter))\n</code></pre>"},{"location":"how_to_guides/query_export/#query-and-filter-a-dataset","title":"Query and filter a dataset","text":"<p>As mentioned, you can use a query with a search term and a filter or various filters to create complex search queries.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\nquery_filter = rg.Query(\n    query=\"my_term\",\n    filter=rg.Filter(\n        [\n            (\"label.suggestion\", \"==\", \"positive\"),\n            (\"metadata.count\", \"&gt;=\", 10),\n        ]\n    )\n)\n\nqueried_filtered_records = list(dataset.records(\n    query=query_filter,\n    with_metadata=True,\n    with_suggestions=True\n)\n)\n</code></pre>"},{"location":"how_to_guides/query_export/#export-records-to-a-dictionary","title":"Export records to a dictionary","text":"<p>Records can be exported from <code>Dataset.records</code> as a dictionary. The <code>to_dict</code> method can be used to export records as a dictionary. You can specify the orientation of the dictionary output. You can also decide if to flatten or not the dictionary.</p> <p>=== \"</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\n# Export records as a dictionary\nexported_records = dataset.records.to_dict()\n# {'fields': [{'text': 'Hello'},{'text': 'World'}], suggestions': [{'label': {'value': 'positive'}}, {'label': {'value': 'negative'}}]\n\n# Export records as a dictionary with orient=index\nexported_records = dataset.records.to_dict(orient=\"index\")\n# {\"uuid\": {'fields': {'text': 'Hello'}, 'suggestions': {'label': {'value': 'positive'}}}, {\"uuid\": {'fields': {'text': 'World'}, 'suggestions': {'label': {'value': 'negative'}}},\n\n# Export records as a dictionary with flatten=false\nexported_records = dataset.records.to_dict(flatten=True)\n# {\"text\": [\"Hello\", \"World\"], \"label.suggestion\": [\"greeting\", \"greeting\"]}\n</code></pre>"},{"location":"how_to_guides/query_export/#export-records-to-a-list","title":"Export records to a list","text":"<p>Records can be exported from <code>Dataset.records</code> as a list of dictionaries. The <code>to_list</code> method can be used to export records as a list of dictionaries. You can decide if to flatten it or not.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\ndataset = client.datasets(name=\"my_dataset\", workspace=workspace)\n\n# Export records as a list of dictionaries\nexported_records = dataset.records.to_list()\n# [{'fields': {'text': 'Hello'}, 'suggestion': {'label': {value: 'greeting'}}}, {'fields': {'text': 'World'}, 'suggestion': {'label': {value: 'greeting'}}}]\n\n# Export records as a list of dictionaries with flatten=False\nexported_records = dataset.records.to_list(flatten=True)\n# [{\"text\": \"Hello\", \"label\": \"greeting\"}, {\"text\": \"World\", \"label\": \"greeting\"}]\n</code></pre>"},{"location":"how_to_guides/record/","title":"Add, update, and delete records","text":"<p>This guide provides an overview of records, explaining the basics of how to define and manage them in Argilla.</p> <p>A record in Argilla is a data item that requires annotation, consisting of one or more fields. These are the pieces of information displayed to the user in the UI to facilitate the completion of the annotation task. Each record also includes questions that annotators are required to answer, with the option of adding suggestions and responses to assist them. Guidelines are also provided to help annotators effectively complete their tasks.</p> <p>A record is part of a dataset, so you will need to create a dataset before adding records. Check these guides to learn how to create a dataset.</p> <p>Main Class</p> <pre><code>rg.Record(\n    external_id=\"1234\",\n    fields={\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\"\n    },\n    metadata={\n        \"category\": \"A\"\n    },\n    vectors={\n        \"my_vector\": [0.1, 0.2, 0.3],\n    },\n    suggestions=[\n        rg.suggestion(\"my_label\", \"positive\", score=0.9, agent=\"model_name\")\n    ],\n    responses=[\n        rg.response(\"label\", \"positive\", user_id=user_id)\n    ],\n)\n</code></pre> <p>Check the Record - Python Reference to see the attributes, arguments, and methods of the <code>Record</code> class in detail.</p>"},{"location":"how_to_guides/record/#add-records","title":"Add records","text":"<p>You can add records to a dataset in two different ways: either by using a dictionary or by directly initializing a <code>Record</code> object. You should ensure that fields, metadata and vectors match those configured in the dataset settings. In both cases, are added via the <code>Dataset.records.log</code> method. As soon as you add the records, these will be available in the Argilla UI. If they do not appear in the UI, you may need to click the refresh button to update the view.</p> <p>Tip</p> <p>Take some time to inspect the data before adding it to the dataset in case this triggers changes in the <code>questions</code> or <code>fields</code>.</p> <p>Note</p> <p>If you are planning to use public data, the Datasets page of the Hugging Face Hub is a good place to start. Remember to always check the license to make sure you can legally use it for your specific use case.</p> As <code>Record</code> objectsFrom a generic data structureFrom a Hugging Face dataset <p>You can add records to a dataset by initializing a <code>Record</code> object directly. This is ideal if you need to apply logic to the data before defining the record. If the data is already structured, you should consider adding it directly as a dictionary or Hugging Face dataset.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\ndataset = client.datasets(name=\"my_dataset\")\n\nrecords = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n    ), # (1)\n]\n\ndataset.records.log(records)\n</code></pre> <ol> <li>This is an illustration of a definition. In a real world scenario, you would iterate over a data structure and create <code>Record</code> objects for each iteration.</li> </ol> <p>You can add the data directly as a dictionary like structure, where the keys correspond to the names of fields, questions, metadata or vectors in the dataset and the values are the data to be added.</p> <p>If your data structure does not correspond to your Argilla dataset names, you can use a <code>mapping</code> to indicate which keys in the source data correspond to the dataset fields.</p> <p>We illustrate this python dictionaries that represent your data, but we would not advise you to define dictionaries. Instead use the <code>Record</code> object for instantiating records.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\ndataset = client.datasets(name=\"my_dataset\")\n\n# Add records to the dataset with the fields 'question' and 'answer'\ndata = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n    }, # (1)\n]\ndataset.records.log(data)\n\n# Add records to the dataset with the a mapping of the fields 'question' and 'answer'\ndata = [\n    {\n        \"query\": \"Do you need oxygen to breathe?\",\n        \"response\": \"Yes\",\n    },\n    {\n        \"query\": \"What is the boiling point of water?\",\n        \"response\": \"100 degrees Celsius\",\n    },\n]\ndataset.records.log(data, mapping={\"query\": \"question\", \"response\": \"answer\"}) # (2)\n</code></pre> <ol> <li>The data structure's keys must match the fields or questions in the Argilla dataset. In this case, there are fields named <code>question</code> and <code>answer</code>.</li> <li>The data structure has keys <code>query</code> and <code>response</code> and the Argilla dataset has fields <code>question</code> and <code>answer</code>. You can use the <code>mapping</code> parameter to map the keys in the data structure to the fields in the Argilla dataset.</li> </ol> <p>You can also add records to a dataset using a Hugging Face dataset. This is useful when you want to use a dataset from the Hugging Face Hub and add it to your Argilla dataset.</p> <p>You can add the dataset where the column names correspond to the names of fields, metadata or vectors in the Argilla dataset.</p> <pre><code>from uuid import uuid4\n\nimport argilla as rg\nfrom datasets import load_dataset\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\ndataset = client.datasets(name=\"my_dataset\") # (1)\n\nhf_dataset = load_dataset(\"imdb\", split=\"train[:100]\") # (2)\n\ndataset.records.log(records=hf_dataset)\n</code></pre> <ol> <li> <p>In this case, we are using the <code>my_dataset</code> dataset from the Argilla workspace. The dataset has a <code>text</code> field and a <code>label</code> question.</p> </li> <li> <p>In this example, the Hugging Face dataset matches the Argilla dataset schema. If that is not the case, you could use the <code>.map</code> of the <code>datasets</code> library to prepare the data before adding it to the Argilla dataset.</p> </li> </ol> <p>If the Hugging Face dataset's schema does not correspond to your Argilla dataset field names, you can use a <code>mapping</code> to specify the relationship. You should indicate as key the column name of the Hugging Face dataset and, as value, the field name of the Argilla dataset.</p> <pre><code>dataset.records.log(records=hf_dataset, mapping={\"text\": \"review\", \"label\": \"sentiment\"}) # (1)\n</code></pre> <ol> <li>In this case, the <code>text</code> key in the Hugging Face dataset would correspond to the <code>review</code> field in the Argilla dataset, and the <code>label</code> key in the Hugging Face dataset would correspond to the <code>sentiment</code> field in the Argilla dataset.</li> </ol>"},{"location":"how_to_guides/record/#metadata","title":"Metadata","text":"<p>Record metadata can include any information about the record that is not part of the fields in the form of a dictionary. To use metadata for filtering and sorting records, make sure that the key of the dictionary corresponds with the metadata property <code>name</code>. When the key doesn't correspond, this will be considered extra metadata that will get stored with the record (as long as <code>allow_extra_metadata</code> is set to <code>True</code> for the dataset), but will not be usable for filtering and sorting.</p> <p>Note</p> <p>Remember that to use metadata within a dataset, you must define a metadata property in the dataset settings.</p> As <code>Record</code> objectsFrom a generic data structure <p>You can add metadata to a record in an initialized <code>Record</code> object.</p> <pre><code># Add records to the dataset with the metadata 'category'\nrecords = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n        metadata={\"category\": \"A\"},\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n        metadata={\"category\": \"B\"},\n    ),\n]\ndataset.records.log(records)\n</code></pre> <p>You can add metadata to a record directly as a dictionary structure, where the keys correspond to the names of metadata properties in the dataset and the values are the metadata to be added. Remember that you can also use the <code>mapping</code> parameter to specify the data structure.</p> <pre><code># Add records to the dataset with the metadata 'category'\ndata = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n        \"category\": \"A\",\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n        \"category\": \"B\",\n    },\n]\ndataset.records.log(data)\n</code></pre>"},{"location":"how_to_guides/record/#vectors","title":"Vectors","text":"<p>You can associate vectors, like text embeddings, to your records. They can be used for semantic search in the UI and the Python SDK. Make sure that the length of the list corresponds to the dimensions set in the vector settings.</p> <p>Note</p> <p>Remember that to use vectors within a dataset, you must define them in the dataset settings.</p> As <code>Record</code> objectsFrom a generic data structure <p>You can also add vectors to a record in an initialized <code>Record</code> object.</p> <p>Check the Vector - Python Reference to see the attributes, arguments, and methods of the <code>Vector</code> class in detail.</p> <pre><code># Add records to the dataset with the vector 'my_vector' and dimension=3\nrecords = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n        vectors=[\n            rg.Vector(\"my_vector\", [0.1, 0.2, 0.3])\n        ],\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n        vectors=[\n            rg.Vector(\"my_vector\", [0.2, 0.5, 0.3])\n        ],\n    ),\n]\ndataset.records.log(records)\n</code></pre> <p>You can add vectors from a dictionary like structure, where the keys correspond to the <code>name</code>s of the vector settings that were configured for your dataset and the value is a list of floats. Remember that you can also use the <code>mapping</code> parameter to specify the data structure.</p> <pre><code># Add records to the dataset with the vector 'my_vector' and dimension=3\ndata = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n        \"my_vector\": [0.1, 0.2, 0.3],\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n        \"my_vector\": [0.2, 0.5, 0.3],\n    },\n]\ndataset.records.log(data)\n</code></pre>"},{"location":"how_to_guides/record/#suggestions","title":"Suggestions","text":"<p>Suggestions refer to suggested responses (e.g. model predictions) that you can add to your records to make the annotation process faster. These can be added during the creation of the record or at a later stage. Only one suggestion can be provided for each question, and suggestion values must be compliant with the pre-defined questions e.g. if we have a <code>RatingQuestion</code> between 1 and 5, the suggestion should have a valid value within that range.</p> As <code>Record</code> objectsFrom a generic data structure <p>You can also add suggestions to a record in an initialized <code>Record</code> object.</p> <p>Check the Suggestions - Python Reference to see the attributes, arguments, and methods of the <code>Suggestion</code> class in detail.</p> <pre><code># Add records to the dataset with the label 'my_label'\nrecords = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n        suggestions=[\n            rg.Suggestion(\n                \"my_label\",\n                \"positive\",\n                score=0.9,\n                agent=\"model_name\"\n            )\n        ],\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n        suggestions=[\n            rg.Suggestion(\n                \"my_label\",\n                \"negative\",\n                score=0.9,\n                agent=\"model_name\"\n            )\n        ],\n    ),\n]\ndataset.records.log(records)\n</code></pre> <p>You can add suggestions as a dictionary, where the keys correspond to the <code>name</code>s of the labels that were configured for your dataset. Remember that you can also use the <code>mapping</code> parameter to specify the data structure.</p> <pre><code>    # Add records to the dataset with the label question 'my_label'\ndata = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n        \"label\": \"positive\",\n        \"score\": 0.9,\n        \"agent\": \"model_name\",\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n        \"label\": \"negative\",\n        \"score\": 0.9,\n        \"agent\": \"model_name\",\n    },\n]\ndataset.records.log(\n    data=data,\n    mapping={\n        \"label\": \"my_label\",\n        \"score\": \"my_label.suggestion.score\",\n        \"agent\": \"my_label.suggestion.agent\",\n    },\n)\n</code></pre>"},{"location":"how_to_guides/record/#responses","title":"Responses","text":"<p>If your dataset includes some annotations, you can add those to the records as you create them. Make sure that the responses adhere to the same format as Argilla's output and meet the schema requirements for the specific type of question being answered. Make sure to include the <code>user_id</code> in case you're planning to add more than one response for the same question, if not responses will apply to all the annotators.</p> <p>Note</p> <p>Keep in mind that records with responses will be displayed as \"Draft\" in the UI.</p> As <code>Record</code> objectsFrom a generic data structure <p>You can also add suggestions to a record in an initialized <code>Record</code> object.</p> <p>Check the Responses - Python Reference to see the attributes, arguments, and methods of the <code>Suggestion</code> class in detail.</p> <pre><code># Add records to the dataset with the label 'my_label'\nrecords = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n        responses=[\n            rg.Response(\"my_label\", \"positive\", user_id=user.id)\n        ]\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n        responses=[\n            rg.Response(\"my_label\", \"negative\", user_id=user.id)\n        ]\n    ),\n]\ndataset.records.log(records)\n</code></pre> <p>You can add suggestions as a dictionary, where the keys correspond to the <code>name</code>s of the labels that were configured for your dataset. Remember that you can also use the <code>mapping</code> parameter to specify the data structure. If you want to specify the user that added the response, you can use the <code>user_id</code> parameter.</p> <pre><code># Add records to the dataset with the label 'my_label'\ndata = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n        \"label\": \"positive\",\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n        \"label\": \"negative\",\n    },\n]\ndataset.records.log(data, user_id=user.id, mapping={\"label\": \"my_label.response\"})\n</code></pre>"},{"location":"how_to_guides/record/#list-records","title":"List records","text":"<p>To list records in a dataset, you can use the <code>records</code> method on the <code>Dataset</code> object. This method returns a list of <code>Record</code> objects that can be iterated over to access the record properties.</p> <pre><code>for record in dataset.records(\n    with_suggestions=True,\n    with_responses=True,\n    with_vectors=True\n    ):\n\n    # Access the record properties\n    print(record.metadata)\n    print(record.vectors)\n    print(record.suggestions)\n    print(record.responses)\n\n    # Access the responses of the record\n    for response in record.responses:\n        print(record[\"&lt;question_name&gt;\"].value)\n</code></pre>"},{"location":"how_to_guides/record/#update-records","title":"Update records","text":"<p>You can update records in a dataset calling the <code>log</code> method on the <code>Dataset</code> object. To update a record, you need to provide the record <code>id</code> and the new data to be updated.</p> <pre><code>data = dataset.records.to_list(flatten=True)\n\nupdated_data = [\n    {\n        \"text\": sample[\"text\"],\n        \"label\": \"positive\",\n        \"id\": sample[\"id\"],\n    }\n    for sample in data\n]\ndataset.records.log(records=updated_data)\n</code></pre> Update the metadataUpdate vectors <p>The <code>metadata</code> of <code>Record</code> object is a python dictionary. So to update the metadata of a record, you can iterate over the records and update the metadata by key or using <code>metadata.update</code>. After that, you should update the records in the dataset.</p> <pre><code>updated_records = []\n\nfor record in dataset.records():\n\n    record.metadata[\"my_metadata\"] = \"new_value\"\n    record.metadata[\"my_new_metadata\"] = \"new_value\"\n\n    updated_records.append(record)\n\ndataset.records.log(records=updated_records)\n</code></pre> <p>When a new vector field is added to the dataset settings, or some value for the existing record vectors must updated, you can iterate over the records and update the vectors in the same way as the metadata.</p> <pre><code>updated_records = []\n\nfor record in dataset.records():\n\n    record.vectors[\"new_vector\"] = [ 0, 1, 2, 3, 4, 5 ]\n    record.vector[\"v\"] = [ 0.1, 0.2, 0.3 ]\n\n    updated_records.append(record)\n\ndataset.records.log(records=updated_records)\n</code></pre>"},{"location":"how_to_guides/record/#delete-records","title":"Delete records","text":"<p>You can delete records in a dataset calling the <code>delete</code> method on the <code>Dataset</code> object. To delete records, you need to retrieve them from the server and get a list with those that you want to delete.</p> <pre><code>records_to_delete = list(dataset.records)[:5]\ndataset.records.delete(records=records_to_delete)\n</code></pre> <p>Delete records based on a query</p> <p>It can be very useful to avoid eliminating records with responses.</p> <p>For more information about the query syntax, check this how-to guide.</p> <pre><code>status_filter = rg.Query(\n    filter = rg.Filter((\"response.status\", \"==\", \"pending\"))\n)\nrecords_to_delete = list(dataset.records(status_filter))\n\ndataset.records.delete(records_to_delete)\n</code></pre>"},{"location":"how_to_guides/user/","title":"User management","text":"<p>This guide provides an overview of user roles and credentials, explaining how to set up and manage users in Argilla.</p> <p>A user in Argilla is an authorized person, who depending on their role, can use the Python SDK and access the UI in a running Argilla instance. We differentiate between three types of users depending on their role, permissions and needs: <code>owner</code>, <code>admin</code> and <code>annotator</code>.</p> OverviewOwnerAdminAnnotator Owner Admin Annotator Number Unlimited Unlimited Unlimited Create and delete workspaces Yes No No Assign users to workspaces Yes No No Create, configure, update, and delete datasets Yes Only within assigned workspaces No Create, update, and delete users Yes No No Provide feedback with Argila UI Yes Yes Yes <p>The <code>owner</code> refers to the root user who created the Argilla instance. Using workspaces within Argilla proves highly beneficial for organizing tasks efficiently. So, the owner has full access to all workspaces and their functionalities:</p> <ul> <li>Workspace management: It can create, read and delete a workspace.</li> <li>User management: It can create a new user, assign it to a workspace, and delete it. It can also list them and search for a specific one.</li> <li>Dataset management: It can create, configure, retrieve, update, and delete datasets.</li> <li>Annotation: It can annotate datasets in the Argilla UI.</li> <li>Feedback: It can provide feedback with the Argilla UI.</li> </ul> <p>An <code>admin</code> user can only access the workspaces it has been assigned to and cannot assign other users to it. An admin user has the following permissions:</p> <ul> <li>Dataset management: It can create, configure, retrieve, update, and delete datasets only on the assigned workspaces.</li> <li>Annotation: It can annotate datasets in the assigned workspaces via the Argilla UI.</li> <li>Feedback: It can provide feedback with the Argilla UI.</li> </ul> <p>An <code>annotator</code> user is limited to accessing only the datasets assigned to it within the workspace. It has two specific permissions:</p> <ul> <li>Annotation: It can annotate the assigned datasets in the Argilla UI.</li> <li>Feedback: It can provide feedback with the Argilla UI.</li> </ul> Question: Who can manage users? <p>Only users with the <code>owner</code> role can manage (create, retrieve, delete) other users.</p>"},{"location":"how_to_guides/user/#default-users-and-credentials","title":"Default users and credentials","text":"<p>Argilla provides a default user with the <code>owner</code> role to help you get started in Python and the UI. The credentials for this user vary depending on the server configuration.</p> Environment Username Password API Key Quickstart Docker and HF Space owner 12345678 owner.apikey Server image argilla 1234 argilla.apikey <p>Main Class</p> <pre><code>rg.User(\n    username=\"username\",\n    first_name=\"first_name\",\n    last_name=\"last_name\",\n    role=\"owner\",\n    password=\"password\",\n    client=client\n)\n</code></pre> <p>Check the User - Python Reference to see the attributes, arguments, and methods of the <code>User</code> class in detail.</p>"},{"location":"how_to_guides/user/#get-current-user","title":"Get current user","text":"<p>To ensure you're using the correct credentials for managing users, you can get the current user in Argilla using the <code>me</code> attribute of the <code>Argilla</code> class.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\ncurrent_user = client.me\n</code></pre>"},{"location":"how_to_guides/user/#create-a-user","title":"Create a user","text":"<p>To create a new user in Argilla, you can define it in the <code>User</code> class and then call the <code>create</code> method. This method is inherited from the <code>Resource</code> base class and operates without modifications.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nuser_to_create = rg.User(\n    username=\"my_username\",\n    password=\"12345678\",\n    client=client\n)\n\ncreated_user = user_to_create.create()\n</code></pre> <p>Accessing attributes</p> <p>Access the attributes of a user by calling them directly on the <code>User</code> object. For example, <code>user.id</code> or <code>user.username</code>.</p>"},{"location":"how_to_guides/user/#list-users","title":"List users","text":"<p>You can list all the existing users in Argilla by accessing the <code>users</code> attribute on the <code>Argilla</code> class and iterating over them. You can also use <code>len(client.users)</code> to get the number of users.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nusers = client.users\n\nfor user in users:\n    print(user)\n</code></pre> <p>Notebooks</p> <p>When using a notebook, executing <code>client.users</code> will display a table with <code>username</code>, <code>id</code>, <code>role</code>, and the last update as <code>updated_at</code>.</p>"},{"location":"how_to_guides/user/#retrieve-a-user","title":"Retrieve a user","text":"<p>You can retrieve an existing user from Argilla by accessing the <code>users</code> attribute on the <code>Argilla</code> class and passing the <code>username</code> as an argument.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nretrieved_user = client.users(\"my_username\")\n</code></pre>"},{"location":"how_to_guides/user/#list-users-in-a-workspace","title":"List users in a workspace","text":"<p>You can list all the users in a workspace by accessing the <code>users</code> attribute on the <code>Workspace</code> class and iterating over them. You can also use <code>len(workspace.users)</code> to get the number of users by workspace.</p> <p>For further information on how to manage workspaces, check this how-to guide.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces('my_workspace')\n\nfor user in workspace.users:\n    print(user)\n</code></pre>"},{"location":"how_to_guides/user/#add-a-user-to-a-workspace","title":"Add a user to a workspace","text":"<p>You can add an existing user to a workspace in Argilla by calling the <code>add_to_workspace</code> method on the <code>User</code> class.</p> <p>For further information on how to manage workspaces, check this how-to guide.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nuser = client.users('my_username')\nworkspace = client.workspaces('my_workspace')\n\nadded_user = user.add_to_workspace(workspace)\n</code></pre>"},{"location":"how_to_guides/user/#remove-a-user-from-a-workspace","title":"Remove a user from a workspace","text":"<p>You can remove an existing user from a workspace in Argilla by calling the <code>remove_from_workspace</code> method on the <code>User</code> class.</p> <p>For further information on how to manage workspaces, check this how-to guide.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nuser = client.users('my_username')\nworkspace = client.workspaces('my_workspace')\n\nremoved_user = user.remove_from_workspace(workspace)\n</code></pre>"},{"location":"how_to_guides/user/#delete-a-user","title":"Delete a user","text":"<p>You can delete an existing user from Argilla by calling the <code>delete</code> method on the <code>User</code> class.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nuser_to_delete = client.users('my_username')\n\ndeleted_user = user_to_delete.delete()\n</code></pre>"},{"location":"how_to_guides/workspace/","title":"Workspace management","text":"<p>This guide provides an overview of workspaces, explaining how to set up and manage workspaces in Argilla.</p> <p>A workspace is a space inside your Argilla instance where authorized users can collaborate on datasets. It is accessible through the Python SDK and the UI.</p> Question: Who can manage workspaces? <p>Only users with the <code>owner</code> role can manage (create, read and delete) workspaces.</p> <p>A user with the <code>admin</code> role can only read the workspace to which it belongs.</p>"},{"location":"how_to_guides/workspace/#default-workspaces","title":"Default workspaces","text":"<p>Argilla provides a default workspace to help you get started in Python and the UI. The name of this workspace varies depending on the server configuration.</p> Environment Name Quickstart Docker and HF Space admin Server image argilla <p>Main Class</p> <pre><code>rg.Workspace(\n    name = \"name\",\n    client=client\n)\n</code></pre> <p>Check the Workspace - Python Reference to see the attributes, arguments, and methods of the <code>Workspace</code> class in detail.</p>"},{"location":"how_to_guides/workspace/#create-a-new-workspace","title":"Create a new workspace","text":"<p>To create a new workspace in Argilla, you can define it in the <code>Workspace</code> class and then call the <code>create</code> method. This method is inherited from the <code>Resource</code> base class and operates without modifications.</p> <p>When you create a new workspace, it will be empty. To create and add a new dataset, check these guides.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace_to_create = rg.Workspace(\n    name=\"my_workspace\",\n    client=client\n)\n\ncreated_workspace = workspace_to_create.create()\ncreated_workspace\n</code></pre> <p>Accessing attributes</p> <p>Access the attributes of a workspace by calling them directly on the <code>Workspace</code> object. For example, <code>workspace.id</code> or <code>workspace.name</code>.</p>"},{"location":"how_to_guides/workspace/#list-workspaces","title":"List workspaces","text":"<p>You can list all the existing workspaces in Argilla by calling the <code>workspaces</code> attribute on the <code>Argilla</code> class and iterating over them. You can also use <code>len(client.workspaces)</code> to get the number of workspaces.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspaces = client.workspaces\n\nfor workspace in workspaces:\n    print(workspace)\n</code></pre> <p>Notebooks</p> <p>When using a notebook, executing <code>client.workspaces</code> will display a table with the number of <code>datasets</code> in each workspace, <code>name</code>, <code>id</code>, and the last update as <code>updated_at</code>.</p>"},{"location":"how_to_guides/workspace/#retrieve-a-workspace","title":"Retrieve a workspace","text":"<p>You can retrieve a workspace by accessing the <code>workspaces</code> method on the <code>Argilla</code> class and passing the name of the workspace as an argument.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nretrieved_workspace = client.workspaces(\"my_workspace\")\n</code></pre>"},{"location":"how_to_guides/workspace/#check-workspace-existence","title":"Check workspace existence","text":"<p>You can check if a workspace exists by calling the <code>exists</code> method on the <code>Workspace</code> class. This method returns a boolean value.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\nworkspace_existed = workspace.exists()\n</code></pre>"},{"location":"how_to_guides/workspace/#list-users-in-a-workspace","title":"List users in a workspace","text":"<p>You can list all the users in a workspace by accessing the <code>users</code> attribute on the <code>Workspace</code> class and iterating over them. You can also use <code>len(workspace.users)</code> to get the number of users by workspace.</p> <p>For further information on how to manage users, check this how-to guide.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces('my_workspace')\n\nfor user in workspace.users:\n    print(user)\n</code></pre>"},{"location":"how_to_guides/workspace/#add-a-user-to-a-workspace","title":"Add a user to a workspace","text":"<p>You can also add a user to a workspace by calling the <code>add_user</code> method on the <code>Workspace</code> class.</p> <p>For further information on how to manage users, check this how-to guide.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\nadded_user = workspace.add_user(\"my_username\")\n</code></pre>"},{"location":"how_to_guides/workspace/#remove-a-user-from-workspace","title":"Remove a user from workspace","text":"<p>You can also remove a user from a workspace by calling the <code>remove_user</code> method on the <code>Workspace</code> class.</p> <p>For further information on how to manage users, check this how-to guide.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace = client.workspaces(\"my_workspace\")\n\nremoved_user = workspace.remove_user(\"my_username\")\n</code></pre>"},{"location":"how_to_guides/workspace/#delete-a-workspace","title":"Delete a workspace","text":"<p>To delete a workspace, no dataset can be associated with it. If the workspace contains any dataset, deletion will fail. You can delete a workspace by calling the <code>delete</code> method on the <code>Workspace</code> class.</p> <p>To clear a workspace and delete all their datasets, refer to this how-to guide.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(api_url=\"&lt;api_url&gt;\", api_key=\"&lt;api_key&gt;\")\n\nworkspace_to_delete = client.workspaces(\"my_workspace\")\n\ndeleted_workspace = workspace_to_delete.delete()\n</code></pre>"},{"location":"reference/argilla/SUMMARY/","title":"SUMMARY","text":"<ul> <li>rg.Argilla</li> <li>rg.Workspace</li> <li>rg.User</li> <li>rg.Dataset<ul> <li>rg.Dataset.records</li> </ul> </li> <li>rg.Settings<ul> <li>Fields</li> <li>Questions</li> <li>Metadata</li> <li>Vectors</li> </ul> </li> <li>rg.Record<ul> <li>rg.Response</li> <li>rg.Suggestion</li> <li>rg.Vector</li> <li>rg.Metadata</li> </ul> </li> <li>rg.Query</li> </ul>"},{"location":"reference/argilla/client/","title":"<code>rg.Argilla</code>","text":"<p>To interact with the Argilla server from Python you can use the <code>Argilla</code> class. The <code>Argilla</code> client is used to create, get, update, and delete all Argilla resources, such as workspaces, users, datasets, and records.</p>"},{"location":"reference/argilla/client/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla/client/#connecting-to-an-argilla-server","title":"Connecting to an Argilla server","text":"<p>To connect to an Argilla server, instantiate the <code>Argilla</code> class and pass the <code>api_url</code> of the server and the <code>api_key</code> to authenticate.</p> <pre><code>import argilla as rg\n\nclient = rg.Argilla(\n    api_url=\"https://argilla.example.com\",\n    api_key=\"my_token\",\n)\n</code></pre>"},{"location":"reference/argilla/client/#accessing-dataset-workspace-and-user-objects","title":"Accessing Dataset, Workspace, and User objects","text":"<p>The <code>Argilla</code> clients provides access to the <code>Dataset</code>, <code>Workspace</code>, and <code>User</code> objects of the Argilla server.</p> <pre><code>my_dataset = client.datasets(\"my_dataset\")\n\nmy_workspace = client.workspaces(\"my_workspace\")\n\nmy_user = client.users(\"my_user\")\n</code></pre> <p>These resources can then be interacted with to access their properties and methods. For example, to list all datasets in a workspace:</p> <pre><code>for dataset in my_workspace.datasets:\n    print(dataset.name)\n</code></pre>"},{"location":"reference/argilla/client/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla/client/#rgargilla_1","title":"<code>rg.Argilla</code>","text":"<p>               Bases: <code>APIClient</code></p> <p>Argilla API client. This is the main entry point to interact with the API.</p> <p>Attributes:</p> Name Type Description <code>workspaces</code> <code>Workspaces</code> <p>A collection of workspaces.</p> <code>datasets</code> <code>Datasets</code> <p>A collection of datasets.</p> <code>users</code> <code>Users</code> <p>A collection of users.</p> <code>me</code> <code>User</code> <p>The current user.</p> Source code in <code>src/argilla/client.py</code> <pre><code>class Argilla(_api.APIClient):\n    \"\"\"Argilla API client. This is the main entry point to interact with the API.\n\n    Attributes:\n        workspaces: A collection of workspaces.\n        datasets: A collection of datasets.\n        users: A collection of users.\n        me: The current user.\n\n    \"\"\"\n\n    workspaces: \"Workspaces\"\n    datasets: \"Datasets\"\n    users: \"Users\"\n    me: \"User\"\n\n    # Default instance of Argilla\n    _default_client: Optional[\"Argilla\"] = None\n\n    def __init__(\n        self,\n        api_url: Optional[str] = DEFAULT_HTTP_CONFIG.api_url,\n        api_key: Optional[str] = DEFAULT_HTTP_CONFIG.api_key,\n        timeout: int = DEFAULT_HTTP_CONFIG.timeout,\n        **http_client_args,\n    ) -&gt; None:\n        super().__init__(api_url=api_url, api_key=api_key, timeout=timeout, **http_client_args)\n\n        self._set_default(self)\n\n    @property\n    def workspaces(self) -&gt; \"Workspaces\":\n        \"\"\"A collection of workspaces on the server.\"\"\"\n        return Workspaces(client=self)\n\n    @property\n    def datasets(self) -&gt; \"Datasets\":\n        \"\"\"A collection of datasets on the server.\"\"\"\n        return Datasets(client=self)\n\n    @property\n    def users(self) -&gt; \"Users\":\n        \"\"\"A collection of users on the server.\"\"\"\n        return Users(client=self)\n\n    @cached_property\n    def me(self) -&gt; \"User\":\n        from argilla.users import User\n\n        return User(client=self, _model=self.api.users.get_me())\n\n    ############################\n    # Private methods\n    ############################\n\n    @classmethod\n    def _set_default(cls, client: \"Argilla\") -&gt; None:\n        \"\"\"Set the default instance of Argilla.\"\"\"\n        cls._default_client = client\n\n    @classmethod\n    def _get_default(cls) -&gt; \"Argilla\":\n        \"\"\"Get the default instance of Argilla. If it doesn't exist, create a new one.\"\"\"\n        if cls._default_client is None:\n            cls._default_client = Argilla()\n        return cls._default_client\n</code></pre>"},{"location":"reference/argilla/client/#src.argilla.client.Argilla.datasets","title":"<code>datasets: Datasets</code>  <code>property</code>","text":"<p>A collection of datasets on the server.</p>"},{"location":"reference/argilla/client/#src.argilla.client.Argilla.users","title":"<code>users: Users</code>  <code>property</code>","text":"<p>A collection of users on the server.</p>"},{"location":"reference/argilla/client/#src.argilla.client.Argilla.workspaces","title":"<code>workspaces: Workspaces</code>  <code>property</code>","text":"<p>A collection of workspaces on the server.</p>"},{"location":"reference/argilla/search/","title":"<code>rg.Query</code>","text":"<p>To collect records based on searching criteria, you can use the <code>Query</code> and <code>Filter</code> classes. The <code>Query</code> class is used to define the search criteria, while the <code>Filter</code> class is used to filter the search results. <code>Filter</code> is passed to a <code>Query</code> object so you can combine multiple filters to create complex search queries. A <code>Query</code> object can also be passed to <code>Dataset.records</code> to fetch records based on the search criteria.</p>"},{"location":"reference/argilla/search/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla/search/#searching-for-records-with-terms","title":"Searching for records with terms","text":"<p>To search for records with terms, you can use the <code>Dataset.records</code> attribute with a query string. The search terms are used to search for records that contain the terms in the text field.</p> <pre><code>for record in dataset.records(query=\"paris\"):\n    print(record)\n</code></pre>"},{"location":"reference/argilla/search/#filtering-records-by-conditions","title":"Filtering records by conditions","text":"<p>Argilla allows you to filter records based on conditions. You can use the <code>Filter</code> class to define the conditions and pass them to the <code>Dataset.records</code> attribute to fetch records based on the conditions. Conditions include \"==\", \"&gt;=\", \"&lt;=\", or \"in\". Conditions can be combined with dot notation to filter records based on metadata, suggestions, or responses.</p> <pre><code># create a range from 10 to 20\nrange_filter = rg.Filter(\n    [\n        (\"metadata.count\", \"&gt;=\", 10),\n        (\"metadata.count\", \"&lt;=\", 20)\n    ]\n)\n\n# query records with metadata count greater than 10 and less than 20\nquery = rg.Query(filters=range_filter, query=\"paris\")\n\n# iterate over the results\nfor record in dataset.records(query=query):\n    print(record)\n</code></pre>"},{"location":"reference/argilla/search/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla/search/#rgquery_1","title":"<code>rg.Query</code>","text":"<p>This class is used to map user queries to the internal query models</p> Source code in <code>src/argilla/records/_search.py</code> <pre><code>class Query:\n    \"\"\"This class is used to map user queries to the internal query models\"\"\"\n\n    query: Optional[str] = None\n\n    def __init__(self, *, query: Union[str, None] = None, filter: Union[Filter, None] = None):\n        \"\"\"Create a query object for use in Argilla search requests.add()\n\n        Parameters:\n            query (Union[str, None], optional): The query string that will be used to search.\n            filter (Union[Filter, None], optional): The filter object that will be used to filter the search results.\n        \"\"\"\n\n        self.query = query\n        self.filter = filter\n\n    def api_model(self) -&gt; SearchQueryModel:\n        model = SearchQueryModel()\n\n        if self.query is not None:\n            text_query = TextQueryModel(q=self.query)\n            model.query = QueryModel(text=text_query)\n\n        if self.filter is not None:\n            model.filters = self.filter.api_model()\n\n        return model\n</code></pre>"},{"location":"reference/argilla/search/#src.argilla.records._search.Query.__init__","title":"<code>__init__(*, query=None, filter=None)</code>","text":"<p>Create a query object for use in Argilla search requests.add()</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Union[str, None]</code> <p>The query string that will be used to search.</p> <code>None</code> <code>filter</code> <code>Union[Filter, None]</code> <p>The filter object that will be used to filter the search results.</p> <code>None</code> Source code in <code>src/argilla/records/_search.py</code> <pre><code>def __init__(self, *, query: Union[str, None] = None, filter: Union[Filter, None] = None):\n    \"\"\"Create a query object for use in Argilla search requests.add()\n\n    Parameters:\n        query (Union[str, None], optional): The query string that will be used to search.\n        filter (Union[Filter, None], optional): The filter object that will be used to filter the search results.\n    \"\"\"\n\n    self.query = query\n    self.filter = filter\n</code></pre>"},{"location":"reference/argilla/search/#rgfilter","title":"<code>rg.Filter</code>","text":"<p>This class is used to map user filters to the internal filter models</p> Source code in <code>src/argilla/records/_search.py</code> <pre><code>class Filter:\n    \"\"\"This class is used to map user filters to the internal filter models\"\"\"\n\n    def __init__(self, conditions: Union[List[Tuple[str, str, Any]], Tuple[str, str, Any], None] = None):\n        \"\"\" Create a filter object for use in Argilla search requests.\n\n        Parameters:\n            conditions (Union[List[Tuple[str, str, Any]], Tuple[str, str, Any], None], optional): \\\n                The conditions that will be used to filter the search results. \\\n                The conditions should be a list of tuples where each tuple contains \\\n                the field, operator, and value. For example `(\"label\", \"in\", [\"positive\",\"happy\"])`.\\\n\n        \"\"\"\n\n        if isinstance(conditions, tuple):\n            conditions = [conditions]\n        self.conditions = [Condition(condition) for condition in conditions]\n\n    def api_model(self) -&gt; AndFilterModel:\n        return AndFilterModel.model_validate({\"and\": [condition.api_model() for condition in self.conditions]})\n</code></pre>"},{"location":"reference/argilla/search/#src.argilla.records._search.Filter.__init__","title":"<code>__init__(conditions=None)</code>","text":"<p>Create a filter object for use in Argilla search requests.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>Union[List[Tuple[str, str, Any]], Tuple[str, str, Any], None]</code> <p>The conditions that will be used to filter the search results.                 The conditions should be a list of tuples where each tuple contains                 the field, operator, and value. For example <code>(\"label\", \"in\", [\"positive\",\"happy\"])</code>.</p> <code>None</code> Source code in <code>src/argilla/records/_search.py</code> <pre><code>def __init__(self, conditions: Union[List[Tuple[str, str, Any]], Tuple[str, str, Any], None] = None):\n    \"\"\" Create a filter object for use in Argilla search requests.\n\n    Parameters:\n        conditions (Union[List[Tuple[str, str, Any]], Tuple[str, str, Any], None], optional): \\\n            The conditions that will be used to filter the search results. \\\n            The conditions should be a list of tuples where each tuple contains \\\n            the field, operator, and value. For example `(\"label\", \"in\", [\"positive\",\"happy\"])`.\\\n\n    \"\"\"\n\n    if isinstance(conditions, tuple):\n        conditions = [conditions]\n    self.conditions = [Condition(condition) for condition in conditions]\n</code></pre>"},{"location":"reference/argilla/users/","title":"<code>rg.User</code>","text":"<p>A user in Argilla is a profile that uses the SDK or UI. Their profile can be used to track their feedback activity and to manage their access to the Argilla server.</p>"},{"location":"reference/argilla/users/#usage-examples","title":"Usage Examples","text":"<p>To create a new user, instantiate the <code>User</code> object with the client and the username:</p> <pre><code>user = rg.User(username=\"my_username\", password=\"my_password\")\nuser.create()\n</code></pre> <p>Existing users can be retrieved by their username:</p> <pre><code>user = client.users(\"my_username\")\n</code></pre> <p>The current user of the <code>rg.Argilla</code> client can be accessed using the <code>me</code> attribute:</p> <pre><code>client.me\n</code></pre>"},{"location":"reference/argilla/users/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla/users/#rguser_1","title":"<code>rg.User</code>","text":"<p>               Bases: <code>Resource</code></p> <p>Class for interacting with Argilla users in the Argilla server. User profiles         are used to manage access to the Argilla server and track responses to records.</p> <p>Attributes:</p> Name Type Description <code>username</code> <code>str</code> <p>The username of the user.</p> <code>first_name</code> <code>str</code> <p>The first name of the user.</p> <code>last_name</code> <code>str</code> <p>The last name of the user.</p> <code>role</code> <code>str</code> <p>The role of the user, either 'annotator' or 'admin'.</p> <code>password</code> <code>str</code> <p>The password of the user.</p> <code>id</code> <code>UUID</code> <p>The ID of the user.</p> Source code in <code>src/argilla/users/_resource.py</code> <pre><code>class User(Resource):\n    \"\"\"Class for interacting with Argilla users in the Argilla server. User profiles \\\n        are used to manage access to the Argilla server and track responses to records.\n\n    Attributes:\n        username (str): The username of the user.\n        first_name (str): The first name of the user.\n        last_name (str): The last name of the user.\n        role (str): The role of the user, either 'annotator' or 'admin'.\n        password (str): The password of the user.\n        id (UUID): The ID of the user.\n    \"\"\"\n\n    _model: UserModel\n    _api: UsersAPI\n\n    def __init__(\n        self,\n        username: Optional[str] = None,\n        first_name: Optional[str] = None,\n        last_name: Optional[str] = None,\n        role: Optional[str] = None,\n        password: Optional[str] = None,\n        client: Optional[\"Argilla\"] = None,\n        id: Optional[UUID] = None,\n        _model: Optional[UserModel] = None,\n    ) -&gt; None:\n        \"\"\"Initializes a User object with a client and a username\n\n        Parameters:\n            username (str): The username of the user\n            first_name (str): The first name of the user\n            last_name (str): The last name of the user\n            role (str): The role of the user, either 'annotator', admin, or 'owner'\n            password (str): The password of the user\n            client (Argilla): The client used to interact with Argilla\n\n        Returns:\n            User: The initialized user object\n        ```\n        \"\"\"\n        client = client or Argilla._get_default()\n        super().__init__(client=client, api=client.api.users)\n\n        if _model is None:\n            _model = UserModel(\n                username=username,\n                password=password,\n                first_name=first_name or username,\n                last_name=last_name,\n                role=role or Role.annotator,\n                id=id,\n            )\n            self._log_message(f\"Initialized user with username {username}\")\n        self._model = _model\n\n    def create(self) -&gt; \"User\":\n        \"\"\"Creates the user in Argilla. After creating a user, it will be able to log in to the Argilla server.\n\n        Returns:\n            User: The user that was created in Argilla.\n\n        \"\"\"\n        model_create = self.api_model()\n        model = self._api.create(model_create)\n        # The password is not returned in the response\n        model.password = model_create.password\n        self._model = model\n        return self\n\n    def delete(self) -&gt; None:\n        \"\"\"Deletes the user from Argilla. After deleting a user, it will no longer be able to log in to the Argilla server.\"\"\"\n        super().delete()\n        # exists relies on the id, so we need to set it to None\n        self._model = UserModel(username=self.username)\n\n    def exists(self) -&gt; bool:\n        \"\"\"Checks if the user exists in Argilla\n\n        Returns:\n            bool: True if the user exists, False otherwise.\n        \"\"\"\n        # TODO - Implement the exist method in the API\n        return self.id is not None\n\n    def add_to_workspace(self, workspace: \"Workspace\") -&gt; \"User\":\n        \"\"\"Adds the user to a workspace. After adding a user to a workspace, it will have access to the datasets\n        in the workspace.\n\n        Args:\n            workspace (Workspace): The workspace to add the user to.\n\n        Returns:\n            User: The user that was added to the workspace.\n        \"\"\"\n        self._model = self._api.add_to_workspace(workspace.id, self.id)\n        return self\n\n    def remove_from_workspace(self, workspace: \"Workspace\") -&gt; \"User\":\n        \"\"\"Removes the user from a workspace. After removing a user from a workspace, it will no longer have access to\n        the datasets in the workspace.\n\n        Args:\n            workspace (Workspace): The workspace to remove the user from.\n\n        Returns:\n            User: The user that was removed from the workspace.\n\n        \"\"\"\n        self._model = self._api.delete_from_workspace(workspace.id, self.id)\n        return self\n\n    ############################\n    # Properties\n    ############################\n    @property\n    def username(self) -&gt; str:\n        return self._model.username\n\n    @username.setter\n    def username(self, value: str) -&gt; None:\n        self._model.username = value\n\n    @property\n    def password(self) -&gt; str:\n        return self._model.password\n\n    @password.setter\n    def password(self, value: str) -&gt; None:\n        self._model.password = value\n\n    @property\n    def first_name(self) -&gt; str:\n        return self._model.first_name\n\n    @first_name.setter\n    def first_name(self, value: str) -&gt; None:\n        self._model.first_name = value\n\n    @property\n    def last_name(self) -&gt; str:\n        return self._model.last_name\n\n    @last_name.setter\n    def last_name(self, value: str) -&gt; None:\n        self._model.last_name = value\n\n    @property\n    def role(self) -&gt; Role:\n        return self._model.role\n\n    @role.setter\n    def role(self, value: Role) -&gt; None:\n        self._model.role = value\n</code></pre>"},{"location":"reference/argilla/users/#src.argilla.users._resource.User.__init__","title":"<code>__init__(username=None, first_name=None, last_name=None, role=None, password=None, client=None, id=None, _model=None)</code>","text":"<p>Initializes a User object with a client and a username</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username of the user</p> <code>None</code> <code>first_name</code> <code>str</code> <p>The first name of the user</p> <code>None</code> <code>last_name</code> <code>str</code> <p>The last name of the user</p> <code>None</code> <code>role</code> <code>str</code> <p>The role of the user, either 'annotator', admin, or 'owner'</p> <code>None</code> <code>password</code> <code>str</code> <p>The password of the user</p> <code>None</code> <code>client</code> <code>Argilla</code> <p>The client used to interact with Argilla</p> <code>None</code> <p>Returns:</p> Name Type Description <code>User</code> <code>None</code> <p>The initialized user object</p> <p>```</p> Source code in <code>src/argilla/users/_resource.py</code> <pre><code>def __init__(\n    self,\n    username: Optional[str] = None,\n    first_name: Optional[str] = None,\n    last_name: Optional[str] = None,\n    role: Optional[str] = None,\n    password: Optional[str] = None,\n    client: Optional[\"Argilla\"] = None,\n    id: Optional[UUID] = None,\n    _model: Optional[UserModel] = None,\n) -&gt; None:\n    \"\"\"Initializes a User object with a client and a username\n\n    Parameters:\n        username (str): The username of the user\n        first_name (str): The first name of the user\n        last_name (str): The last name of the user\n        role (str): The role of the user, either 'annotator', admin, or 'owner'\n        password (str): The password of the user\n        client (Argilla): The client used to interact with Argilla\n\n    Returns:\n        User: The initialized user object\n    ```\n    \"\"\"\n    client = client or Argilla._get_default()\n    super().__init__(client=client, api=client.api.users)\n\n    if _model is None:\n        _model = UserModel(\n            username=username,\n            password=password,\n            first_name=first_name or username,\n            last_name=last_name,\n            role=role or Role.annotator,\n            id=id,\n        )\n        self._log_message(f\"Initialized user with username {username}\")\n    self._model = _model\n</code></pre>"},{"location":"reference/argilla/users/#src.argilla.users._resource.User.add_to_workspace","title":"<code>add_to_workspace(workspace)</code>","text":"<p>Adds the user to a workspace. After adding a user to a workspace, it will have access to the datasets in the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Workspace</code> <p>The workspace to add the user to.</p> required <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>The user that was added to the workspace.</p> Source code in <code>src/argilla/users/_resource.py</code> <pre><code>def add_to_workspace(self, workspace: \"Workspace\") -&gt; \"User\":\n    \"\"\"Adds the user to a workspace. After adding a user to a workspace, it will have access to the datasets\n    in the workspace.\n\n    Args:\n        workspace (Workspace): The workspace to add the user to.\n\n    Returns:\n        User: The user that was added to the workspace.\n    \"\"\"\n    self._model = self._api.add_to_workspace(workspace.id, self.id)\n    return self\n</code></pre>"},{"location":"reference/argilla/users/#src.argilla.users._resource.User.create","title":"<code>create()</code>","text":"<p>Creates the user in Argilla. After creating a user, it will be able to log in to the Argilla server.</p> <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>The user that was created in Argilla.</p> Source code in <code>src/argilla/users/_resource.py</code> <pre><code>def create(self) -&gt; \"User\":\n    \"\"\"Creates the user in Argilla. After creating a user, it will be able to log in to the Argilla server.\n\n    Returns:\n        User: The user that was created in Argilla.\n\n    \"\"\"\n    model_create = self.api_model()\n    model = self._api.create(model_create)\n    # The password is not returned in the response\n    model.password = model_create.password\n    self._model = model\n    return self\n</code></pre>"},{"location":"reference/argilla/users/#src.argilla.users._resource.User.delete","title":"<code>delete()</code>","text":"<p>Deletes the user from Argilla. After deleting a user, it will no longer be able to log in to the Argilla server.</p> Source code in <code>src/argilla/users/_resource.py</code> <pre><code>def delete(self) -&gt; None:\n    \"\"\"Deletes the user from Argilla. After deleting a user, it will no longer be able to log in to the Argilla server.\"\"\"\n    super().delete()\n    # exists relies on the id, so we need to set it to None\n    self._model = UserModel(username=self.username)\n</code></pre>"},{"location":"reference/argilla/users/#src.argilla.users._resource.User.exists","title":"<code>exists()</code>","text":"<p>Checks if the user exists in Argilla</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the user exists, False otherwise.</p> Source code in <code>src/argilla/users/_resource.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Checks if the user exists in Argilla\n\n    Returns:\n        bool: True if the user exists, False otherwise.\n    \"\"\"\n    # TODO - Implement the exist method in the API\n    return self.id is not None\n</code></pre>"},{"location":"reference/argilla/users/#src.argilla.users._resource.User.remove_from_workspace","title":"<code>remove_from_workspace(workspace)</code>","text":"<p>Removes the user from a workspace. After removing a user from a workspace, it will no longer have access to the datasets in the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Workspace</code> <p>The workspace to remove the user from.</p> required <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>The user that was removed from the workspace.</p> Source code in <code>src/argilla/users/_resource.py</code> <pre><code>def remove_from_workspace(self, workspace: \"Workspace\") -&gt; \"User\":\n    \"\"\"Removes the user from a workspace. After removing a user from a workspace, it will no longer have access to\n    the datasets in the workspace.\n\n    Args:\n        workspace (Workspace): The workspace to remove the user from.\n\n    Returns:\n        User: The user that was removed from the workspace.\n\n    \"\"\"\n    self._model = self._api.delete_from_workspace(workspace.id, self.id)\n    return self\n</code></pre>"},{"location":"reference/argilla/workspaces/","title":"<code>rg.Workspace</code>","text":"<p>In Argilla, workspaces are used to organize datasets in to groups. For example, you might have a workspace for each project or team.</p>"},{"location":"reference/argilla/workspaces/#usage-examples","title":"Usage Examples","text":"<p>To create a new workspace, instantiate the <code>Workspace</code> object with the client and the name:</p> <pre><code>workspace = rg.Workspace(name=\"my_workspace\")\nworkspace.create()\n</code></pre> <p>To retrieve an existing workspace, use the <code>client.workspaces</code> attribute:</p> <pre><code>workspace = client.workspaces(\"my_workspace\")\n</code></pre>"},{"location":"reference/argilla/workspaces/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla/workspaces/#rgworkspace_1","title":"<code>rg.Workspace</code>","text":"<p>               Bases: <code>Resource</code></p> <p>Class for interacting with Argilla workspaces. Workspaces are used to organize datasets in the Argilla server.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the workspace.</p> <code>id</code> <code>UUID</code> <p>The ID of the workspace. This is a unique identifier for the workspace in the server.</p> <code>datasets</code> <code>List[Dataset]</code> <p>A list of all datasets in the workspace.</p> <code>users</code> <code>WorkspaceUsers</code> <p>A list of all users in the workspace.</p> Source code in <code>src/argilla/workspaces/_resource.py</code> <pre><code>class Workspace(Resource):\n    \"\"\"Class for interacting with Argilla workspaces. Workspaces are used to organize datasets in the Argilla server.\n\n    Attributes:\n        name (str): The name of the workspace.\n        id (UUID): The ID of the workspace. This is a unique identifier for the workspace in the server.\n        datasets (List[Dataset]): A list of all datasets in the workspace.\n        users (WorkspaceUsers): A list of all users in the workspace.\n    \"\"\"\n\n    name: Optional[str]\n\n    _api: \"WorkspacesAPI\"\n\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        id: Optional[UUID] = None,\n        client: Optional[\"Argilla\"] = None,\n    ) -&gt; None:\n        \"\"\"Initializes a Workspace object with a client and a name or id\n\n        Parameters:\n            client (Argilla): The client used to interact with Argilla\n            name (str): The name of the workspace\n            id (UUID): The id of the workspace\n        Returns:\n            Workspace: The initialized workspace object\n        \"\"\"\n        client = client or Argilla._get_default()\n        super().__init__(client=client, api=client.api.workspaces)\n\n        self._model = WorkspaceModel(name=name, id=id)\n\n    def exists(self) -&gt; bool:\n        \"\"\"\n        Checks if the workspace exists in the server\n\n        Returns:\n            bool: True if the workspace exists, False otherwise\n        \"\"\"\n        return self._api.exists(self.id)\n\n    def add_user(self, user: Union[\"User\", str]) -&gt; \"User\":\n        \"\"\"Adds a user to the workspace. After adding a user to the workspace, it will have access to the datasets\n        in the workspace.\n\n        Args:\n            user (Union[User, str]): The user to add to the workspace. Can be a User object or a username.\n\n        Returns:\n            User: The user that was added to the workspace\n        \"\"\"\n        return self.users.add(user)\n\n    def remove_user(self, user: Union[\"User\", str]) -&gt; \"User\":\n        \"\"\"Removes a user from the workspace. After removing a user from the workspace, it will no longer have access\n\n        Args:\n            user (Union[User, str]): The user to remove from the workspace. Can be a User object or a username.\n\n        Returns:\n            User: The user that was removed from the workspace.\n        \"\"\"\n        return self.users.delete(user)\n\n    # TODO: Make this method private\n    def list_datasets(self) -&gt; List[\"Dataset\"]:\n        from argilla.datasets import Dataset\n\n        datasets = self._client.api.datasets.list(self.id)\n        self._log_message(f\"Got {len(datasets)} datasets for workspace {self.id}\")\n        return [Dataset.from_model(model=dataset, client=self._client) for dataset in datasets]\n\n    @classmethod\n    def from_model(cls, model: WorkspaceModel, client: Argilla) -&gt; \"Workspace\":\n        instance = cls(name=model.name, id=model.id, client=client)\n        instance._model = model\n\n        return instance\n\n    ############################\n    # Properties\n    ############################\n\n    @property\n    def name(self) -&gt; Optional[str]:\n        return self._model.name\n\n    @name.setter\n    def name(self, value: str) -&gt; None:\n        self._model.name = value\n\n    @property\n    def datasets(self) -&gt; List[\"Dataset\"]:\n        \"\"\"List all datasets in the workspace\n\n        Returns:\n            List[Dataset]: A list of all datasets in the workspace\n        \"\"\"\n        return self.list_datasets()\n\n    @property\n    def users(self) -&gt; \"WorkspaceUsers\":\n        \"\"\"List all users in the workspace\n\n        Returns:\n            WorkspaceUsers: A list of all users in the workspace\n\n        \"\"\"\n        return WorkspaceUsers(workspace=self)\n</code></pre>"},{"location":"reference/argilla/workspaces/#src.argilla.workspaces._resource.Workspace.datasets","title":"<code>datasets: List[Dataset]</code>  <code>property</code>","text":"<p>List all datasets in the workspace</p> <p>Returns:</p> Type Description <code>List[Dataset]</code> <p>List[Dataset]: A list of all datasets in the workspace</p>"},{"location":"reference/argilla/workspaces/#src.argilla.workspaces._resource.Workspace.users","title":"<code>users: WorkspaceUsers</code>  <code>property</code>","text":"<p>List all users in the workspace</p> <p>Returns:</p> Name Type Description <code>WorkspaceUsers</code> <code>WorkspaceUsers</code> <p>A list of all users in the workspace</p>"},{"location":"reference/argilla/workspaces/#src.argilla.workspaces._resource.Workspace.__init__","title":"<code>__init__(name=None, id=None, client=None)</code>","text":"<p>Initializes a Workspace object with a client and a name or id</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Argilla</code> <p>The client used to interact with Argilla</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the workspace</p> <code>None</code> <code>id</code> <code>UUID</code> <p>The id of the workspace</p> <code>None</code> <p>Returns:     Workspace: The initialized workspace object</p> Source code in <code>src/argilla/workspaces/_resource.py</code> <pre><code>def __init__(\n    self,\n    name: Optional[str] = None,\n    id: Optional[UUID] = None,\n    client: Optional[\"Argilla\"] = None,\n) -&gt; None:\n    \"\"\"Initializes a Workspace object with a client and a name or id\n\n    Parameters:\n        client (Argilla): The client used to interact with Argilla\n        name (str): The name of the workspace\n        id (UUID): The id of the workspace\n    Returns:\n        Workspace: The initialized workspace object\n    \"\"\"\n    client = client or Argilla._get_default()\n    super().__init__(client=client, api=client.api.workspaces)\n\n    self._model = WorkspaceModel(name=name, id=id)\n</code></pre>"},{"location":"reference/argilla/workspaces/#src.argilla.workspaces._resource.Workspace.add_user","title":"<code>add_user(user)</code>","text":"<p>Adds a user to the workspace. After adding a user to the workspace, it will have access to the datasets in the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Union[User, str]</code> <p>The user to add to the workspace. Can be a User object or a username.</p> required <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>The user that was added to the workspace</p> Source code in <code>src/argilla/workspaces/_resource.py</code> <pre><code>def add_user(self, user: Union[\"User\", str]) -&gt; \"User\":\n    \"\"\"Adds a user to the workspace. After adding a user to the workspace, it will have access to the datasets\n    in the workspace.\n\n    Args:\n        user (Union[User, str]): The user to add to the workspace. Can be a User object or a username.\n\n    Returns:\n        User: The user that was added to the workspace\n    \"\"\"\n    return self.users.add(user)\n</code></pre>"},{"location":"reference/argilla/workspaces/#src.argilla.workspaces._resource.Workspace.exists","title":"<code>exists()</code>","text":"<p>Checks if the workspace exists in the server</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the workspace exists, False otherwise</p> Source code in <code>src/argilla/workspaces/_resource.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"\n    Checks if the workspace exists in the server\n\n    Returns:\n        bool: True if the workspace exists, False otherwise\n    \"\"\"\n    return self._api.exists(self.id)\n</code></pre>"},{"location":"reference/argilla/workspaces/#src.argilla.workspaces._resource.Workspace.remove_user","title":"<code>remove_user(user)</code>","text":"<p>Removes a user from the workspace. After removing a user from the workspace, it will no longer have access</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Union[User, str]</code> <p>The user to remove from the workspace. Can be a User object or a username.</p> required <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>The user that was removed from the workspace.</p> Source code in <code>src/argilla/workspaces/_resource.py</code> <pre><code>def remove_user(self, user: Union[\"User\", str]) -&gt; \"User\":\n    \"\"\"Removes a user from the workspace. After removing a user from the workspace, it will no longer have access\n\n    Args:\n        user (Union[User, str]): The user to remove from the workspace. Can be a User object or a username.\n\n    Returns:\n        User: The user that was removed from the workspace.\n    \"\"\"\n    return self.users.delete(user)\n</code></pre>"},{"location":"reference/argilla/datasets/dataset_records/","title":"<code>rg.Dataset.records</code>","text":""},{"location":"reference/argilla/datasets/dataset_records/#usage-examples","title":"Usage Examples","text":"<p>In most cases, you will not need to create a <code>DatasetRecords</code> object directly. Instead, you can access it via the <code>Dataset</code> object:</p> <pre><code>dataset.records\n</code></pre> <p>For user familiar with legacy approaches</p> <ol> <li><code>Dataset.records</code> object is used to interact with the records in a dataset. It interactively fetches records from the server in batches without using a local copy of the records.</li> <li>The <code>log</code> method of <code>Dataset.records</code> is used to both add and update records in a dataset. If the record includes a known <code>id</code> field, the record will be updated. If the record does not include a known <code>id</code> field, the record will be added.</li> </ol>"},{"location":"reference/argilla/datasets/dataset_records/#adding-records-to-a-dataset","title":"Adding records to a dataset","text":"<p>To add records to a dataset, use the <code>log</code> method. Records can be added as dictionaries or as <code>Record</code> objects. Single records can also be added as a dictionary or <code>Record</code>.</p> As a <code>Record</code> objectFrom a data structureFrom a data structure with a mappingFrom a Hugging Face dataset <p>You can also add records to a dataset by initializing a <code>Record</code> object directly.</p> <pre><code>records = [\n    rg.Record(\n        fields={\n            \"question\": \"Do you need oxygen to breathe?\",\n            \"answer\": \"Yes\"\n        },\n    ),\n    rg.Record(\n        fields={\n            \"question\": \"What is the boiling point of water?\",\n            \"answer\": \"100 degrees Celsius\"\n        },\n    ),\n] # (1)\n\ndataset.records.log(records)\n</code></pre> <ol> <li>This is an illustration of a definition. In a real world scenario, you would iterate over a data structure and create <code>Record</code> objects for each iteration.</li> </ol> <pre><code>data = [\n    {\n        \"question\": \"Do you need oxygen to breathe?\",\n        \"answer\": \"Yes\",\n    },\n    {\n        \"question\": \"What is the boiling point of water?\",\n        \"answer\": \"100 degrees Celsius\",\n    },\n] # (1)\n\ndataset.records.log(data)\n</code></pre> <ol> <li>The data structure's keys must match the fields or questions in the Argilla dataset. In this case, there are fields named <code>question</code> and <code>answer</code>.</li> </ol> <pre><code>data = [\n    {\n        \"query\": \"Do you need oxygen to breathe?\",\n        \"response\": \"Yes\",\n    },\n    {\n        \"query\": \"What is the boiling point of water?\",\n        \"response\": \"100 degrees Celsius\",\n    },\n] # (1)\ndataset.records.log(\n    records=data,\n    mapping={\"query\": \"question\", \"response\": \"answer\"} # (2)\n)\n</code></pre> <ol> <li>The data structure's keys must match the fields or questions in the Argilla dataset. In this case, there are fields named <code>question</code> and <code>answer</code>.</li> <li>The data structure has keys <code>query</code> and <code>response</code> and the Argilla dataset has <code>question</code> and <code>answer</code>. You can use the <code>mapping</code> parameter to map the keys in the data structure to the fields in the Argilla dataset.</li> </ol> <p>You can also add records to a dataset using a Hugging Face dataset. This is useful when you want to use a dataset from the Hugging Face Hub and add it to your Argilla dataset.</p> <p>You can add the dataset where the column names correspond to the names of fields, questions, metadata or vectors in the Argilla dataset.</p> <p>If the dataset's schema does not correspond to your Argilla dataset names, you can use a <code>mapping</code> to indicate which columns in the dataset correspond to the Argilla dataset fields.</p> <pre><code>from datasets import load_dataset\n\nhf_dataset = load_dataset(\"imdb\", split=\"train[:100]\") # (1)\n\ndataset.records.log(records=hf_dataset)\n</code></pre> <ol> <li>In this example, the Hugging Face dataset matches the Argilla dataset schema. If that is not the case, you could use the <code>.map</code> of the <code>datasets</code> library to prepare the data before adding it to the Argilla dataset.</li> </ol> <p>Here we use the <code>mapping</code> parameter to specify the relationship between the Hugging Face dataset and the Argilla dataset.</p> <pre><code>dataset.records.log(records=hf_dataset, mapping={\"txt\": \"text\", \"y\": \"label\"}) # (1)\n</code></pre> <ol> <li>In this case, the <code>txt</code> key in the Hugging Face dataset corresponds to the <code>text</code> field in the Argilla dataset, and the <code>y</code> key in the Hugging Face dataset corresponds to the <code>label</code> field in the Argilla dataset.</li> </ol>"},{"location":"reference/argilla/datasets/dataset_records/#updating-records-in-a-dataset","title":"Updating records in a dataset","text":"<p>Records can also be updated using the <code>log</code> method with records that contain an <code>id</code> to identify the records to be updated. As above, records can be added as dictionaries or as <code>Record</code> objects.</p> As a <code>Record</code> objectFrom a data structureFrom a data structure with a mappingFrom a Hugging Face dataset <p>You can update records in a dataset by initializing a <code>Record</code> object directly and providing the <code>id</code> field.</p> <pre><code>records = [\n    rg.Record(\n        metadata={\"department\": \"toys\"},\n        id=\"2\" # (1)\n    ),\n] # (1)\n\ndataset.records.log(records)\n</code></pre> <ol> <li>The <code>id</code> field is required to identify the record to be updated. The <code>id</code> field must be unique for each record in the dataset. If the <code>id</code> field is not provided, the record will be added as a new record.</li> </ol> <p>You can also update records in a dataset by providing the <code>id</code> field in the data structure.</p> <pre><code>data = [\n    {\n        \"metadata\": {\"department\": \"toys\"},\n        \"id\": \"2\" # (1)\n    },\n] # (1)\n\ndataset.records.log(data)\n</code></pre> <ol> <li>The <code>id</code> field is required to identify the record to be updated. The <code>id</code> field must be unique for each record in the dataset. If the <code>id</code> field is not provided, the record will be added as a new record.</li> </ol> <p>You can also update records in a dataset by providing the <code>id</code> field in the data structure and using a mapping to map the keys in the data structure to the fields in the dataset.</p> <p><pre><code>data = [\n    {\n        \"metadata\": {\"department\": \"toys\"},\n        \"my_id\": \"2\" # (1)\n    },\n]\n\ndataset.records.log(\n    records=data,\n    mapping={\"my_id\": \"id\"} # (2)\n)\n</code></pre> 1. The <code>id</code> field is required to identify the record to be updated. The <code>id</code> field must be unique for each record in the dataset. If the <code>id</code> field is not provided, the record will be added as a new record. 2. Let's say that your data structure has keys <code>my_id</code> instead of <code>id</code>. You can use the <code>mapping</code> parameter to map the keys in the data structure to the fields in the dataset.</p> <p>You can also update records to an Argilla dataset using a Hugging Face dataset. To update records, the Hugging Face dataset must contain an <code>id</code> field to identify the records to be updated, or you can use a mapping to map the keys in the Hugging Face dataset to the fields in the Argilla dataset.</p> <pre><code>from datasets import load_dataset\n\nhf_dataset = load_dataset(\"imdb\", split=\"train[:100]\") # (1)\n\ndataset.records.log(records=hf_dataset, mapping={\"uuid\": \"id\"}) # (2)\n</code></pre> <ol> <li>In this example, the Hugging Face dataset matches the Argilla dataset schema.</li> <li>The <code>uuid</code> key in the Hugging Face dataset corresponds to the <code>id</code> field in the Argilla dataset.</li> </ol>"},{"location":"reference/argilla/datasets/dataset_records/#iterating-over-records-in-a-dataset","title":"Iterating over records in a dataset","text":"<p><code>Dataset.records</code> can be used to iterate over records in a dataset from the server. The records will be fetched in batches from the server::</p> <pre><code>for record in dataset.records:\n    print(record)\n\n# Fetch records with suggestions and responses\nfor record in dataset.records(with_suggestions=True, with_responses=True):\n    print(record.suggestions)\n    print(record.responses)\n\n# Filter records by a query and fetch records with vectors\nfor record in dataset.records(query=\"capital\", with_vectors=True):\n    print(record.vectors)\n</code></pre> <p>Check out the <code>rg.Record</code> class reference for more information on the properties and methods available on a record and the <code>rg.Query</code> class reference for more information on the query syntax.</p>"},{"location":"reference/argilla/datasets/dataset_records/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla/datasets/dataset_records/#rgdatasetrecords_1","title":"<code>rg.Dataset.records</code>","text":"<p>               Bases: <code>Iterable[Record]</code>, <code>LoggingMixin</code></p> <p>This class is used to work with records from a dataset and is accessed via <code>Dataset.records</code>. The responsibility of this class is to provide an interface to interact with records in a dataset, by adding, updating, fetching, querying, deleting, and exporting records.</p> <p>Attributes:</p> Name Type Description <code>client</code> <code>Argilla</code> <p>The Argilla client object.</p> <code>dataset</code> <code>Dataset</code> <p>The dataset object.</p> Source code in <code>src/argilla/records/_dataset_records.py</code> <pre><code>class DatasetRecords(Iterable[Record], LoggingMixin):\n    \"\"\"This class is used to work with records from a dataset and is accessed via `Dataset.records`.\n    The responsibility of this class is to provide an interface to interact with records in a dataset,\n    by adding, updating, fetching, querying, deleting, and exporting records.\n\n    Attributes:\n        client (Argilla): The Argilla client object.\n        dataset (Dataset): The dataset object.\n    \"\"\"\n\n    _api: RecordsAPI\n\n    DEFAULT_BATCH_SIZE = 256\n\n    def __init__(self, client: \"Argilla\", dataset: \"Dataset\"):\n        \"\"\"Initializes a DatasetRecords object with a client and a dataset.\n        Args:\n            client: An Argilla client object.\n            dataset: A Dataset object.\n        \"\"\"\n        self.__client = client\n        self.__dataset = dataset\n        self._api = self.__client.api.records\n\n    def __iter__(self):\n        return DatasetRecordsIterator(self.__dataset, self.__client, with_suggestions=True, with_responses=True)\n\n    def __call__(\n        self,\n        query: Optional[Union[str, Query]] = None,\n        batch_size: Optional[int] = DEFAULT_BATCH_SIZE,\n        start_offset: int = 0,\n        with_suggestions: bool = True,\n        with_responses: bool = True,\n        with_vectors: Optional[Union[List, bool, str]] = None,\n    ) -&gt; DatasetRecordsIterator:\n        \"\"\"Returns an iterator over the records in the dataset on the server.\n\n        Parameters:\n            query: A string or a Query object to filter the records.\n            batch_size: The number of records to fetch in each batch. The default is 256.\n            start_offset: The offset from which to start fetching records. The default is 0.\n            with_suggestions: Whether to include suggestions in the records. The default is True.\n            with_responses: Whether to include responses in the records. The default is True.\n            with_vectors: A list of vector names to include in the records. The default is None.\n                If a list is provided, only the specified vectors will be included.\n                If True is provided, all vectors will be included.\n\n        Returns:\n            An iterator over the records in the dataset on the server.\n\n        \"\"\"\n        if query and isinstance(query, str):\n            query = Query(query=query)\n\n        if with_vectors:\n            self._validate_vector_names(vector_names=with_vectors)\n\n        return DatasetRecordsIterator(\n            dataset=self.__dataset,\n            client=self.__client,\n            query=query,\n            batch_size=batch_size,\n            start_offset=start_offset,\n            with_suggestions=with_suggestions,\n            with_responses=with_responses,\n            with_vectors=with_vectors,\n        )\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self.__dataset})\"\n\n    ############################\n    # Public methods\n    ############################\n\n    def log(\n        self,\n        records: Union[List[dict], List[Record], HFDataset],\n        mapping: Optional[Dict[str, Union[str, Sequence[str]]]] = None,\n        user_id: Optional[UUID] = None,\n        batch_size: int = DEFAULT_BATCH_SIZE,\n    ) -&gt; \"DatasetRecords\":\n        \"\"\"Add or update records in a dataset on the server using the provided records.\n        If the record includes a known `id` field, the record will be updated.\n        If the record does not include a known `id` field, the record will be added as a new record.\n        See `rg.Record` for more information on the record definition.\n\n        Parameters:\n            records: A list of `Record` objects, a Hugging Face Dataset, or a list of dictionaries representing the records.\n                     If records are defined as a dictionaries or a dataset, the keys/ column names should correspond to the\n                     fields in the Argilla dataset's fields and questions. `id` should be provided to identify the records when updating.\n            mapping: A dictionary that maps the keys/ column names in the records to the fields or questions in the Argilla dataset.\n                     To assign an incoming key or column to multiple fields or questions, provide a list or tuple of field or question names.\n            user_id: The user id to be associated with the records' response. If not provided, the current user id is used.\n            batch_size: The number of records to send in each batch. The default is 256.\n\n        Returns:\n            A list of Record objects representing the updated records.\n        \"\"\"\n        record_models = self._ingest_records(records=records, mapping=mapping, user_id=user_id or self.__client.me.id)\n        batch_size = self._normalize_batch_size(\n            batch_size=batch_size,\n            records_length=len(record_models),\n            max_value=self._api.MAX_RECORDS_PER_UPSERT_BULK,\n        )\n\n        created_or_updated = []\n        records_updated = 0\n\n        for batch in tqdm(\n            iterable=range(0, len(records), batch_size),\n            desc=\"Sending records...\",\n            total=len(records) // batch_size,\n            unit=\"batch\",\n        ):\n            self._log_message(message=f\"Sending records from {batch} to {batch + batch_size}.\")\n            batch_records = record_models[batch : batch + batch_size]\n            models, updated = self._api.bulk_upsert(dataset_id=self.__dataset.id, records=batch_records)\n            created_or_updated.extend([Record.from_model(model=model, dataset=self.__dataset) for model in models])\n            records_updated += updated\n\n        records_created = len(created_or_updated) - records_updated\n        self._log_message(\n            message=f\"Updated {records_updated} records and added {records_created} records to dataset {self.__dataset.name}\",\n            level=\"info\",\n        )\n\n        return self\n\n    def delete(\n        self,\n        records: List[Record],\n    ) -&gt; List[Record]:\n        \"\"\"Delete records in a dataset on the server using the provided records\n            and matching based on the id.\n\n        Parameters:\n            records: A list of `Record` objects representing the records to be deleted.\n\n        Returns:\n            A list of Record objects representing the deleted records.\n\n        \"\"\"\n        mapping = None\n        user_id = self.__client.me.id\n\n        record_models = self._ingest_records(records=records, mapping=mapping, user_id=user_id)\n\n        self._api.delete_many(dataset_id=self.__dataset.id, records=record_models)\n\n        self._log_message(\n            message=f\"Deleted {len(record_models)} records from dataset {self.__dataset.name}\",\n            level=\"info\",\n        )\n\n        return record_models\n\n    def to_dict(self, flatten: bool = False, orient: str = \"names\") -&gt; Dict[str, Any]:\n        \"\"\"\n        Return the records as a dictionary. This is a convenient shortcut for dataset.records(...).to_dict().\n\n        Parameters:\n            flatten (bool): The structure of the exported dictionary.\n                - True: The record fields, metadata, suggestions and responses will be flattened.\n                - False: The record fields, metadata, suggestions and responses will be nested.\n            orient (str): The orientation of the exported dictionary.\n                - \"names\": The keys of the dictionary will be the names of the fields, metadata, suggestions and responses.\n                - \"index\": The keys of the dictionary will be the id of the records.\n        Returns:\n            A dictionary of records.\n\n        \"\"\"\n        return self().to_dict(flatten=flatten, orient=orient)\n\n    def to_list(self, flatten: bool = False) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Return the records as a list of dictionaries. This is a convenient shortcut for dataset.records(...).to_list().\n\n        Parameters:\n            flatten (bool): The structure of the exported dictionaries in the list.\n                - True: The record keys are flattened and a dot notation is used to record attributes and their attributes . For example, `label.suggestion` and `label.response`. Records responses are spread across multiple columns for values and users.\n                - False: The record fields, metadata, suggestions and responses will be nested dictionary with keys for record attributes.\n        Returns:\n            A list of dictionaries of records.\n        \"\"\"\n        data = self().to_list(flatten=flatten)\n        return data\n\n    def to_json(self, path: Union[Path, str]) -&gt; Path:\n        \"\"\"\n        Export the records to a file on disk.\n\n        Parameters:\n            path (str): The path to the file to save the records.\n\n        Returns:\n            The path to the file where the records were saved.\n\n        \"\"\"\n        return self().to_json(path=path)\n\n    def from_json(self, path: Union[Path, str]) -&gt; List[Record]:\n        \"\"\"Creates a DatasetRecords object from a disk path to a JSON file.\n            The JSON file should be defined by `DatasetRecords.to_json`.\n\n        Args:\n            path (str): The path to the file containing the records.\n\n        Returns:\n            DatasetRecords: The DatasetRecords object created from the disk path.\n\n        \"\"\"\n        records = JsonIO._records_from_json(path=path)\n        return self.log(records=records)\n\n    def to_datasets(self) -&gt; HFDataset:\n        \"\"\"\n        Export the records to a HFDataset.\n\n        Returns:\n            The dataset containing the records.\n\n        \"\"\"\n\n        return self().to_datasets()\n\n    ############################\n    # Private methods\n    ############################\n\n    def _ingest_records(\n        self,\n        records: Union[List[Dict[str, Any]], List[Record], HFDataset],\n        mapping: Optional[Dict[str, Union[str, Sequence[str]]]] = None,\n        user_id: Optional[UUID] = None,\n    ) -&gt; List[RecordModel]:\n        \"\"\"Ingests records from a list of dictionaries, a Hugging Face Dataset, or a list of Record objects.\"\"\"\n\n        if len(records) == 0:\n            raise ValueError(\"No records provided to ingest.\")\n\n        if HFDatasetsIO._is_hf_dataset(dataset=records):\n            records = HFDatasetsIO._record_dicts_from_datasets(dataset=records)\n\n        ingested_records = []\n        record_mapper = IngestedRecordMapper(mapping=mapping, dataset=self.__dataset, user_id=user_id)\n        for record in records:\n            try:\n                if isinstance(record, dict):\n                    record = record_mapper(data=record)\n                elif isinstance(record, Record):\n                    record.dataset = self.__dataset\n                else:\n                    raise ValueError(\n                        \"Records should be a a list Record instances, \"\n                        \"a Hugging Face Dataset, or a list of dictionaries representing the records.\"\n                        f\"Found a record of type {type(record)}: {record}.\"\n                    )\n            except Exception as e:\n                raise RecordsIngestionError(f\"Failed to ingest record from dict {record}: {e}\")\n            ingested_records.append(record.api_model())\n        return ingested_records\n\n    def _normalize_batch_size(self, batch_size: int, records_length, max_value: int):\n        norm_batch_size = min(batch_size, records_length, max_value)\n\n        if batch_size != norm_batch_size:\n            self._log_message(\n                message=f\"The provided batch size {batch_size} was normalized. Using value {norm_batch_size}.\",\n                level=\"warning\",\n            )\n\n        return norm_batch_size\n\n    def _validate_vector_names(self, vector_names: Union[List[str], str]) -&gt; None:\n        if not isinstance(vector_names, list):\n            vector_names = [vector_names]\n        for vector_name in vector_names:\n            if isinstance(vector_name, bool):\n                continue\n            if vector_name not in self.__dataset.schema:\n                raise ValueError(f\"Vector field {vector_name} not found in dataset schema.\")\n</code></pre>"},{"location":"reference/argilla/datasets/dataset_records/#src.argilla.records._dataset_records.DatasetRecords.__call__","title":"<code>__call__(query=None, batch_size=DEFAULT_BATCH_SIZE, start_offset=0, with_suggestions=True, with_responses=True, with_vectors=None)</code>","text":"<p>Returns an iterator over the records in the dataset on the server.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Optional[Union[str, Query]]</code> <p>A string or a Query object to filter the records.</p> <code>None</code> <code>batch_size</code> <code>Optional[int]</code> <p>The number of records to fetch in each batch. The default is 256.</p> <code>DEFAULT_BATCH_SIZE</code> <code>start_offset</code> <code>int</code> <p>The offset from which to start fetching records. The default is 0.</p> <code>0</code> <code>with_suggestions</code> <code>bool</code> <p>Whether to include suggestions in the records. The default is True.</p> <code>True</code> <code>with_responses</code> <code>bool</code> <p>Whether to include responses in the records. The default is True.</p> <code>True</code> <code>with_vectors</code> <code>Optional[Union[List, bool, str]]</code> <p>A list of vector names to include in the records. The default is None. If a list is provided, only the specified vectors will be included. If True is provided, all vectors will be included.</p> <code>None</code> <p>Returns:</p> Type Description <code>DatasetRecordsIterator</code> <p>An iterator over the records in the dataset on the server.</p> Source code in <code>src/argilla/records/_dataset_records.py</code> <pre><code>def __call__(\n    self,\n    query: Optional[Union[str, Query]] = None,\n    batch_size: Optional[int] = DEFAULT_BATCH_SIZE,\n    start_offset: int = 0,\n    with_suggestions: bool = True,\n    with_responses: bool = True,\n    with_vectors: Optional[Union[List, bool, str]] = None,\n) -&gt; DatasetRecordsIterator:\n    \"\"\"Returns an iterator over the records in the dataset on the server.\n\n    Parameters:\n        query: A string or a Query object to filter the records.\n        batch_size: The number of records to fetch in each batch. The default is 256.\n        start_offset: The offset from which to start fetching records. The default is 0.\n        with_suggestions: Whether to include suggestions in the records. The default is True.\n        with_responses: Whether to include responses in the records. The default is True.\n        with_vectors: A list of vector names to include in the records. The default is None.\n            If a list is provided, only the specified vectors will be included.\n            If True is provided, all vectors will be included.\n\n    Returns:\n        An iterator over the records in the dataset on the server.\n\n    \"\"\"\n    if query and isinstance(query, str):\n        query = Query(query=query)\n\n    if with_vectors:\n        self._validate_vector_names(vector_names=with_vectors)\n\n    return DatasetRecordsIterator(\n        dataset=self.__dataset,\n        client=self.__client,\n        query=query,\n        batch_size=batch_size,\n        start_offset=start_offset,\n        with_suggestions=with_suggestions,\n        with_responses=with_responses,\n        with_vectors=with_vectors,\n    )\n</code></pre>"},{"location":"reference/argilla/datasets/dataset_records/#src.argilla.records._dataset_records.DatasetRecords.__init__","title":"<code>__init__(client, dataset)</code>","text":"<p>Initializes a DatasetRecords object with a client and a dataset. Args:     client: An Argilla client object.     dataset: A Dataset object.</p> Source code in <code>src/argilla/records/_dataset_records.py</code> <pre><code>def __init__(self, client: \"Argilla\", dataset: \"Dataset\"):\n    \"\"\"Initializes a DatasetRecords object with a client and a dataset.\n    Args:\n        client: An Argilla client object.\n        dataset: A Dataset object.\n    \"\"\"\n    self.__client = client\n    self.__dataset = dataset\n    self._api = self.__client.api.records\n</code></pre>"},{"location":"reference/argilla/datasets/dataset_records/#src.argilla.records._dataset_records.DatasetRecords.delete","title":"<code>delete(records)</code>","text":"<p>Delete records in a dataset on the server using the provided records     and matching based on the id.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>List[Record]</code> <p>A list of <code>Record</code> objects representing the records to be deleted.</p> required <p>Returns:</p> Type Description <code>List[Record]</code> <p>A list of Record objects representing the deleted records.</p> Source code in <code>src/argilla/records/_dataset_records.py</code> <pre><code>def delete(\n    self,\n    records: List[Record],\n) -&gt; List[Record]:\n    \"\"\"Delete records in a dataset on the server using the provided records\n        and matching based on the id.\n\n    Parameters:\n        records: A list of `Record` objects representing the records to be deleted.\n\n    Returns:\n        A list of Record objects representing the deleted records.\n\n    \"\"\"\n    mapping = None\n    user_id = self.__client.me.id\n\n    record_models = self._ingest_records(records=records, mapping=mapping, user_id=user_id)\n\n    self._api.delete_many(dataset_id=self.__dataset.id, records=record_models)\n\n    self._log_message(\n        message=f\"Deleted {len(record_models)} records from dataset {self.__dataset.name}\",\n        level=\"info\",\n    )\n\n    return record_models\n</code></pre>"},{"location":"reference/argilla/datasets/dataset_records/#src.argilla.records._dataset_records.DatasetRecords.from_json","title":"<code>from_json(path)</code>","text":"<p>Creates a DatasetRecords object from a disk path to a JSON file.     The JSON file should be defined by <code>DatasetRecords.to_json</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file containing the records.</p> required <p>Returns:</p> Name Type Description <code>DatasetRecords</code> <code>List[Record]</code> <p>The DatasetRecords object created from the disk path.</p> Source code in <code>src/argilla/records/_dataset_records.py</code> <pre><code>def from_json(self, path: Union[Path, str]) -&gt; List[Record]:\n    \"\"\"Creates a DatasetRecords object from a disk path to a JSON file.\n        The JSON file should be defined by `DatasetRecords.to_json`.\n\n    Args:\n        path (str): The path to the file containing the records.\n\n    Returns:\n        DatasetRecords: The DatasetRecords object created from the disk path.\n\n    \"\"\"\n    records = JsonIO._records_from_json(path=path)\n    return self.log(records=records)\n</code></pre>"},{"location":"reference/argilla/datasets/dataset_records/#src.argilla.records._dataset_records.DatasetRecords.log","title":"<code>log(records, mapping=None, user_id=None, batch_size=DEFAULT_BATCH_SIZE)</code>","text":"<p>Add or update records in a dataset on the server using the provided records. If the record includes a known <code>id</code> field, the record will be updated. If the record does not include a known <code>id</code> field, the record will be added as a new record. See <code>rg.Record</code> for more information on the record definition.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>Union[List[dict], List[Record], HFDataset]</code> <p>A list of <code>Record</code> objects, a Hugging Face Dataset, or a list of dictionaries representing the records.      If records are defined as a dictionaries or a dataset, the keys/ column names should correspond to the      fields in the Argilla dataset's fields and questions. <code>id</code> should be provided to identify the records when updating.</p> required <code>mapping</code> <code>Optional[Dict[str, Union[str, Sequence[str]]]]</code> <p>A dictionary that maps the keys/ column names in the records to the fields or questions in the Argilla dataset.      To assign an incoming key or column to multiple fields or questions, provide a list or tuple of field or question names.</p> <code>None</code> <code>user_id</code> <code>Optional[UUID]</code> <p>The user id to be associated with the records' response. If not provided, the current user id is used.</p> <code>None</code> <code>batch_size</code> <code>int</code> <p>The number of records to send in each batch. The default is 256.</p> <code>DEFAULT_BATCH_SIZE</code> <p>Returns:</p> Type Description <code>DatasetRecords</code> <p>A list of Record objects representing the updated records.</p> Source code in <code>src/argilla/records/_dataset_records.py</code> <pre><code>def log(\n    self,\n    records: Union[List[dict], List[Record], HFDataset],\n    mapping: Optional[Dict[str, Union[str, Sequence[str]]]] = None,\n    user_id: Optional[UUID] = None,\n    batch_size: int = DEFAULT_BATCH_SIZE,\n) -&gt; \"DatasetRecords\":\n    \"\"\"Add or update records in a dataset on the server using the provided records.\n    If the record includes a known `id` field, the record will be updated.\n    If the record does not include a known `id` field, the record will be added as a new record.\n    See `rg.Record` for more information on the record definition.\n\n    Parameters:\n        records: A list of `Record` objects, a Hugging Face Dataset, or a list of dictionaries representing the records.\n                 If records are defined as a dictionaries or a dataset, the keys/ column names should correspond to the\n                 fields in the Argilla dataset's fields and questions. `id` should be provided to identify the records when updating.\n        mapping: A dictionary that maps the keys/ column names in the records to the fields or questions in the Argilla dataset.\n                 To assign an incoming key or column to multiple fields or questions, provide a list or tuple of field or question names.\n        user_id: The user id to be associated with the records' response. If not provided, the current user id is used.\n        batch_size: The number of records to send in each batch. The default is 256.\n\n    Returns:\n        A list of Record objects representing the updated records.\n    \"\"\"\n    record_models = self._ingest_records(records=records, mapping=mapping, user_id=user_id or self.__client.me.id)\n    batch_size = self._normalize_batch_size(\n        batch_size=batch_size,\n        records_length=len(record_models),\n        max_value=self._api.MAX_RECORDS_PER_UPSERT_BULK,\n    )\n\n    created_or_updated = []\n    records_updated = 0\n\n    for batch in tqdm(\n        iterable=range(0, len(records), batch_size),\n        desc=\"Sending records...\",\n        total=len(records) // batch_size,\n        unit=\"batch\",\n    ):\n        self._log_message(message=f\"Sending records from {batch} to {batch + batch_size}.\")\n        batch_records = record_models[batch : batch + batch_size]\n        models, updated = self._api.bulk_upsert(dataset_id=self.__dataset.id, records=batch_records)\n        created_or_updated.extend([Record.from_model(model=model, dataset=self.__dataset) for model in models])\n        records_updated += updated\n\n    records_created = len(created_or_updated) - records_updated\n    self._log_message(\n        message=f\"Updated {records_updated} records and added {records_created} records to dataset {self.__dataset.name}\",\n        level=\"info\",\n    )\n\n    return self\n</code></pre>"},{"location":"reference/argilla/datasets/dataset_records/#src.argilla.records._dataset_records.DatasetRecords.to_datasets","title":"<code>to_datasets()</code>","text":"<p>Export the records to a HFDataset.</p> <p>Returns:</p> Type Description <code>HFDataset</code> <p>The dataset containing the records.</p> Source code in <code>src/argilla/records/_dataset_records.py</code> <pre><code>def to_datasets(self) -&gt; HFDataset:\n    \"\"\"\n    Export the records to a HFDataset.\n\n    Returns:\n        The dataset containing the records.\n\n    \"\"\"\n\n    return self().to_datasets()\n</code></pre>"},{"location":"reference/argilla/datasets/dataset_records/#src.argilla.records._dataset_records.DatasetRecords.to_dict","title":"<code>to_dict(flatten=False, orient='names')</code>","text":"<p>Return the records as a dictionary. This is a convenient shortcut for dataset.records(...).to_dict().</p> <p>Parameters:</p> Name Type Description Default <code>flatten</code> <code>bool</code> <p>The structure of the exported dictionary. - True: The record fields, metadata, suggestions and responses will be flattened. - False: The record fields, metadata, suggestions and responses will be nested.</p> <code>False</code> <code>orient</code> <code>str</code> <p>The orientation of the exported dictionary. - \"names\": The keys of the dictionary will be the names of the fields, metadata, suggestions and responses. - \"index\": The keys of the dictionary will be the id of the records.</p> <code>'names'</code> <p>Returns:     A dictionary of records.</p> Source code in <code>src/argilla/records/_dataset_records.py</code> <pre><code>def to_dict(self, flatten: bool = False, orient: str = \"names\") -&gt; Dict[str, Any]:\n    \"\"\"\n    Return the records as a dictionary. This is a convenient shortcut for dataset.records(...).to_dict().\n\n    Parameters:\n        flatten (bool): The structure of the exported dictionary.\n            - True: The record fields, metadata, suggestions and responses will be flattened.\n            - False: The record fields, metadata, suggestions and responses will be nested.\n        orient (str): The orientation of the exported dictionary.\n            - \"names\": The keys of the dictionary will be the names of the fields, metadata, suggestions and responses.\n            - \"index\": The keys of the dictionary will be the id of the records.\n    Returns:\n        A dictionary of records.\n\n    \"\"\"\n    return self().to_dict(flatten=flatten, orient=orient)\n</code></pre>"},{"location":"reference/argilla/datasets/dataset_records/#src.argilla.records._dataset_records.DatasetRecords.to_json","title":"<code>to_json(path)</code>","text":"<p>Export the records to a file on disk.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file to save the records.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path to the file where the records were saved.</p> Source code in <code>src/argilla/records/_dataset_records.py</code> <pre><code>def to_json(self, path: Union[Path, str]) -&gt; Path:\n    \"\"\"\n    Export the records to a file on disk.\n\n    Parameters:\n        path (str): The path to the file to save the records.\n\n    Returns:\n        The path to the file where the records were saved.\n\n    \"\"\"\n    return self().to_json(path=path)\n</code></pre>"},{"location":"reference/argilla/datasets/dataset_records/#src.argilla.records._dataset_records.DatasetRecords.to_list","title":"<code>to_list(flatten=False)</code>","text":"<p>Return the records as a list of dictionaries. This is a convenient shortcut for dataset.records(...).to_list().</p> <p>Parameters:</p> Name Type Description Default <code>flatten</code> <code>bool</code> <p>The structure of the exported dictionaries in the list. - True: The record keys are flattened and a dot notation is used to record attributes and their attributes . For example, <code>label.suggestion</code> and <code>label.response</code>. Records responses are spread across multiple columns for values and users. - False: The record fields, metadata, suggestions and responses will be nested dictionary with keys for record attributes.</p> <code>False</code> <p>Returns:     A list of dictionaries of records.</p> Source code in <code>src/argilla/records/_dataset_records.py</code> <pre><code>def to_list(self, flatten: bool = False) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Return the records as a list of dictionaries. This is a convenient shortcut for dataset.records(...).to_list().\n\n    Parameters:\n        flatten (bool): The structure of the exported dictionaries in the list.\n            - True: The record keys are flattened and a dot notation is used to record attributes and their attributes . For example, `label.suggestion` and `label.response`. Records responses are spread across multiple columns for values and users.\n            - False: The record fields, metadata, suggestions and responses will be nested dictionary with keys for record attributes.\n    Returns:\n        A list of dictionaries of records.\n    \"\"\"\n    data = self().to_list(flatten=flatten)\n    return data\n</code></pre>"},{"location":"reference/argilla/datasets/datasets/","title":"<code>rg.Dataset</code>","text":"<p><code>Dataset</code> is a class that represents a collection of records. It is used to store and manage records in Argilla.</p>"},{"location":"reference/argilla/datasets/datasets/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla/datasets/datasets/#creating-a-dataset","title":"Creating a Dataset","text":"<p>To create a new dataset you need to define its name and settings. Optional parameters are <code>workspace</code> and <code>client</code>, if you want to create the dataset in a specific workspace or on a specific Argilla instance.</p> <pre><code>dataset = rg.Dataset(\n    name=\"my_dataset\",\n    settings=rg.Settings(\n        fields=[\n            rg.TextField(name=\"text\"),\n        ],\n        questions=[\n            rg.TextQuestion(name=\"response\"),\n        ],\n    ),\n)\ndataset.create()\n</code></pre> <p>For a detail guide of the dataset creation and publication process, see the Dataset how to guide.</p>"},{"location":"reference/argilla/datasets/datasets/#retrieving-an-existing-dataset","title":"Retrieving an existing Dataset","text":"<p>To retrieve an existing dataset, use <code>client.datasets(\"my_dataset\")</code> instead.</p> <pre><code>dataset = client.datasets(\"my_dataset\")\n</code></pre>"},{"location":"reference/argilla/datasets/datasets/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla/datasets/datasets/#rgdataset_1","title":"<code>rg.Dataset</code>","text":"<p>               Bases: <code>Resource</code>, <code>DiskImportExportMixin</code></p> <p>Class for interacting with Argilla Datasets</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the dataset.</p> <code>records</code> <code>DatasetRecords</code> <p>The records object for the dataset. Used to interact with the records of the dataset by iterating, searching, etc.</p> <code>settings</code> <code>Settings</code> <p>The settings object of the dataset. Used to configure the dataset with fields, questions, guidelines, etc.</p> <code>fields</code> <code>list</code> <p>The fields of the dataset, for example the <code>rg.TextField</code> of the dataset. Defined in the settings.</p> <code>questions</code> <code>list</code> <p>The questions of the dataset defined in the settings. For example, the <code>rg.TextQuestion</code> that you want labelers to answer.</p> <code>guidelines</code> <code>str</code> <p>The guidelines of the dataset defined in the settings. Used to provide instructions to labelers.</p> <code>allow_extra_metadata</code> <code>bool</code> <p>True if extra metadata is allowed, False otherwise.</p> Source code in <code>src/argilla/datasets/_resource.py</code> <pre><code>class Dataset(Resource, DiskImportExportMixin):\n    \"\"\"Class for interacting with Argilla Datasets\n\n    Attributes:\n        name: Name of the dataset.\n        records (DatasetRecords): The records object for the dataset. Used to interact with the records of the dataset by iterating, searching, etc.\n        settings (Settings): The settings object of the dataset. Used to configure the dataset with fields, questions, guidelines, etc.\n        fields (list): The fields of the dataset, for example the `rg.TextField` of the dataset. Defined in the settings.\n        questions (list): The questions of the dataset defined in the settings. For example, the `rg.TextQuestion` that you want labelers to answer.\n        guidelines (str): The guidelines of the dataset defined in the settings. Used to provide instructions to labelers.\n        allow_extra_metadata (bool): True if extra metadata is allowed, False otherwise.\n    \"\"\"\n\n    name: str\n    id: Optional[UUID]\n\n    _api: \"DatasetsAPI\"\n    _model: \"DatasetModel\"\n\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        workspace: Optional[Union[\"Workspace\", str, UUID]] = None,\n        settings: Optional[Settings] = None,\n        client: Optional[\"Argilla\"] = None,\n    ) -&gt; None:\n        \"\"\"Initializes a new Argilla Dataset object with the given parameters.\n\n        Parameters:\n            name (str): Name of the dataset. Replaced by random UUID if not assigned.\n            workspace (UUID): Workspace of the dataset. Default is the first workspace found in the server.\n            settings (Settings): Settings class to be used to configure the dataset.\n            client (Argilla): Instance of Argilla to connect with the server. Default is the default client.\n        \"\"\"\n        client = client or Argilla._get_default()\n        super().__init__(client=client, api=client.api.datasets)\n        if name is None:\n            name = f\"dataset_{uuid4()}\"\n            self._log_message(f\"Settings dataset name to unique UUID: {name}\")\n\n        self._workspace = workspace\n        self._model = DatasetModel(name=name)\n        self._settings = settings or Settings(_dataset=self)\n        self._settings.dataset = self\n        self.__records = DatasetRecords(client=self._client, dataset=self)\n\n    #####################\n    #  Properties       #\n    #####################\n\n    @property\n    def name(self) -&gt; str:\n        return self._model.name\n\n    @name.setter\n    def name(self, value: str) -&gt; None:\n        self._model.name = value\n\n    @property\n    def records(self) -&gt; \"DatasetRecords\":\n        return self.__records\n\n    @property\n    def settings(self) -&gt; Settings:\n        return self._settings\n\n    @settings.setter\n    def settings(self, value: Settings) -&gt; None:\n        value.dataset = self\n        self._settings = value\n\n    @property\n    def fields(self) -&gt; list:\n        return self.settings.fields\n\n    @property\n    def questions(self) -&gt; list:\n        return self.settings.questions\n\n    @property\n    def guidelines(self) -&gt; str:\n        return self.settings.guidelines\n\n    @guidelines.setter\n    def guidelines(self, value: str) -&gt; None:\n        self.settings.guidelines = value\n\n    @property\n    def allow_extra_metadata(self) -&gt; bool:\n        return self.settings.allow_extra_metadata\n\n    @allow_extra_metadata.setter\n    def allow_extra_metadata(self, value: bool) -&gt; None:\n        self.settings.allow_extra_metadata = value\n\n    @property\n    def schema(self) -&gt; dict:\n        return self.settings.schema\n\n    @property\n    def workspace(self) -&gt; Workspace:\n        self._workspace = self._resolve_workspace()\n        return self._workspace\n\n    #####################\n    #  Core methods     #\n    #####################\n\n    def get(self) -&gt; \"Dataset\":\n        super().get()\n        self.settings.get()\n        return self\n\n    def exists(self) -&gt; bool:\n        \"\"\"Checks if the dataset exists on the server\n\n        Returns:\n            bool: True if the dataset exists, False otherwise\n        \"\"\"\n        return self.id and self._api.exists(self.id)\n\n    def create(self) -&gt; \"Dataset\":\n        \"\"\"Creates the dataset on the server with the `Settings` configuration.\n\n        Returns:\n            Dataset: The created dataset object.\n        \"\"\"\n        super().create()\n        try:\n            return self._publish()\n        except Exception as e:\n            self._log_message(message=f\"Error creating dataset: {e}\", level=\"error\")\n            self._rollback_dataset_creation()\n            raise SettingsError from e\n\n    def update(self) -&gt; \"Dataset\":\n        \"\"\"Updates the dataset on the server with the current settings.\n\n        Returns:\n            Dataset: The updated dataset object.\n        \"\"\"\n        self.settings.update()\n        return self\n\n    @classmethod\n    def from_model(cls, model: DatasetModel, client: \"Argilla\") -&gt; \"Dataset\":\n        instance = cls(client=client, workspace=model.workspace_id, name=model.name)\n        instance._model = model\n\n        return instance\n\n    #####################\n    #  Utility methods  #\n    #####################\n\n    def api_model(self) -&gt; DatasetModel:\n        self._model.workspace_id = self.workspace.id\n        return self._model\n\n    def _publish(self) -&gt; \"Dataset\":\n        self._settings.create()\n        self._api.publish(dataset_id=self._model.id)\n\n        return self.get()\n\n    def _resolve_workspace(self) -&gt; Workspace:\n        workspace = self._workspace\n\n        if workspace is None:\n            workspace = self._client.workspaces.default\n            warnings.warn(f\"Workspace not provided. Using default workspace: {workspace.name} id: {workspace.id}\")\n        elif isinstance(workspace, str):\n            workspace = self._client.workspaces(workspace)\n            if not workspace.exists():\n                available_workspace_names = [ws.name for ws in self._client.workspaces]\n                raise NotFoundError(\n                    f\"Workspace with name { workspace} not found. Available workspaces: {available_workspace_names}\"\n                )\n        elif isinstance(workspace, UUID):\n            ws_model = self._client.api.workspaces.get(workspace)\n            workspace = Workspace.from_model(ws_model, client=self._client)\n        elif not isinstance(workspace, Workspace):\n            raise ValueError(f\"Wrong workspace value found {workspace}\")\n\n        return workspace\n\n    def _rollback_dataset_creation(self):\n        if self.exists() and not self._is_published():\n            self.delete()\n\n    def _is_published(self) -&gt; bool:\n        return self.exists() and self._model.status == \"ready\"\n</code></pre>"},{"location":"reference/argilla/datasets/datasets/#src.argilla.datasets._resource.Dataset.__init__","title":"<code>__init__(name=None, workspace=None, settings=None, client=None)</code>","text":"<p>Initializes a new Argilla Dataset object with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the dataset. Replaced by random UUID if not assigned.</p> <code>None</code> <code>workspace</code> <code>UUID</code> <p>Workspace of the dataset. Default is the first workspace found in the server.</p> <code>None</code> <code>settings</code> <code>Settings</code> <p>Settings class to be used to configure the dataset.</p> <code>None</code> <code>client</code> <code>Argilla</code> <p>Instance of Argilla to connect with the server. Default is the default client.</p> <code>None</code> Source code in <code>src/argilla/datasets/_resource.py</code> <pre><code>def __init__(\n    self,\n    name: Optional[str] = None,\n    workspace: Optional[Union[\"Workspace\", str, UUID]] = None,\n    settings: Optional[Settings] = None,\n    client: Optional[\"Argilla\"] = None,\n) -&gt; None:\n    \"\"\"Initializes a new Argilla Dataset object with the given parameters.\n\n    Parameters:\n        name (str): Name of the dataset. Replaced by random UUID if not assigned.\n        workspace (UUID): Workspace of the dataset. Default is the first workspace found in the server.\n        settings (Settings): Settings class to be used to configure the dataset.\n        client (Argilla): Instance of Argilla to connect with the server. Default is the default client.\n    \"\"\"\n    client = client or Argilla._get_default()\n    super().__init__(client=client, api=client.api.datasets)\n    if name is None:\n        name = f\"dataset_{uuid4()}\"\n        self._log_message(f\"Settings dataset name to unique UUID: {name}\")\n\n    self._workspace = workspace\n    self._model = DatasetModel(name=name)\n    self._settings = settings or Settings(_dataset=self)\n    self._settings.dataset = self\n    self.__records = DatasetRecords(client=self._client, dataset=self)\n</code></pre>"},{"location":"reference/argilla/datasets/datasets/#src.argilla.datasets._resource.Dataset.create","title":"<code>create()</code>","text":"<p>Creates the dataset on the server with the <code>Settings</code> configuration.</p> <p>Returns:</p> Name Type Description <code>Dataset</code> <code>Dataset</code> <p>The created dataset object.</p> Source code in <code>src/argilla/datasets/_resource.py</code> <pre><code>def create(self) -&gt; \"Dataset\":\n    \"\"\"Creates the dataset on the server with the `Settings` configuration.\n\n    Returns:\n        Dataset: The created dataset object.\n    \"\"\"\n    super().create()\n    try:\n        return self._publish()\n    except Exception as e:\n        self._log_message(message=f\"Error creating dataset: {e}\", level=\"error\")\n        self._rollback_dataset_creation()\n        raise SettingsError from e\n</code></pre>"},{"location":"reference/argilla/datasets/datasets/#src.argilla.datasets._resource.Dataset.exists","title":"<code>exists()</code>","text":"<p>Checks if the dataset exists on the server</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the dataset exists, False otherwise</p> Source code in <code>src/argilla/datasets/_resource.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Checks if the dataset exists on the server\n\n    Returns:\n        bool: True if the dataset exists, False otherwise\n    \"\"\"\n    return self.id and self._api.exists(self.id)\n</code></pre>"},{"location":"reference/argilla/datasets/datasets/#src.argilla.datasets._resource.Dataset.update","title":"<code>update()</code>","text":"<p>Updates the dataset on the server with the current settings.</p> <p>Returns:</p> Name Type Description <code>Dataset</code> <code>Dataset</code> <p>The updated dataset object.</p> Source code in <code>src/argilla/datasets/_resource.py</code> <pre><code>def update(self) -&gt; \"Dataset\":\n    \"\"\"Updates the dataset on the server with the current settings.\n\n    Returns:\n        Dataset: The updated dataset object.\n    \"\"\"\n    self.settings.update()\n    return self\n</code></pre>"},{"location":"reference/argilla/records/metadata/","title":"<code>metadata</code>","text":"<p>Metadata in argilla is a dictionary that can be attached to a record. It is used to store additional information about the record that is not part of the record's fields or responses. For example, the source of the record, the date it was created, or any other information that is relevant to the record. Metadata can be added to a record directly or as valules within a dictionary.</p>"},{"location":"reference/argilla/records/metadata/#usage-examples","title":"Usage Examples","text":"<p>To use metadata within a dataset, you must define a metadata property in the dataset settings. The metadata property is a list of metadata properties that can be attached to a record. The following example demonstrates how to add metadata to a dataset and how to access metadata from a record object:</p> <pre><code>import argilla as rg\n\ndataset = Dataset(\n    name=\"dataset_with_metadata\",\n    settings=Settings(\n        fields=[TextField(name=\"text\")],\n        questions=[LabelQuestion(name=\"label\", labels=[\"positive\", \"negative\"])],\n        metadata=[\n            rg.TermsMetadataProperty(name=\"category\", options=[\"A\", \"B\", \"C\"]),\n        ],\n    ),\n)\ndataset.create()\n</code></pre> <p>Then, you can add records to the dataset with metadata that corresponds to the metadata property defined in the dataset settings:</p> <pre><code>dataset_with_metadata.records.log(\n    [\n        {\"text\": \"text\", \"label\": \"positive\", \"category\": \"A\"},\n        {\"text\": \"text\", \"label\": \"negative\", \"category\": \"B\"},\n    ]\n)\n</code></pre>"},{"location":"reference/argilla/records/records/","title":"<code>rg.Record</code>","text":"<p>The <code>Record</code> object is used to represent a single record in Argilla. It contains fields, suggestions, responses, metadata, and vectors.</p>"},{"location":"reference/argilla/records/records/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla/records/records/#creating-a-record","title":"Creating a Record","text":"<p>To create records, you can use the <code>Record</code> class and pass it to the <code>Dataset.records.log</code> method. The <code>Record</code> class requires a <code>fields</code> parameter, which is a dictionary of field names and values. The field names must match the field names in the dataset's <code>Settings</code> object to be accepted.</p> <pre><code>dataset.records.log(\n    records=[\n        rg.Record(\n            fields={\"text\": \"Hello World, how are you?\"},\n        ),\n    ]\n) # (1)\n</code></pre> <ol> <li>The Argilla dataset contains a field named <code>text</code> matching the key here.</li> </ol>"},{"location":"reference/argilla/records/records/#accessing-record-attributes","title":"Accessing Record Attributes","text":"<p>The <code>Record</code> object has suggestions, responses, metadata, and vectors attributes that can be accessed directly whilst iterating over records in a dataset.</p> <pre><code>for record in dataset.records(\n    with_suggestions=True,\n    with_responses=True,\n    with_metadata=True,\n    with_vectors=True\n    ):\n    print(record.suggestions)\n    print(record.responses)\n    print(record.metadata)\n    print(record.vectors)\n</code></pre> <p>Record properties can also be updated whilst iterating over records in a dataset.</p> <pre><code>for record in dataset.records(with_metadata=True):\n    record.metadata = {\"department\": \"toys\"}\n</code></pre> <p>For changes to take effect, the user must call the <code>update</code> method on the <code>Dataset</code> object, or pass the updated records to <code>Dataset.records.log</code>. All core record atttributes can be updated in this way. Check their respective documentation for more information: Suggestions, Responses, Metadata, Vectors.</p>"},{"location":"reference/argilla/records/records/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla/records/records/#rgrecord_1","title":"<code>rg.Record</code>","text":"<p>               Bases: <code>Resource</code></p> <p>The class for interacting with Argilla Records. A <code>Record</code> is a single sample in a dataset. Records receives feedback in the form of responses and suggestions. Records contain fields, metadata, and vectors.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Union[str, UUID]</code> <p>The id of the record.</p> <code>fields</code> <code>RecordFields</code> <p>The fields of the record.</p> <code>metadata</code> <code>RecordMetadata</code> <p>The metadata of the record.</p> <code>vectors</code> <code>RecordVectors</code> <p>The vectors of the record.</p> <code>responses</code> <code>RecordResponses</code> <p>The responses of the record.</p> <code>suggestions</code> <code>RecordSuggestions</code> <p>The suggestions of the record.</p> <code>dataset</code> <code>Dataset</code> <p>The dataset to which the record belongs.</p> <code>_server_id</code> <code>UUID</code> <p>An id for the record generated by the Argilla server.</p> Source code in <code>src/argilla/records/_resource.py</code> <pre><code>class Record(Resource):\n    \"\"\"The class for interacting with Argilla Records. A `Record` is a single sample\n    in a dataset. Records receives feedback in the form of responses and suggestions.\n    Records contain fields, metadata, and vectors.\n\n    Attributes:\n        id (Union[str, UUID]): The id of the record.\n        fields (RecordFields): The fields of the record.\n        metadata (RecordMetadata): The metadata of the record.\n        vectors (RecordVectors): The vectors of the record.\n        responses (RecordResponses): The responses of the record.\n        suggestions (RecordSuggestions): The suggestions of the record.\n        dataset (Dataset): The dataset to which the record belongs.\n        _server_id (UUID): An id for the record generated by the Argilla server.\n    \"\"\"\n\n    _model: RecordModel\n\n    def __init__(\n        self,\n        id: Optional[Union[UUID, str]] = None,\n        fields: Optional[Dict[str, FieldValue]] = None,\n        metadata: Optional[Dict[str, MetadataValue]] = None,\n        vectors: Optional[Dict[str, VectorValue]] = None,\n        responses: Optional[List[Response]] = None,\n        suggestions: Optional[List[Suggestion]] = None,\n        _server_id: Optional[UUID] = None,\n        _dataset: Optional[\"Dataset\"] = None,\n    ):\n        \"\"\"Initializes a Record with fields, metadata, vectors, responses, suggestions, external_id, and id.\n        Records are typically defined as flat dictionary objects with fields, metadata, vectors, responses, and suggestions\n        and passed to Dataset.DatasetRecords.add() as a list of dictionaries.\n\n        Args:\n            id: An id for the record. If not provided, a UUID will be generated.\n            fields: A dictionary of fields for the record.\n            metadata: A dictionary of metadata for the record.\n            vectors: A dictionary of vectors for the record.\n            responses: A list of Response objects for the record.\n            suggestions: A list of Suggestion objects for the record.\n            _server_id: An id for the record. (Read-only and set by the server)\n            _dataset: The dataset object to which the record belongs.\n        \"\"\"\n        if fields is None and metadata is None and vectors is None and responses is None and suggestions is None:\n            raise ValueError(\"At least one of fields, metadata, vectors, responses, or suggestions must be provided.\")\n        if fields is None and id is None:\n            raise ValueError(\"If fields are not provided, an id must be provided.\")\n        if fields == {} and id is None:\n            raise ValueError(\"If fields are an empty dictionary, an id must be provided.\")\n        self._dataset = _dataset\n\n        self._model = RecordModel(\n            fields=fields,\n            external_id=id or uuid4(),\n            id=_server_id,\n        )\n        # TODO: All this code blocks could be define as property setters\n        # Initialize the fields\n        self.__fields = RecordFields(fields=self._model.fields)\n        # Initialize the vectors\n        self.__vectors = RecordVectors(vectors=vectors)\n        # Initialize the metadata\n        self.__metadata = RecordMetadata(metadata=metadata)\n        self.__responses = RecordResponses(responses=responses, record=self)\n        self.__suggestions = RecordSuggestions(suggestions=suggestions, record=self)\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"Record(id={self.id},fields={self.fields},metadata={self.metadata},\"\n            f\"suggestions={self.suggestions},responses={self.responses})\"\n        )\n\n    ############################\n    # Properties\n    ############################\n\n    @property\n    def id(self) -&gt; str:\n        return self._model.external_id\n\n    @id.setter\n    def id(self, value: str) -&gt; None:\n        self._model.external_id = value\n\n    @property\n    def dataset(self) -&gt; \"Dataset\":\n        return self._dataset\n\n    @dataset.setter\n    def dataset(self, value: \"Dataset\") -&gt; None:\n        self._dataset = value\n\n    @property\n    def fields(self) -&gt; \"RecordFields\":\n        return self.__fields\n\n    @property\n    def responses(self) -&gt; \"RecordResponses\":\n        return self.__responses\n\n    @property\n    def suggestions(self) -&gt; \"RecordSuggestions\":\n        return self.__suggestions\n\n    @property\n    def metadata(self) -&gt; \"RecordMetadata\":\n        return self.__metadata\n\n    @property\n    def vectors(self) -&gt; \"RecordVectors\":\n        return self.__vectors\n\n    @property\n    def _server_id(self) -&gt; Optional[UUID]:\n        return self._model.id\n\n    ############################\n    # Public methods\n    ############################\n\n    def api_model(self) -&gt; RecordModel:\n        return RecordModel(\n            id=self._model.id,\n            external_id=self._model.external_id,\n            fields=self.fields.to_dict(),\n            metadata=self.metadata.api_models(),\n            vectors=self.vectors.api_models(),\n            responses=self.responses.api_models(),\n            suggestions=self.suggestions.api_models(),\n        )\n\n    def serialize(self) -&gt; Dict[str, Any]:\n        \"\"\"Serializes the Record to a dictionary for interaction with the API\"\"\"\n        serialized_model = self._model.model_dump()\n        serialized_suggestions = [suggestion.serialize() for suggestion in self.__suggestions]\n        serialized_responses = [response.serialize() for response in self.__responses]\n        serialized_model[\"responses\"] = serialized_responses\n        serialized_model[\"suggestions\"] = serialized_suggestions\n        return serialized_model\n\n    def to_dict(self) -&gt; Dict[str, Dict]:\n        \"\"\"Converts a Record object to a dictionary for export.\n        Returns:\n            A dictionary representing the record where the keys are \"fields\",\n            \"metadata\", \"suggestions\", and \"responses\". Each field and question is\n            represented as a key-value pair in the dictionary of the respective key. i.e.\n            `{\"fields\": {\"prompt\": \"...\", \"response\": \"...\"}, \"responses\": {\"rating\": \"...\"},\n        \"\"\"\n        id = str(self.id) if self.id else None\n        server_id = str(self._model.id) if self._model.id else None\n        fields = self.fields.to_dict()\n        metadata = self.metadata.to_dict()\n        suggestions = self.suggestions.to_dict()\n        responses = self.responses.to_dict()\n        vectors = self.vectors.to_dict()\n\n        return {\n            \"id\": id,\n            \"fields\": fields,\n            \"metadata\": metadata,\n            \"suggestions\": suggestions,\n            \"responses\": responses,\n            \"vectors\": vectors,\n            \"_server_id\": server_id,\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Dict], dataset: Optional[\"Dataset\"] = None) -&gt; \"Record\":\n        \"\"\"Converts a dictionary to a Record object.\n        Args:\n            data: A dictionary representing the record.\n            dataset: The dataset object to which the record belongs.\n        Returns:\n            A Record object.\n        \"\"\"\n        fields = data.get(\"fields\", {})\n        metadata = data.get(\"metadata\", {})\n        suggestions = data.get(\"suggestions\", {})\n        responses = data.get(\"responses\", {})\n        vectors = data.get(\"vectors\", {})\n        record_id = data.get(\"id\", None)\n        _server_id = data.get(\"_server_id\", None)\n\n        suggestions = [Suggestion(question_name=question_name, **value) for question_name, value in suggestions.items()]\n        responses = [\n            Response(question_name=question_name, **value)\n            for question_name, _responses in responses.items()\n            for value in _responses\n        ]\n\n        return cls(\n            id=record_id,\n            fields=fields,\n            suggestions=suggestions,\n            responses=responses,\n            vectors=vectors,\n            metadata=metadata,\n            _dataset=dataset,\n            _server_id=_server_id,\n        )\n\n    @classmethod\n    def from_model(cls, model: RecordModel, dataset: \"Dataset\") -&gt; \"Record\":\n        \"\"\"Converts a RecordModel object to a Record object.\n        Args:\n            model: A RecordModel object.\n            dataset: The dataset object to which the record belongs.\n        Returns:\n            A Record object.\n        \"\"\"\n        return cls(\n            id=model.external_id,\n            fields=model.fields,\n            metadata={meta.name: meta.value for meta in model.metadata},\n            vectors={vector.name: vector.vector_values for vector in model.vectors},\n            # Responses and their models are not aligned 1-1.\n            responses=[\n                response\n                for response_model in model.responses\n                for response in UserResponse.from_model(response_model, dataset=dataset)\n            ],\n            suggestions=[Suggestion.from_model(model=suggestion, dataset=dataset) for suggestion in model.suggestions],\n            _dataset=dataset,\n            _server_id=model.id,\n        )\n</code></pre>"},{"location":"reference/argilla/records/records/#src.argilla.records._resource.Record.__init__","title":"<code>__init__(id=None, fields=None, metadata=None, vectors=None, responses=None, suggestions=None, _server_id=None, _dataset=None)</code>","text":"<p>Initializes a Record with fields, metadata, vectors, responses, suggestions, external_id, and id. Records are typically defined as flat dictionary objects with fields, metadata, vectors, responses, and suggestions and passed to Dataset.DatasetRecords.add() as a list of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>Optional[Union[UUID, str]]</code> <p>An id for the record. If not provided, a UUID will be generated.</p> <code>None</code> <code>fields</code> <code>Optional[Dict[str, FieldValue]]</code> <p>A dictionary of fields for the record.</p> <code>None</code> <code>metadata</code> <code>Optional[Dict[str, MetadataValue]]</code> <p>A dictionary of metadata for the record.</p> <code>None</code> <code>vectors</code> <code>Optional[Dict[str, VectorValue]]</code> <p>A dictionary of vectors for the record.</p> <code>None</code> <code>responses</code> <code>Optional[List[Response]]</code> <p>A list of Response objects for the record.</p> <code>None</code> <code>suggestions</code> <code>Optional[List[Suggestion]]</code> <p>A list of Suggestion objects for the record.</p> <code>None</code> <code>_server_id</code> <code>Optional[UUID]</code> <p>An id for the record. (Read-only and set by the server)</p> <code>None</code> <code>_dataset</code> <code>Optional[Dataset]</code> <p>The dataset object to which the record belongs.</p> <code>None</code> Source code in <code>src/argilla/records/_resource.py</code> <pre><code>def __init__(\n    self,\n    id: Optional[Union[UUID, str]] = None,\n    fields: Optional[Dict[str, FieldValue]] = None,\n    metadata: Optional[Dict[str, MetadataValue]] = None,\n    vectors: Optional[Dict[str, VectorValue]] = None,\n    responses: Optional[List[Response]] = None,\n    suggestions: Optional[List[Suggestion]] = None,\n    _server_id: Optional[UUID] = None,\n    _dataset: Optional[\"Dataset\"] = None,\n):\n    \"\"\"Initializes a Record with fields, metadata, vectors, responses, suggestions, external_id, and id.\n    Records are typically defined as flat dictionary objects with fields, metadata, vectors, responses, and suggestions\n    and passed to Dataset.DatasetRecords.add() as a list of dictionaries.\n\n    Args:\n        id: An id for the record. If not provided, a UUID will be generated.\n        fields: A dictionary of fields for the record.\n        metadata: A dictionary of metadata for the record.\n        vectors: A dictionary of vectors for the record.\n        responses: A list of Response objects for the record.\n        suggestions: A list of Suggestion objects for the record.\n        _server_id: An id for the record. (Read-only and set by the server)\n        _dataset: The dataset object to which the record belongs.\n    \"\"\"\n    if fields is None and metadata is None and vectors is None and responses is None and suggestions is None:\n        raise ValueError(\"At least one of fields, metadata, vectors, responses, or suggestions must be provided.\")\n    if fields is None and id is None:\n        raise ValueError(\"If fields are not provided, an id must be provided.\")\n    if fields == {} and id is None:\n        raise ValueError(\"If fields are an empty dictionary, an id must be provided.\")\n    self._dataset = _dataset\n\n    self._model = RecordModel(\n        fields=fields,\n        external_id=id or uuid4(),\n        id=_server_id,\n    )\n    # TODO: All this code blocks could be define as property setters\n    # Initialize the fields\n    self.__fields = RecordFields(fields=self._model.fields)\n    # Initialize the vectors\n    self.__vectors = RecordVectors(vectors=vectors)\n    # Initialize the metadata\n    self.__metadata = RecordMetadata(metadata=metadata)\n    self.__responses = RecordResponses(responses=responses, record=self)\n    self.__suggestions = RecordSuggestions(suggestions=suggestions, record=self)\n</code></pre>"},{"location":"reference/argilla/records/records/#src.argilla.records._resource.Record.from_dict","title":"<code>from_dict(data, dataset=None)</code>  <code>classmethod</code>","text":"<p>Converts a dictionary to a Record object. Args:     data: A dictionary representing the record.     dataset: The dataset object to which the record belongs. Returns:     A Record object.</p> Source code in <code>src/argilla/records/_resource.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Dict], dataset: Optional[\"Dataset\"] = None) -&gt; \"Record\":\n    \"\"\"Converts a dictionary to a Record object.\n    Args:\n        data: A dictionary representing the record.\n        dataset: The dataset object to which the record belongs.\n    Returns:\n        A Record object.\n    \"\"\"\n    fields = data.get(\"fields\", {})\n    metadata = data.get(\"metadata\", {})\n    suggestions = data.get(\"suggestions\", {})\n    responses = data.get(\"responses\", {})\n    vectors = data.get(\"vectors\", {})\n    record_id = data.get(\"id\", None)\n    _server_id = data.get(\"_server_id\", None)\n\n    suggestions = [Suggestion(question_name=question_name, **value) for question_name, value in suggestions.items()]\n    responses = [\n        Response(question_name=question_name, **value)\n        for question_name, _responses in responses.items()\n        for value in _responses\n    ]\n\n    return cls(\n        id=record_id,\n        fields=fields,\n        suggestions=suggestions,\n        responses=responses,\n        vectors=vectors,\n        metadata=metadata,\n        _dataset=dataset,\n        _server_id=_server_id,\n    )\n</code></pre>"},{"location":"reference/argilla/records/records/#src.argilla.records._resource.Record.from_model","title":"<code>from_model(model, dataset)</code>  <code>classmethod</code>","text":"<p>Converts a RecordModel object to a Record object. Args:     model: A RecordModel object.     dataset: The dataset object to which the record belongs. Returns:     A Record object.</p> Source code in <code>src/argilla/records/_resource.py</code> <pre><code>@classmethod\ndef from_model(cls, model: RecordModel, dataset: \"Dataset\") -&gt; \"Record\":\n    \"\"\"Converts a RecordModel object to a Record object.\n    Args:\n        model: A RecordModel object.\n        dataset: The dataset object to which the record belongs.\n    Returns:\n        A Record object.\n    \"\"\"\n    return cls(\n        id=model.external_id,\n        fields=model.fields,\n        metadata={meta.name: meta.value for meta in model.metadata},\n        vectors={vector.name: vector.vector_values for vector in model.vectors},\n        # Responses and their models are not aligned 1-1.\n        responses=[\n            response\n            for response_model in model.responses\n            for response in UserResponse.from_model(response_model, dataset=dataset)\n        ],\n        suggestions=[Suggestion.from_model(model=suggestion, dataset=dataset) for suggestion in model.suggestions],\n        _dataset=dataset,\n        _server_id=model.id,\n    )\n</code></pre>"},{"location":"reference/argilla/records/records/#src.argilla.records._resource.Record.serialize","title":"<code>serialize()</code>","text":"<p>Serializes the Record to a dictionary for interaction with the API</p> Source code in <code>src/argilla/records/_resource.py</code> <pre><code>def serialize(self) -&gt; Dict[str, Any]:\n    \"\"\"Serializes the Record to a dictionary for interaction with the API\"\"\"\n    serialized_model = self._model.model_dump()\n    serialized_suggestions = [suggestion.serialize() for suggestion in self.__suggestions]\n    serialized_responses = [response.serialize() for response in self.__responses]\n    serialized_model[\"responses\"] = serialized_responses\n    serialized_model[\"suggestions\"] = serialized_suggestions\n    return serialized_model\n</code></pre>"},{"location":"reference/argilla/records/records/#src.argilla.records._resource.Record.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts a Record object to a dictionary for export. Returns:     A dictionary representing the record where the keys are \"fields\",     \"metadata\", \"suggestions\", and \"responses\". Each field and question is     represented as a key-value pair in the dictionary of the respective key. i.e.     `{\"fields\": {\"prompt\": \"...\", \"response\": \"...\"}, \"responses\": {\"rating\": \"...\"},</p> Source code in <code>src/argilla/records/_resource.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Dict]:\n    \"\"\"Converts a Record object to a dictionary for export.\n    Returns:\n        A dictionary representing the record where the keys are \"fields\",\n        \"metadata\", \"suggestions\", and \"responses\". Each field and question is\n        represented as a key-value pair in the dictionary of the respective key. i.e.\n        `{\"fields\": {\"prompt\": \"...\", \"response\": \"...\"}, \"responses\": {\"rating\": \"...\"},\n    \"\"\"\n    id = str(self.id) if self.id else None\n    server_id = str(self._model.id) if self._model.id else None\n    fields = self.fields.to_dict()\n    metadata = self.metadata.to_dict()\n    suggestions = self.suggestions.to_dict()\n    responses = self.responses.to_dict()\n    vectors = self.vectors.to_dict()\n\n    return {\n        \"id\": id,\n        \"fields\": fields,\n        \"metadata\": metadata,\n        \"suggestions\": suggestions,\n        \"responses\": responses,\n        \"vectors\": vectors,\n        \"_server_id\": server_id,\n    }\n</code></pre>"},{"location":"reference/argilla/records/responses/","title":"<code>rg.Response</code>","text":"<p>Class for interacting with Argilla Responses of records. Responses are answers to questions by a user. Therefore, a recod question can have multiple responses, one for each user that has answered the question. A <code>Response</code> is typically created by a user in the UI or consumed from a data source as a label, unlike a <code>Suggestion</code> which is typically created by a model prediction.</p>"},{"location":"reference/argilla/records/responses/#usage-examples","title":"Usage Examples","text":"<p>Responses can be added to an instantiated <code>Record</code> directly or as a dictionary a dictionary. The following examples demonstrate how to add responses to a record object and how to access responses from a record object:</p> <p>Instantiate the <code>Record</code> and related <code>Response</code> objects:</p> <pre><code>dataset.records.log(\n    [\n        rg.Record(\n            fields={\"text\": \"Hello World, how are you?\"},\n            responses=[rg.Response(\"label\", \"negative\", user_id=user.id)],\n            external_id=str(uuid.uuid4()),\n        )\n    ]\n)\n</code></pre> <p>Or, add a response from a dictionary where key is the question name and value is the response:</p> <pre><code>dataset.records.log(\n    [\n        {\n            \"text\": \"Hello World, how are you?\",\n            \"label.response\": \"negative\",\n        },\n    ]\n)\n</code></pre> <p>Responses can be accessed from a <code>Record</code> via their question name as an attribute of the record. So if a question is named <code>label</code>, the response can be accessed as <code>record.label</code>. The following example demonstrates how to access responses from a record object:</p> <p><pre><code># iterate over the records and responses\n\nfor record in dataset.records:\n    for response in record.responses[\"label\"]: # (1)\n        print(response.value)\n        print(response.user_id)\n\n# validate that the record has a response\n\nfor record in dataset.records:\n    if record.responses[\"label\"]:\n        for response in record.responses[\"label\"]:\n            print(response.value)\n            print(response.user_id)\n    else:\n        record.responses.add(\n            rg.Response(\"label\", \"positive\", user_id=user.id)\n        ) # (2)\n</code></pre>     1. Access the responses for the question named <code>label</code> for each record like a dictionary containing a list of <code>Response</code> objects.     2. Add a response to the record if it does not already have one.</p>"},{"location":"reference/argilla/records/responses/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla/records/responses/#rgresponse_1","title":"<code>rg.Response</code>","text":"<p>Class for interacting with Argilla Responses of records. Responses are answers to questions by a user. Therefore, a record question can have multiple responses, one for each user that has answered the question. A <code>Response</code> is typically created by a user in the UI or consumed from a data source as a label, unlike a <code>Suggestion</code> which is typically created by a model prediction.</p> Source code in <code>src/argilla/responses.py</code> <pre><code>class Response:\n    \"\"\"Class for interacting with Argilla Responses of records. Responses are answers to questions by a user.\n    Therefore, a record question can have multiple responses, one for each user that has answered the question.\n    A `Response` is typically created by a user in the UI or consumed from a data source as a label,\n    unlike a `Suggestion` which is typically created by a model prediction.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        question_name: str,\n        value: Any,\n        user_id: UUID,\n        status: Optional[Union[ResponseStatus, str]] = None,\n        _record: Optional[\"Record\"] = None,\n    ) -&gt; None:\n        \"\"\"Initializes a `Response` for a `Record` with a user_id and value\"\"\"\n\n        if question_name is None:\n            raise ValueError(\"question_name is required\")\n        if value is None:\n            raise ValueError(\"value is required\")\n        if user_id is None:\n            raise ValueError(\"user_id is required\")\n\n        if isinstance(status, str):\n            status = ResponseStatus(status)\n\n        self.record = _record\n        self.question_name = question_name\n        self.value = value\n        self.user_id = user_id\n        self.status = status\n\n    def serialize(self) -&gt; dict[str, Any]:\n        \"\"\"Serializes the Response to a dictionary. This is principally used for sending the response to the API, \\\n            but can be used for data wrangling or manual export.\n\n        Returns:\n            dict[str, Any]: The serialized response as a dictionary with keys `question_name`, `value`, and `user_id`.\n\n        Examples:\n\n        ```python\n        response = rg.Response(\"label\", \"negative\", user_id=user.id)\n        response.serialize()\n        ```\n        \"\"\"\n        return {\n            \"question_name\": self.question_name,\n            \"value\": self.value,\n            \"user_id\": self.user_id,\n            \"status\": self.status,\n        }\n</code></pre>"},{"location":"reference/argilla/records/responses/#src.argilla.responses.Response.__init__","title":"<code>__init__(question_name, value, user_id, status=None, _record=None)</code>","text":"<p>Initializes a <code>Response</code> for a <code>Record</code> with a user_id and value</p> Source code in <code>src/argilla/responses.py</code> <pre><code>def __init__(\n    self,\n    question_name: str,\n    value: Any,\n    user_id: UUID,\n    status: Optional[Union[ResponseStatus, str]] = None,\n    _record: Optional[\"Record\"] = None,\n) -&gt; None:\n    \"\"\"Initializes a `Response` for a `Record` with a user_id and value\"\"\"\n\n    if question_name is None:\n        raise ValueError(\"question_name is required\")\n    if value is None:\n        raise ValueError(\"value is required\")\n    if user_id is None:\n        raise ValueError(\"user_id is required\")\n\n    if isinstance(status, str):\n        status = ResponseStatus(status)\n\n    self.record = _record\n    self.question_name = question_name\n    self.value = value\n    self.user_id = user_id\n    self.status = status\n</code></pre>"},{"location":"reference/argilla/records/responses/#src.argilla.responses.Response.serialize","title":"<code>serialize()</code>","text":"<p>Serializes the Response to a dictionary. This is principally used for sending the response to the API,             but can be used for data wrangling or manual export.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The serialized response as a dictionary with keys <code>question_name</code>, <code>value</code>, and <code>user_id</code>.</p> <p>Examples:</p> <pre><code>response = rg.Response(\"label\", \"negative\", user_id=user.id)\nresponse.serialize()\n</code></pre> Source code in <code>src/argilla/responses.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n    \"\"\"Serializes the Response to a dictionary. This is principally used for sending the response to the API, \\\n        but can be used for data wrangling or manual export.\n\n    Returns:\n        dict[str, Any]: The serialized response as a dictionary with keys `question_name`, `value`, and `user_id`.\n\n    Examples:\n\n    ```python\n    response = rg.Response(\"label\", \"negative\", user_id=user.id)\n    response.serialize()\n    ```\n    \"\"\"\n    return {\n        \"question_name\": self.question_name,\n        \"value\": self.value,\n        \"user_id\": self.user_id,\n        \"status\": self.status,\n    }\n</code></pre>"},{"location":"reference/argilla/records/suggestions/","title":"<code>rg.Suggestion</code>","text":"<p>Class for interacting with Argilla Suggestions of records. Suggestions are typically created by a model prediction, unlike a <code>Response</code> which is typically created by a user in the UI or consumed from a data source as a label.</p>"},{"location":"reference/argilla/records/suggestions/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla/records/suggestions/#adding-records-with-suggestions","title":"Adding records with suggestions","text":"<p>Suggestions can be added to a record directly or via a dictionary structure. The following examples demonstrate how to add suggestions to a record object and how to access suggestions from a record object:</p> <p>Add a response from a dictionary where key is the question name and value is the response:</p> <pre><code>dataset.records.log(\n    [\n        {\n            \"text\": \"Hello World, how are you?\",\n            \"label\": \"negative\", # this will be used as a suggestion\n        },\n    ]\n)\n</code></pre> <p>If your data contains scores for suggestions you can add them as well via the <code>mapping</code> parameter. The following example demonstrates how to add a suggestion with a score to a record object:</p> <pre><code>dataset.records.log(\n    [\n        {\n            \"prompt\": \"Hello World, how are you?\",\n            \"label\": \"negative\",  # this will be used as a suggestion\n            \"score\": 0.9,  # this will be used as the suggestion score\n            \"model\": \"model_name\",  # this will be used as the suggestion agent\n        },\n    ],\n    mapping={\n        \"score\": \"label.suggestion.score\",\n        \"model\": \"label.suggestion.agent\",\n    },  # `label` is the question name in the dataset settings\n)\n</code></pre> <p>Or, instantiate the <code>Record</code> and related <code>Suggestions</code> objects directly, like this:</p> <pre><code>dataset.records.log(\n    [\n        rg.Record(\n            fields={\"text\": \"Hello World, how are you?\"},\n            suggestions=[rg.Suggestion(\"negative\", \"label\", score=0.9, agent=\"model_name\")],\n        )\n    ]\n)\n</code></pre>"},{"location":"reference/argilla/records/suggestions/#iterating-over-records-with-suggestions","title":"Iterating over records with suggestions","text":"<p>Just like responses, suggestions can be accessed from a <code>Record</code> via their question name as an attribute of the record. So if a question is named <code>label</code>, the suggestion can be accessed as <code>record.label</code>. The following example demonstrates how to access suggestions from a record object:</p> <pre><code>for record in dataset.records(with_suggestions=True):\n    print(record.suggestions[\"label\"].value)\n</code></pre> <p>We can also add suggestions to records as we iterate over them using the <code>add</code> method:</p> <pre><code>for record in dataset.records(with_suggestions=True):\n    if not record.suggestions[\"label\"]: # (1)\n        record.suggestions.add(\n            rg.Suggestion(\"positive\", \"label\", score=0.9, agent=\"model_name\")\n        ) # (2)\n</code></pre> <ol> <li>Validate that the record has a suggestion</li> <li>Add a suggestion to the record if it does not already have one</li> </ol>"},{"location":"reference/argilla/records/suggestions/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla/records/suggestions/#rgsuggestion_1","title":"<code>rg.Suggestion</code>","text":"<p>               Bases: <code>Resource</code></p> <p>Class for interacting with Argilla Suggestions. Suggestions are typically model predictions for records. Suggestions are rendered in the user interfaces as 'hints' or 'suggestions' for the user to review and accept or reject.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>str</code> <p>The value of the suggestion.add()</p> <code>question_name</code> <code>str</code> <p>The name of the question that the suggestion is for.</p> <code>type</code> <code>str</code> <p>The type of suggestion, either 'model' or 'human'.</p> <code>score</code> <code>float</code> <p>The score of the suggestion. For example, the probability of the model prediction.</p> <code>agent</code> <code>str</code> <p>The agent that created the suggestion. For example, the model name.</p> <code>question_id</code> <code>UUID</code> <p>The ID of the question that the suggestion is for.</p> Source code in <code>src/argilla/suggestions.py</code> <pre><code>class Suggestion(Resource):\n    \"\"\"Class for interacting with Argilla Suggestions. Suggestions are typically model predictions for records.\n    Suggestions are rendered in the user interfaces as 'hints' or 'suggestions' for the user to review and accept or reject.\n\n    Attributes:\n        value (str): The value of the suggestion.add()\n        question_name (str): The name of the question that the suggestion is for.\n        type (str): The type of suggestion, either 'model' or 'human'.\n        score (float): The score of the suggestion. For example, the probability of the model prediction.\n        agent (str): The agent that created the suggestion. For example, the model name.\n        question_id (UUID): The ID of the question that the suggestion is for.\n\n    \"\"\"\n\n    _model: SuggestionModel\n\n    def __init__(\n        self,\n        question_name: str,\n        value: Any,\n        score: Union[float, List[float], None] = None,\n        agent: Optional[str] = None,\n        type: Optional[Literal[\"model\", \"human\"]] = None,\n        id: Optional[UUID] = None,\n        question_id: Optional[UUID] = None,\n        _record: Optional[\"Record\"] = None,\n    ) -&gt; None:\n        super().__init__()\n\n        if question_name is None:\n            raise ValueError(\"question_name is required\")\n        if value is None:\n            raise ValueError(\"value is required\")\n\n        self.record = _record\n        self._model = SuggestionModel(\n            id=id,\n            question_name=question_name,\n            question_id=question_id,\n            value=value,\n            type=type,\n            score=score,\n            agent=agent,\n        )\n\n    ##############################\n    # Properties\n    ##############################\n\n    @property\n    def value(self) -&gt; Any:\n        \"\"\"The value of the suggestion.\"\"\"\n        return self._model.value\n\n    @property\n    def question_name(self) -&gt; Optional[str]:\n        \"\"\"The name of the question that the suggestion is for.\"\"\"\n        return self._model.question_name\n\n    @question_name.setter\n    def question_name(self, value: str) -&gt; None:\n        self._model.question_name = value\n\n    @property\n    def question_id(self) -&gt; Optional[UUID]:\n        \"\"\"The ID of the question that the suggestion is for.\"\"\"\n        return self._model.question_id\n\n    @question_id.setter\n    def question_id(self, value: UUID) -&gt; None:\n        self._model.question_id = value\n\n    @property\n    def type(self) -&gt; Optional[Literal[\"model\", \"human\"]]:\n        \"\"\"The type of suggestion, either 'model' or 'human'.\"\"\"\n        return self._model.type\n\n    @property\n    def score(self) -&gt; Optional[Union[float, List[float]]]:\n        \"\"\"The score of the suggestion.\"\"\"\n        return self._model.score\n\n    @score.setter\n    def score(self, value: float) -&gt; None:\n        self._model.score = value\n\n    @property\n    def agent(self) -&gt; Optional[str]:\n        \"\"\"The agent that created the suggestion.\"\"\"\n        return self._model.agent\n\n    @agent.setter\n    def agent(self, value: str) -&gt; None:\n        self._model.agent = value\n\n    @classmethod\n    def from_model(cls, model: SuggestionModel, dataset: \"Dataset\") -&gt; \"Suggestion\":\n        question = dataset.settings.question_by_id(model.question_id)\n        model.question_name = question.name\n        model.value = cls.__from_model_value(model.value, question)\n\n        return cls(**model.model_dump())\n\n    def api_model(self) -&gt; SuggestionModel:\n        if self.record is None or self.record.dataset is None:\n            return self._model\n\n        question = self.record.dataset.settings.question_by_name(self.question_name)\n        return SuggestionModel(\n            value=self.__to_model_value(self.value, question),\n            question_name=self.question_name,\n            question_id=self.question_id or question.id,\n            type=self._model.type,\n            score=self._model.score,\n            agent=self._model.agent,\n            id=self._model.id,\n        )\n\n    @classmethod\n    def __to_model_value(cls, value: Any, question: \"QuestionType\") -&gt; Any:\n        if isinstance(question, RankingQuestion):\n            return cls.__ranking_to_model_value(value)\n        return value\n\n    @classmethod\n    def __from_model_value(cls, value: Any, question: \"QuestionType\") -&gt; Any:\n        if isinstance(question, RankingQuestion):\n            return cls.__ranking_from_model_value(value)\n        return value\n\n    @classmethod\n    def __ranking_from_model_value(cls, value: List[Dict[str, Any]]) -&gt; List[str]:\n        return [v[\"value\"] for v in value]\n\n    @classmethod\n    def __ranking_to_model_value(cls, value: List[str]) -&gt; List[Dict[str, str]]:\n        return [{\"value\": str(v)} for v in value]\n</code></pre>"},{"location":"reference/argilla/records/suggestions/#src.argilla.suggestions.Suggestion.agent","title":"<code>agent: Optional[str]</code>  <code>property</code> <code>writable</code>","text":"<p>The agent that created the suggestion.</p>"},{"location":"reference/argilla/records/suggestions/#src.argilla.suggestions.Suggestion.question_id","title":"<code>question_id: Optional[UUID]</code>  <code>property</code> <code>writable</code>","text":"<p>The ID of the question that the suggestion is for.</p>"},{"location":"reference/argilla/records/suggestions/#src.argilla.suggestions.Suggestion.question_name","title":"<code>question_name: Optional[str]</code>  <code>property</code> <code>writable</code>","text":"<p>The name of the question that the suggestion is for.</p>"},{"location":"reference/argilla/records/suggestions/#src.argilla.suggestions.Suggestion.score","title":"<code>score: Optional[Union[float, List[float]]]</code>  <code>property</code> <code>writable</code>","text":"<p>The score of the suggestion.</p>"},{"location":"reference/argilla/records/suggestions/#src.argilla.suggestions.Suggestion.type","title":"<code>type: Optional[Literal['model', 'human']]</code>  <code>property</code>","text":"<p>The type of suggestion, either 'model' or 'human'.</p>"},{"location":"reference/argilla/records/suggestions/#src.argilla.suggestions.Suggestion.value","title":"<code>value: Any</code>  <code>property</code>","text":"<p>The value of the suggestion.</p>"},{"location":"reference/argilla/records/vectors/","title":"<code>rg.Vector</code>","text":"<p>A vector is a numerical representation of a <code>Record</code> field or attribute, usually the record's text. Vectors can be used to search for similar records via the UI or SDK. Vectors can be added to a record directly or as a dictionary with a key that the matches <code>rg.VectorField</code> name.</p>"},{"location":"reference/argilla/records/vectors/#usage-examples","title":"Usage Examples","text":"<p>To use vectors within a dataset, you must define a vector field in the dataset settings. The vector field is a list of vector fields that can be attached to a record. The following example demonstrates how to add vectors to a dataset and how to access vectors from a record object:</p> <pre><code>import argilla as rg\n\ndataset = Dataset(\n    name=\"dataset_with_metadata\",\n    settings=Settings(\n        fields=[TextField(name=\"text\")],\n        questions=[LabelQuestion(name=\"label\", labels=[\"positive\", \"negative\"])],\n        vectors=[\n            VectorField(name=\"vector_name\"),\n        ],\n    ),\n)\ndataset.create()\n</code></pre> <p>Then, you can add records to the dataset with vectors that correspond to the vector field defined in the dataset settings:</p> <pre><code>dataset.records.log(\n    [\n        {\n            \"text\": \"Hello World, how are you?\",\n            \"vector_name\": [0.1, 0.2, 0.3]\n        }\n    ]\n)\n</code></pre> <p>Vectors can be passed using a mapping, where the key is the key in the data source and the value is the name in the dataset's setting's <code>rg.VectorField</code> object. For example, the following code adds a record with a vector using a mapping:</p> <pre><code>dataset.records.log(\n    [\n        {\n            \"text\": \"Hello World, how are you?\",\n            \"x\": [0.1, 0.2, 0.3]\n        }\n    ],\n    mapping={\"x\": \"vector_name\"}\n)\n</code></pre> <p>Or, vectors can be instantiated and added to a record directly, like this:</p> <pre><code>dataset.records.log(\n    [\n        rg.Record(\n            fields={\"text\": \"Hello World, how are you?\"},\n            vectors=[rg.Vector(\"embedding\", [0.1, 0.2, 0.3])],\n        )\n    ]\n)\n</code></pre>"},{"location":"reference/argilla/records/vectors/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla/records/vectors/#rgvector_1","title":"<code>rg.Vector</code>","text":"<p>               Bases: <code>Resource</code></p> <p>Class for interacting with Argilla Vectors. Vectors are typically used to represent         embeddings or features of records. The <code>Vector</code> class is used to deliver vectors to the Argilla server.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the vector.</p> <code>values</code> <code>list[float]</code> <p>The values of the vector.</p> Source code in <code>src/argilla/vectors.py</code> <pre><code>class Vector(Resource):\n    \"\"\" Class for interacting with Argilla Vectors. Vectors are typically used to represent \\\n        embeddings or features of records. The `Vector` class is used to deliver vectors to the Argilla server.\n\n    Attributes:\n        name (str): The name of the vector.\n        values (list[float]): The values of the vector.\n    \"\"\"\n\n    _model: VectorModel\n\n    def __init__(\n        self,\n        name: str,\n        values: list[float],\n    ) -&gt; None:\n        \"\"\"Initializes a Vector with a name and values that can be used to search in the Argilla ui.\n\n        Parameters:\n            name (str): Name of the vector\n            values (list[float]): List of float values\n\n        \"\"\"\n        self._model = VectorModel(\n            name=name,\n            vector_values=values,\n        )\n\n    def __repr__(self) -&gt; str:\n        return repr(f\"{self.__class__.__name__}({self._model})\")\n\n    ##############################\n    # Properties\n    ##############################\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Name of the vector that corresponds to the name of the vector in the dataset's `Settings`\"\"\"\n        return self._model.name\n\n    @property\n    def values(self) -&gt; list[float]:\n        \"\"\"List of float values that represent the vector.\"\"\"\n        return self._model.vector_values\n\n    ##############################\n    # Methods\n    ##############################\n\n    @classmethod\n    def from_model(cls, model: VectorModel) -&gt; \"Vector\":\n        return cls(\n            name=model.name,\n            values=model.vector_values,\n        )\n\n    def serialize(self) -&gt; dict[str, Any]:\n        dumped_model = self._model.model_dump()\n        name = dumped_model.pop(\"name\")\n        values = dumped_model.pop(\"vector_values\")\n        return {name: values}\n</code></pre>"},{"location":"reference/argilla/records/vectors/#src.argilla.vectors.Vector.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Name of the vector that corresponds to the name of the vector in the dataset's <code>Settings</code></p>"},{"location":"reference/argilla/records/vectors/#src.argilla.vectors.Vector.values","title":"<code>values: list[float]</code>  <code>property</code>","text":"<p>List of float values that represent the vector.</p>"},{"location":"reference/argilla/records/vectors/#src.argilla.vectors.Vector.__init__","title":"<code>__init__(name, values)</code>","text":"<p>Initializes a Vector with a name and values that can be used to search in the Argilla ui.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the vector</p> required <code>values</code> <code>list[float]</code> <p>List of float values</p> required Source code in <code>src/argilla/vectors.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    values: list[float],\n) -&gt; None:\n    \"\"\"Initializes a Vector with a name and values that can be used to search in the Argilla ui.\n\n    Parameters:\n        name (str): Name of the vector\n        values (list[float]): List of float values\n\n    \"\"\"\n    self._model = VectorModel(\n        name=name,\n        vector_values=values,\n    )\n</code></pre>"},{"location":"reference/argilla/settings/fields/","title":"Fields","text":"<p>Fields in Argilla are define the content of a record that will be reviewed by a user.</p>"},{"location":"reference/argilla/settings/fields/#usage-examples","title":"Usage Examples","text":"<p>To define a field, instantiate the <code>TextField</code> class and pass it to the <code>fields</code> parameter of the <code>Settings</code> class.</p> <pre><code>text_field = rg.TextField(name=\"text\")\nmarkdown_field = rg.TextField(name=\"text\", use_markdown=True)\n</code></pre> <p>The <code>fields</code> parameter of the <code>Settings</code> class can accept a list of fields, like this:</p> <pre><code>settings = rg.Settings(\n    fields=[\n        rg.TextField(name=\"text\"),\n    ],\n)\n\ndata = rg.Dataset(\n    name=\"my_dataset\",\n    settings=settings,\n)\n</code></pre> <p>To add records with values for fields, refer to the <code>rg.Dataset.records</code> documentation.</p>"},{"location":"reference/argilla/settings/fields/#class-references","title":"Class References","text":""},{"location":"reference/argilla/settings/fields/#rgtextfield","title":"<code>rg.TextField</code>","text":"<p>               Bases: <code>SettingsPropertyBase</code></p> <p>Text field for use in Argilla <code>Dataset</code> <code>Settings</code></p> Source code in <code>src/argilla/settings/_field.py</code> <pre><code>class TextField(SettingsPropertyBase):\n    \"\"\"Text field for use in Argilla `Dataset` `Settings`\"\"\"\n\n    _model: FieldModel\n    _api: FieldsAPI\n\n    _dataset: \"Dataset\"\n\n    def __init__(\n        self,\n        name: str,\n        title: Optional[str] = None,\n        use_markdown: Optional[bool] = False,\n        required: Optional[bool] = True,\n        description: Optional[str] = None,\n        client: Optional[Argilla] = None,\n    ) -&gt; None:\n        \"\"\"Text field for use in Argilla `Dataset` `Settings`\n        Parameters:\n            name (str): The name of the field\n            title (Optional[str], optional): The title of the field. Defaults to None.\n            use_markdown (Optional[bool], optional): Whether to use markdown. Defaults to False.\n            required (Optional[bool], optional): Whether the field is required. Defaults to True.\n            description (Optional[str], optional): The description of the field. Defaults to None.\n\n        \"\"\"\n        client = client or Argilla._get_default()\n\n        super().__init__(api=client.api.fields, client=client)\n        self._model = FieldModel(\n            name=name,\n            title=title,\n            required=required or True,\n            description=description,\n            settings=TextFieldSettings(use_markdown=use_markdown),\n        )\n\n    @classmethod\n    def from_model(cls, model: FieldModel) -&gt; \"TextField\":\n        instance = cls(name=model.name)\n        instance._model = model\n\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"TextField\":\n        model = FieldModel(**data)\n        return cls.from_model(model=model)\n\n    @property\n    def use_markdown(self) -&gt; Optional[bool]:\n        return self._model.settings.use_markdown\n\n    @use_markdown.setter\n    def use_markdown(self, value: bool) -&gt; None:\n        self._model.settings.use_markdown = value\n\n    @property\n    def dataset(self) -&gt; \"Dataset\":\n        return self._dataset\n\n    @dataset.setter\n    def dataset(self, value: \"Dataset\") -&gt; None:\n        self._dataset = value\n        self._model.dataset_id = self._dataset.id\n</code></pre>"},{"location":"reference/argilla/settings/fields/#src.argilla.settings._field.TextField.__init__","title":"<code>__init__(name, title=None, use_markdown=False, required=True, description=None, client=None)</code>","text":"<p>Text field for use in Argilla <code>Dataset</code> <code>Settings</code> Parameters:     name (str): The name of the field     title (Optional[str], optional): The title of the field. Defaults to None.     use_markdown (Optional[bool], optional): Whether to use markdown. Defaults to False.     required (Optional[bool], optional): Whether the field is required. Defaults to True.     description (Optional[str], optional): The description of the field. Defaults to None.</p> Source code in <code>src/argilla/settings/_field.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    title: Optional[str] = None,\n    use_markdown: Optional[bool] = False,\n    required: Optional[bool] = True,\n    description: Optional[str] = None,\n    client: Optional[Argilla] = None,\n) -&gt; None:\n    \"\"\"Text field for use in Argilla `Dataset` `Settings`\n    Parameters:\n        name (str): The name of the field\n        title (Optional[str], optional): The title of the field. Defaults to None.\n        use_markdown (Optional[bool], optional): Whether to use markdown. Defaults to False.\n        required (Optional[bool], optional): Whether the field is required. Defaults to True.\n        description (Optional[str], optional): The description of the field. Defaults to None.\n\n    \"\"\"\n    client = client or Argilla._get_default()\n\n    super().__init__(api=client.api.fields, client=client)\n    self._model = FieldModel(\n        name=name,\n        title=title,\n        required=required or True,\n        description=description,\n        settings=TextFieldSettings(use_markdown=use_markdown),\n    )\n</code></pre>"},{"location":"reference/argilla/settings/metadata_property/","title":"Metadata Properties","text":"<p>Metadata properties are used to define metadata fields in a dataset. Metadata fields are used to store additional information about the records in the dataset. For example, the category of a record, the price of a product, or any other information that is relevant to the record.</p>"},{"location":"reference/argilla/settings/metadata_property/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla/settings/metadata_property/#defining-metadata-property-for-a-dataset","title":"Defining Metadata Property for a dataset","text":"<p>We define metadata properties via type specific classes. The following example demonstrates how to define metadata properties as either a float, integer, or terms metadata property:</p> <p><code>TermsMetadataProperty</code> is used to define a metadata field with a list of options. For example, a color field with options red, blue, and green. <code>FloatMetadataProperty</code> and <code>IntegerMetadataProperty</code> is used to define a metadata field with a float value. For example, a price field with a minimum value of 0.0 and a maximum value of 100.0.</p> <pre><code>import argilla as rg\n\n# Define metadata properties as terms\nmetadata_field = rg.TermsMetadataProperty(\n    name=\"color\",\n    options=[\"red\", \"blue\", \"green\"],\n    title=\"Color\",\n)\n\n# Define metadata properties as float\nfloat_\nmetadata_field = rg.FloatMetadataProperty(\n    name=\"price\",\n    min=0.0,\n    max=100.0,\n    title=\"Price\",\n)\n\n# Define metadata properties as integer\nint_metadata_field = rg.IntegerMetadataProperty(\n    name=\"quantity\",\n    min=0,\n    max=100,\n    title=\"Quantity\",\n)\n</code></pre> <p>Metadata properties can be added to a dataset settings object:</p> <pre><code>dataset = rg.Dataset(\n    name=\"my_dataset\",\n    settings=rg.Settings(\n        fields=[\n            rg.TextField(name=\"text\"),\n        ],\n        metadata=[\n            metadata_field,\n            float_metadata_field,\n            int_metadata_field,\n        ],\n    ),\n)\n</code></pre> <p>To add records with metadata, refer to the <code>rg.Metadata</code> class documentation.</p>"},{"location":"reference/argilla/settings/metadata_property/#class-references","title":"Class References","text":""},{"location":"reference/argilla/settings/metadata_property/#rgfloatmetadataproperty","title":"<code>rg.FloatMetadataProperty</code>","text":"<p>               Bases: <code>MetadataPropertyBase</code></p> Source code in <code>src/argilla/settings/_metadata.py</code> <pre><code>class FloatMetadataProperty(MetadataPropertyBase):\n    def __init__(\n        self,\n        name: str,\n        min: Optional[float] = None,\n        max: Optional[float] = None,\n        title: Optional[str] = None,\n        client: Optional[Argilla] = None,\n    ) -&gt; None:\n        \"\"\"Create a metadata field with float settings.\n\n        Parameters:\n            name (str): The name of the metadata field\n            min (Optional[float]): The minimum value\n            max (Optional[float]): The maximum value\n            title (Optional[str]): The title of the metadata field\n            client (Optional[Argilla]): The client to use for API requests\n        Raises:\n            MetadataError: If an error occurs while defining metadata settings\n\n        \"\"\"\n\n        super().__init__(client=client)\n\n        try:\n            settings = FloatMetadataPropertySettings(min=min, max=max, type=MetadataPropertyType.float)\n        except ValueError as e:\n            raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n        self._model = MetadataFieldModel(\n            name=name,\n            type=MetadataPropertyType.float,\n            title=title,\n            settings=settings,\n        )\n\n    @property\n    def min(self) -&gt; Optional[int]:\n        return self._model.settings.min\n\n    @min.setter\n    def min(self, value: Optional[int]) -&gt; None:\n        self._model.settings.min = value\n\n    @property\n    def max(self) -&gt; Optional[int]:\n        return self._model.settings.max\n\n    @max.setter\n    def max(self, value: Optional[int]) -&gt; None:\n        self._model.settings.max = value\n\n    @classmethod\n    def from_model(cls, model: MetadataFieldModel) -&gt; \"FloatMetadataProperty\":\n        instance = FloatMetadataProperty(name=model.name)\n        instance._model = model\n\n        return instance\n</code></pre>"},{"location":"reference/argilla/settings/metadata_property/#src.argilla.settings._metadata.FloatMetadataProperty.__init__","title":"<code>__init__(name, min=None, max=None, title=None, client=None)</code>","text":"<p>Create a metadata field with float settings.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata field</p> required <code>min</code> <code>Optional[float]</code> <p>The minimum value</p> <code>None</code> <code>max</code> <code>Optional[float]</code> <p>The maximum value</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>The title of the metadata field</p> <code>None</code> <code>client</code> <code>Optional[Argilla]</code> <p>The client to use for API requests</p> <code>None</code> <p>Raises:     MetadataError: If an error occurs while defining metadata settings</p> Source code in <code>src/argilla/settings/_metadata.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    min: Optional[float] = None,\n    max: Optional[float] = None,\n    title: Optional[str] = None,\n    client: Optional[Argilla] = None,\n) -&gt; None:\n    \"\"\"Create a metadata field with float settings.\n\n    Parameters:\n        name (str): The name of the metadata field\n        min (Optional[float]): The minimum value\n        max (Optional[float]): The maximum value\n        title (Optional[str]): The title of the metadata field\n        client (Optional[Argilla]): The client to use for API requests\n    Raises:\n        MetadataError: If an error occurs while defining metadata settings\n\n    \"\"\"\n\n    super().__init__(client=client)\n\n    try:\n        settings = FloatMetadataPropertySettings(min=min, max=max, type=MetadataPropertyType.float)\n    except ValueError as e:\n        raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n    self._model = MetadataFieldModel(\n        name=name,\n        type=MetadataPropertyType.float,\n        title=title,\n        settings=settings,\n    )\n</code></pre>"},{"location":"reference/argilla/settings/metadata_property/#rgintegermetadataproperty","title":"<code>rg.IntegerMetadataProperty</code>","text":"<p>               Bases: <code>MetadataPropertyBase</code></p> Source code in <code>src/argilla/settings/_metadata.py</code> <pre><code>class IntegerMetadataProperty(MetadataPropertyBase):\n    def __init__(\n        self,\n        name: str,\n        min: Optional[int] = None,\n        max: Optional[int] = None,\n        title: Optional[str] = None,\n        client: Optional[Argilla] = None,\n    ) -&gt; None:\n        \"\"\"Create a metadata field with integer settings.\n\n        Parameters:\n            name (str): The name of the metadata field\n            min (Optional[int]): The minimum value\n            max (Optional[int]): The maximum value\n            title (Optional[str]): The title of the metadata field\n        Raises:\n            MetadataError: If an error occurs while defining metadata settings\n        \"\"\"\n        super().__init__(client=client)\n\n        try:\n            settings = IntegerMetadataPropertySettings(min=min, max=max, type=MetadataPropertyType.integer)\n        except ValueError as e:\n            raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n        self._model = MetadataFieldModel(\n            name=name,\n            type=MetadataPropertyType.integer,\n            title=title,\n            settings=settings,\n        )\n\n    @property\n    def min(self) -&gt; Optional[int]:\n        return self._model.settings.min\n\n    @min.setter\n    def min(self, value: Optional[int]) -&gt; None:\n        self._model.settings.min = value\n\n    @property\n    def max(self) -&gt; Optional[int]:\n        return self._model.settings.max\n\n    @max.setter\n    def max(self, value: Optional[int]) -&gt; None:\n        self._model.settings.max = value\n\n    @classmethod\n    def from_model(cls, model: MetadataFieldModel) -&gt; \"IntegerMetadataProperty\":\n        instance = IntegerMetadataProperty(name=model.name)\n        instance._model = model\n\n        return instance\n</code></pre>"},{"location":"reference/argilla/settings/metadata_property/#src.argilla.settings._metadata.IntegerMetadataProperty.__init__","title":"<code>__init__(name, min=None, max=None, title=None, client=None)</code>","text":"<p>Create a metadata field with integer settings.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata field</p> required <code>min</code> <code>Optional[int]</code> <p>The minimum value</p> <code>None</code> <code>max</code> <code>Optional[int]</code> <p>The maximum value</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>The title of the metadata field</p> <code>None</code> <p>Raises:     MetadataError: If an error occurs while defining metadata settings</p> Source code in <code>src/argilla/settings/_metadata.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    min: Optional[int] = None,\n    max: Optional[int] = None,\n    title: Optional[str] = None,\n    client: Optional[Argilla] = None,\n) -&gt; None:\n    \"\"\"Create a metadata field with integer settings.\n\n    Parameters:\n        name (str): The name of the metadata field\n        min (Optional[int]): The minimum value\n        max (Optional[int]): The maximum value\n        title (Optional[str]): The title of the metadata field\n    Raises:\n        MetadataError: If an error occurs while defining metadata settings\n    \"\"\"\n    super().__init__(client=client)\n\n    try:\n        settings = IntegerMetadataPropertySettings(min=min, max=max, type=MetadataPropertyType.integer)\n    except ValueError as e:\n        raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n    self._model = MetadataFieldModel(\n        name=name,\n        type=MetadataPropertyType.integer,\n        title=title,\n        settings=settings,\n    )\n</code></pre>"},{"location":"reference/argilla/settings/metadata_property/#rgtermsmetadataproperty","title":"<code>rg.TermsMetadataProperty</code>","text":"<p>               Bases: <code>MetadataPropertyBase</code></p> Source code in <code>src/argilla/settings/_metadata.py</code> <pre><code>class TermsMetadataProperty(MetadataPropertyBase):\n    def __init__(\n        self,\n        name: str,\n        options: Optional[List[str]] = None,\n        title: Optional[str] = None,\n        visible_for_annotators: Optional[bool] = True,\n        client: Optional[Argilla] = None,\n    ) -&gt; None:\n        \"\"\"Create a metadata field with terms settings.\n\n        Parameters:\n            name (str): The name of the metadata field\n            options (Optional[List[str]]): The list of options\n            title (Optional[str]): The title of the metadata field\n            visible_for_annotators (Optional[bool]): Whether the metadata field is visible for annotators\n        Raises:\n            MetadataError: If an error occurs while defining metadata settings\n        \"\"\"\n        super().__init__(client=client)\n\n        try:\n            settings = TermsMetadataPropertySettings(values=options, type=MetadataPropertyType.terms)\n        except ValueError as e:\n            raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n        self._model = MetadataFieldModel(\n            name=name,\n            type=MetadataPropertyType.terms,\n            title=title,\n            settings=settings,\n            visible_for_annotators=visible_for_annotators,\n        )\n\n    @property\n    def options(self) -&gt; Optional[List[str]]:\n        return self._model.settings.values\n\n    @options.setter\n    def options(self, value: list[str]) -&gt; None:\n        self._model.settings.values = value\n\n    @classmethod\n    def from_model(cls, model: MetadataFieldModel) -&gt; \"TermsMetadataProperty\":\n        instance = TermsMetadataProperty(name=model.name)\n        instance._model = model\n\n        return instance\n</code></pre>"},{"location":"reference/argilla/settings/metadata_property/#src.argilla.settings._metadata.TermsMetadataProperty.__init__","title":"<code>__init__(name, options=None, title=None, visible_for_annotators=True, client=None)</code>","text":"<p>Create a metadata field with terms settings.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata field</p> required <code>options</code> <code>Optional[List[str]]</code> <p>The list of options</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>The title of the metadata field</p> <code>None</code> <code>visible_for_annotators</code> <code>Optional[bool]</code> <p>Whether the metadata field is visible for annotators</p> <code>True</code> <p>Raises:     MetadataError: If an error occurs while defining metadata settings</p> Source code in <code>src/argilla/settings/_metadata.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    options: Optional[List[str]] = None,\n    title: Optional[str] = None,\n    visible_for_annotators: Optional[bool] = True,\n    client: Optional[Argilla] = None,\n) -&gt; None:\n    \"\"\"Create a metadata field with terms settings.\n\n    Parameters:\n        name (str): The name of the metadata field\n        options (Optional[List[str]]): The list of options\n        title (Optional[str]): The title of the metadata field\n        visible_for_annotators (Optional[bool]): Whether the metadata field is visible for annotators\n    Raises:\n        MetadataError: If an error occurs while defining metadata settings\n    \"\"\"\n    super().__init__(client=client)\n\n    try:\n        settings = TermsMetadataPropertySettings(values=options, type=MetadataPropertyType.terms)\n    except ValueError as e:\n        raise MetadataError(f\"Error defining metadata settings for {name}\") from e\n\n    self._model = MetadataFieldModel(\n        name=name,\n        type=MetadataPropertyType.terms,\n        title=title,\n        settings=settings,\n        visible_for_annotators=visible_for_annotators,\n    )\n</code></pre>"},{"location":"reference/argilla/settings/questions/","title":"Questions","text":"<p>Questions in Argilla are the questions that will be answered as feedback. They are used to define the questions that will be answered by users or models.</p>"},{"location":"reference/argilla/settings/questions/#usage-examples","title":"Usage Examples","text":"<p>To define a label question, for example, instantiate the <code>LabelQuestion</code> class and pass it to the <code>Settings</code> class.</p> <pre><code>label_question = rg.LabelQuestion(name=\"label\", labels=[\"positive\", \"negative\"])\n\nsettings = rg.Settings(\n    fields=[\n        rg.TextField(name=\"text\"),\n    ],\n    questions=[\n        label_question,\n    ],\n)\n</code></pre> <p>Questions can be combined in extensible ways based on the type of feedback you want to collect. For example, you can combine a label question with a text question to collect both a label and a text response.</p> <pre><code>label_question = rg.LabelQuestion(name=\"label\", labels=[\"positive\", \"negative\"])\ntext_question = rg.TextQuestion(name=\"response\")\n\nsettings = rg.Settings(\n    fields=[\n        rg.TextField(name=\"text\"),\n    ],\n    questions=[\n        label_question,\n        text_question,\n    ],\n)\n\ndataset = rg.Dataset(\n    name=\"my_dataset\",\n    settings=settings,\n)\n</code></pre> <p>To add records with responses to questions, refer to the <code>rg.Response</code> class documentation.</p>"},{"location":"reference/argilla/settings/questions/#class-references","title":"Class References","text":""},{"location":"reference/argilla/settings/questions/#rglabelquestion","title":"<code>rg.LabelQuestion</code>","text":"<p>               Bases: <code>QuestionPropertyBase</code></p> Source code in <code>src/argilla/settings/_question.py</code> <pre><code>class LabelQuestion(QuestionPropertyBase):\n    _model: LabelQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        labels: Union[List[str], Dict[str, str]],\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n        visible_labels: Optional[int] = None,\n    ) -&gt; None:\n        \"\"\" Define a new label question for `Settings` of a `Dataset`. A label \\\n            question is a question where the user can select one label from \\\n            a list of available labels.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            labels: Union[List[str], Dict[str, str]]: The list of available labels for the question,\n                or a dictionary of key-value pairs where the key is the label and the value is the label text in the UI.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n            visible_labels: Optional[int]: The number of visible labels for the question.\n        \"\"\"\n        self._model = LabelQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            settings=LabelQuestionSettings(\n                options=self._render_values_as_options(labels), visible_options=visible_labels\n            ),\n        )\n\n    @classmethod\n    def from_model(cls, model: LabelQuestionModel) -&gt; \"LabelQuestion\":\n        instance = cls(name=model.name, labels=cls._render_options_as_values(model.settings.options))\n        instance._model = model\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"LabelQuestion\":\n        model = LabelQuestionModel(**data)\n        return cls.from_model(model=model)\n\n    ##############################\n    # Public properties\n    ##############################\n\n    @property\n    def labels(self) -&gt; List[str]:\n        return self._render_options_as_labels(self._model.settings.options)\n\n    @labels.setter\n    def labels(self, labels: List[str]) -&gt; None:\n        self._model.settings.options = self._render_values_as_options(labels)\n\n    @property\n    def visible_labels(self) -&gt; Optional[int]:\n        return self._model.settings.visible_options\n\n    @visible_labels.setter\n    def visible_labels(self, visible_labels: Optional[int]) -&gt; None:\n        self._model.settings.visible_options = visible_labels\n</code></pre>"},{"location":"reference/argilla/settings/questions/#src.argilla.settings._question.LabelQuestion.__init__","title":"<code>__init__(name, labels, title=None, description=None, required=True, visible_labels=None)</code>","text":"<p>Define a new label question for <code>Settings</code> of a <code>Dataset</code>. A label             question is a question where the user can select one label from             a list of available labels.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>labels</code> <code>Union[List[str], Dict[str, str]]</code> <p>Union[List[str], Dict[str, str]]: The list of available labels for the question, or a dictionary of key-value pairs where the key is the label and the value is the label text in the UI.</p> required <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> <code>visible_labels</code> <code>Optional[int]</code> <p>Optional[int]: The number of visible labels for the question.</p> <code>None</code> Source code in <code>src/argilla/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    labels: Union[List[str], Dict[str, str]],\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n    visible_labels: Optional[int] = None,\n) -&gt; None:\n    \"\"\" Define a new label question for `Settings` of a `Dataset`. A label \\\n        question is a question where the user can select one label from \\\n        a list of available labels.\n\n    Parameters:\n        name: str: The name of the question to be used as a reference.\n        labels: Union[List[str], Dict[str, str]]: The list of available labels for the question,\n            or a dictionary of key-value pairs where the key is the label and the value is the label text in the UI.\n        title: Optional[str]: The title of the question to be shown in the UI.\n        description: Optional[str]: The description of the question to be shown in the UI.\n        required: bool: If the question is required for a record to be valid.\n        visible_labels: Optional[int]: The number of visible labels for the question.\n    \"\"\"\n    self._model = LabelQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        settings=LabelQuestionSettings(\n            options=self._render_values_as_options(labels), visible_options=visible_labels\n        ),\n    )\n</code></pre>"},{"location":"reference/argilla/settings/questions/#rgmultilabelquestion","title":"<code>rg.MultiLabelQuestion</code>","text":"<p>               Bases: <code>LabelQuestion</code></p> Source code in <code>src/argilla/settings/_question.py</code> <pre><code>class MultiLabelQuestion(LabelQuestion):\n    _model: MultiLabelQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        labels: List[str],\n        visible_labels: Optional[int] = None,\n        labels_order: Literal[\"natural\", \"suggestion\"] = \"natural\",\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n    ) -&gt; None:\n        \"\"\"Create a new multilabel question for `Settings` of a `Dataset`. A \\\n            multilabel question is a question where the user can select multiple \\\n            labels from a list of available labels.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            labels: List[str]: The list of available labels for the question.\n            labels_order: Literal[\"natural\", \"suggestion\"]: The order of the labels in the UI. \\\n                Can be either \"natural\" or \"suggestion\". Default is \"natural\".\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n            visible_labels: Optional[int]: The number of visible labels for the question.\n            labels_order: str: The order of the labels in the UI. Can be either \"natural\" or \"suggestion\". Default is \"natural\".\n        \"\"\"\n        self._model = MultiLabelQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            settings=MultiLabelQuestionSettings(\n                options=self._render_values_as_options(labels),\n                visible_options=visible_labels,\n                options_order=labels_order,\n            ),\n        )\n\n    @classmethod\n    def from_model(cls, model: MultiLabelQuestionModel) -&gt; \"MultiLabelQuestion\":\n        instance = cls(\n            name=model.name,\n            labels=cls._render_options_as_values(model.settings.options),\n            labels_order=model.settings.options_order,\n        )\n        instance._model = model\n\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"MultiLabelQuestion\":\n        model = MultiLabelQuestionModel(**data)\n        return cls.from_model(model=model)\n</code></pre>"},{"location":"reference/argilla/settings/questions/#src.argilla.settings._question.MultiLabelQuestion.__init__","title":"<code>__init__(name, labels, visible_labels=None, labels_order='natural', title=None, description=None, required=True)</code>","text":"<p>Create a new multilabel question for <code>Settings</code> of a <code>Dataset</code>. A             multilabel question is a question where the user can select multiple             labels from a list of available labels.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>labels</code> <code>List[str]</code> <p>List[str]: The list of available labels for the question.</p> required <code>labels_order</code> <code>Literal['natural', 'suggestion']</code> <p>Literal[\"natural\", \"suggestion\"]: The order of the labels in the UI.                 Can be either \"natural\" or \"suggestion\". Default is \"natural\".</p> <code>'natural'</code> <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> <code>visible_labels</code> <code>Optional[int]</code> <p>Optional[int]: The number of visible labels for the question.</p> <code>None</code> <code>labels_order</code> <code>Literal['natural', 'suggestion']</code> <p>str: The order of the labels in the UI. Can be either \"natural\" or \"suggestion\". Default is \"natural\".</p> <code>'natural'</code> Source code in <code>src/argilla/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    labels: List[str],\n    visible_labels: Optional[int] = None,\n    labels_order: Literal[\"natural\", \"suggestion\"] = \"natural\",\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Create a new multilabel question for `Settings` of a `Dataset`. A \\\n        multilabel question is a question where the user can select multiple \\\n        labels from a list of available labels.\n\n    Parameters:\n        name: str: The name of the question to be used as a reference.\n        labels: List[str]: The list of available labels for the question.\n        labels_order: Literal[\"natural\", \"suggestion\"]: The order of the labels in the UI. \\\n            Can be either \"natural\" or \"suggestion\". Default is \"natural\".\n        title: Optional[str]: The title of the question to be shown in the UI.\n        description: Optional[str]: The description of the question to be shown in the UI.\n        required: bool: If the question is required for a record to be valid.\n        visible_labels: Optional[int]: The number of visible labels for the question.\n        labels_order: str: The order of the labels in the UI. Can be either \"natural\" or \"suggestion\". Default is \"natural\".\n    \"\"\"\n    self._model = MultiLabelQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        settings=MultiLabelQuestionSettings(\n            options=self._render_values_as_options(labels),\n            visible_options=visible_labels,\n            options_order=labels_order,\n        ),\n    )\n</code></pre>"},{"location":"reference/argilla/settings/questions/#rgrankingquestion","title":"<code>rg.RankingQuestion</code>","text":"<p>               Bases: <code>QuestionPropertyBase</code></p> Source code in <code>src/argilla/settings/_question.py</code> <pre><code>class RankingQuestion(QuestionPropertyBase):\n    _model: RankingQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        values: List[str],\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n    ) -&gt; None:\n        \"\"\"Create a new ranking question for `Settings` of a `Dataset`. A ranking question \\\n            is a question where the user can rank a list of options.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            values: List[str]: The list of available values for the question.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n        \"\"\"\n        self._model = RankingQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            settings=RankingQuestionSettings(options=self._render_values_as_options(values)),\n        )\n\n    @classmethod\n    def from_model(cls, model: RankingQuestionModel) -&gt; \"RankingQuestion\":\n        instance = cls(name=model.name, values=cls._render_options_as_values(model.settings.options))\n        instance._model = model\n\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"RankingQuestion\":\n        model = RankingQuestionModel(**data)\n        return cls.from_model(model=model)\n\n    @property\n    def values(self) -&gt; List[str]:\n        return self._render_options_as_labels(self._model.settings.options)\n\n    @values.setter\n    def values(self, values: List[int]) -&gt; None:\n        self._model.settings.options = self._render_values_as_options(values)\n</code></pre>"},{"location":"reference/argilla/settings/questions/#src.argilla.settings._question.RankingQuestion.__init__","title":"<code>__init__(name, values, title=None, description=None, required=True)</code>","text":"<p>Create a new ranking question for <code>Settings</code> of a <code>Dataset</code>. A ranking question             is a question where the user can rank a list of options.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>values</code> <code>List[str]</code> <p>List[str]: The list of available values for the question.</p> required <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> Source code in <code>src/argilla/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    values: List[str],\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Create a new ranking question for `Settings` of a `Dataset`. A ranking question \\\n        is a question where the user can rank a list of options.\n\n    Parameters:\n        name: str: The name of the question to be used as a reference.\n        values: List[str]: The list of available values for the question.\n        title: Optional[str]: The title of the question to be shown in the UI.\n        description: Optional[str]: The description of the question to be shown in the UI.\n        required: bool: If the question is required for a record to be valid.\n    \"\"\"\n    self._model = RankingQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        settings=RankingQuestionSettings(options=self._render_values_as_options(values)),\n    )\n</code></pre>"},{"location":"reference/argilla/settings/questions/#rgtextquestion","title":"<code>rg.TextQuestion</code>","text":"<p>               Bases: <code>QuestionPropertyBase</code></p> Source code in <code>src/argilla/settings/_question.py</code> <pre><code>class TextQuestion(QuestionPropertyBase):\n    _model: TextQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n        use_markdown: bool = False,\n    ) -&gt; None:\n        \"\"\"Create a new text question for `Settings` of a `Dataset`. A text question \\\n            is a question where the user can input text.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n            use_markdown: bool: If the question should use markdown for the description.\n        \"\"\"\n        self._model = TextQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            settings=TextQuestionSettings(use_markdown=use_markdown),\n        )\n\n    @classmethod\n    def from_model(cls, model: TextQuestionModel) -&gt; \"TextQuestion\":\n        instance = cls(name=model.name)\n        instance._model = model\n\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"TextQuestion\":\n        model = TextQuestionModel(**data)\n        return cls.from_model(model=model)\n\n    @property\n    def use_markdown(self) -&gt; bool:\n        return self._model.settings.use_markdown\n\n    @use_markdown.setter\n    def use_markdown(self, use_markdown: bool) -&gt; None:\n        self._model.settings.use_markdown = use_markdown\n</code></pre>"},{"location":"reference/argilla/settings/questions/#src.argilla.settings._question.TextQuestion.__init__","title":"<code>__init__(name, title=None, description=None, required=True, use_markdown=False)</code>","text":"<p>Create a new text question for <code>Settings</code> of a <code>Dataset</code>. A text question             is a question where the user can input text.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> <code>use_markdown</code> <code>bool</code> <p>bool: If the question should use markdown for the description.</p> <code>False</code> Source code in <code>src/argilla/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n    use_markdown: bool = False,\n) -&gt; None:\n    \"\"\"Create a new text question for `Settings` of a `Dataset`. A text question \\\n        is a question where the user can input text.\n\n    Parameters:\n        name: str: The name of the question to be used as a reference.\n        title: Optional[str]: The title of the question to be shown in the UI.\n        description: Optional[str]: The description of the question to be shown in the UI.\n        required: bool: If the question is required for a record to be valid.\n        use_markdown: bool: If the question should use markdown for the description.\n    \"\"\"\n    self._model = TextQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        settings=TextQuestionSettings(use_markdown=use_markdown),\n    )\n</code></pre>"},{"location":"reference/argilla/settings/questions/#rgratingquestion","title":"<code>rg.RatingQuestion</code>","text":"<p>               Bases: <code>QuestionPropertyBase</code></p> Source code in <code>src/argilla/settings/_question.py</code> <pre><code>class RatingQuestion(QuestionPropertyBase):\n    _model: RatingQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        values: List[int],\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n    ) -&gt; None:\n        \"\"\"Create a new rating question for `Settings` of a `Dataset`. A rating question \\\n            is a question where the user can select a value from a sequential list of options.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            values: List[int]: The list of available values for the question.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n        \"\"\"\n        self._model = RatingQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            values=values,\n            settings=RatingQuestionSettings(options=self._render_values_as_options(values)),\n        )\n\n    @classmethod\n    def from_model(cls, model: RatingQuestionModel) -&gt; \"RatingQuestion\":\n        instance = cls(name=model.name, values=cls._render_options_as_values(model.settings.options))\n        instance._model = model\n\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"RatingQuestion\":\n        model = RatingQuestionModel(**data)\n        return cls.from_model(model=model)\n\n    @property\n    def values(self) -&gt; List[int]:\n        return self._render_options_as_labels(self._model.settings.options)\n\n    @values.setter\n    def values(self, values: List[int]) -&gt; None:\n        self._model.values = self._render_values_as_options(values)\n</code></pre>"},{"location":"reference/argilla/settings/questions/#src.argilla.settings._question.RatingQuestion.__init__","title":"<code>__init__(name, values, title=None, description=None, required=True)</code>","text":"<p>Create a new rating question for <code>Settings</code> of a <code>Dataset</code>. A rating question             is a question where the user can select a value from a sequential list of options.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>values</code> <code>List[int]</code> <p>List[int]: The list of available values for the question.</p> required <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> Source code in <code>src/argilla/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    values: List[int],\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Create a new rating question for `Settings` of a `Dataset`. A rating question \\\n        is a question where the user can select a value from a sequential list of options.\n\n    Parameters:\n        name: str: The name of the question to be used as a reference.\n        values: List[int]: The list of available values for the question.\n        title: Optional[str]: The title of the question to be shown in the UI.\n        description: Optional[str]: The description of the question to be shown in the UI.\n        required: bool: If the question is required for a record to be valid.\n    \"\"\"\n    self._model = RatingQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        values=values,\n        settings=RatingQuestionSettings(options=self._render_values_as_options(values)),\n    )\n</code></pre>"},{"location":"reference/argilla/settings/questions/#rgspanquestion","title":"<code>rg.SpanQuestion</code>","text":"<p>               Bases: <code>QuestionPropertyBase</code></p> Source code in <code>src/argilla/settings/_question.py</code> <pre><code>class SpanQuestion(QuestionPropertyBase):\n    _model: SpanQuestionModel\n\n    def __init__(\n        self,\n        name: str,\n        field: str,\n        labels: List[str],\n        allow_overlapping: bool = False,\n        visible_labels: Optional[int] = None,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        required: bool = True,\n    ):\n        \"\"\" Create a new span question for `Settings` of a `Dataset`. A span question \\\n            is a question where the user can select a section of text within a text field \\\n            and assign it a label.\n\n            Parameters:\n                name: str: The name of the question to be used as a reference.\n                field: str: The name of the text field to apply the span question to.\n                labels: List[str]: The list of available labels for the question.\n                allow_overlapping: bool: If the user can select overlapping spans.\n                visible_labels: Optional[int]: The number of labels to show at once.\n                title: Optional[str]: The title of the question to be shown in the UI.\n                description: Optional[str]: The description of the question to be shown in the UI.\n                required: bool: If the question is required for a record to be valid.\n            \"\"\"\n        self._model = SpanQuestionModel(\n            name=name,\n            title=title,\n            description=description,\n            required=required,\n            settings=SpanQuestionSettings(\n                field=field,\n                allow_overlapping=allow_overlapping,\n                visible_options=visible_labels,\n                options=self._render_values_as_options(labels),\n            ),\n        )\n\n    @property\n    def name(self):\n        return self._model.name\n\n    @property\n    def field(self):\n        return self._model.settings.field\n\n    @field.setter\n    def field(self, field: str):\n        self._model.settings.field = field\n\n    @property\n    def allow_overlapping(self):\n        return self._model.settings.allow_overlapping\n\n    @allow_overlapping.setter\n    def allow_overlapping(self, allow_overlapping: bool):\n        self._model.settings.allow_overlapping = allow_overlapping\n\n    @property\n    def visible_labels(self) -&gt; Optional[int]:\n        return self._model.settings.visible_options\n\n    @visible_labels.setter\n    def visible_labels(self, visible_labels: Optional[int]) -&gt; None:\n        self._model.settings.visible_options = visible_labels\n\n    @property\n    def labels(self) -&gt; List[str]:\n        return self._render_options_as_labels(self._model.settings.options)\n\n    @labels.setter\n    def labels(self, labels: List[str]) -&gt; None:\n        self._model.settings.options = self._render_values_as_options(labels)\n\n    @classmethod\n    def from_model(cls, model: SpanQuestionModel) -&gt; \"SpanQuestion\":\n        instance = cls(\n            name=model.name,\n            field=model.settings.field,\n            labels=cls._render_options_as_values(model.settings.options),\n        )\n        instance._model = model\n\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"SpanQuestion\":\n        model = SpanQuestionModel(**data)\n        return cls.from_model(model=model)\n</code></pre>"},{"location":"reference/argilla/settings/questions/#src.argilla.settings._question.SpanQuestion.__init__","title":"<code>__init__(name, field, labels, allow_overlapping=False, visible_labels=None, title=None, description=None, required=True)</code>","text":"<p>Create a new span question for <code>Settings</code> of a <code>Dataset</code>. A span question             is a question where the user can select a section of text within a text field             and assign it a label.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the question to be used as a reference.</p> required <code>field</code> <code>str</code> <p>str: The name of the text field to apply the span question to.</p> required <code>labels</code> <code>List[str]</code> <p>List[str]: The list of available labels for the question.</p> required <code>allow_overlapping</code> <code>bool</code> <p>bool: If the user can select overlapping spans.</p> <code>False</code> <code>visible_labels</code> <code>Optional[int]</code> <p>Optional[int]: The number of labels to show at once.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Optional[str]: The title of the question to be shown in the UI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional[str]: The description of the question to be shown in the UI.</p> <code>None</code> <code>required</code> <code>bool</code> <p>bool: If the question is required for a record to be valid.</p> <code>True</code> Source code in <code>src/argilla/settings/_question.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    field: str,\n    labels: List[str],\n    allow_overlapping: bool = False,\n    visible_labels: Optional[int] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    required: bool = True,\n):\n    \"\"\" Create a new span question for `Settings` of a `Dataset`. A span question \\\n        is a question where the user can select a section of text within a text field \\\n        and assign it a label.\n\n        Parameters:\n            name: str: The name of the question to be used as a reference.\n            field: str: The name of the text field to apply the span question to.\n            labels: List[str]: The list of available labels for the question.\n            allow_overlapping: bool: If the user can select overlapping spans.\n            visible_labels: Optional[int]: The number of labels to show at once.\n            title: Optional[str]: The title of the question to be shown in the UI.\n            description: Optional[str]: The description of the question to be shown in the UI.\n            required: bool: If the question is required for a record to be valid.\n        \"\"\"\n    self._model = SpanQuestionModel(\n        name=name,\n        title=title,\n        description=description,\n        required=required,\n        settings=SpanQuestionSettings(\n            field=field,\n            allow_overlapping=allow_overlapping,\n            visible_options=visible_labels,\n            options=self._render_values_as_options(labels),\n        ),\n    )\n</code></pre>"},{"location":"reference/argilla/settings/settings/","title":"<code>rg.Settings</code>","text":"<p><code>rg.Settings</code> is used to define the setttings of an Argilla <code>Dataset</code>. The settings can be used to configure the behavior of the dataset, such as the fields, questions, guidelines, metadata, and vectors. The <code>Settings</code> class is passed to the <code>Dataset</code> class and used to create the dataset on the server. Once created, the settings of a dataset cannot be changed.</p>"},{"location":"reference/argilla/settings/settings/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/argilla/settings/settings/#creating-a-new-dataset-with-settings","title":"Creating a new dataset with settings","text":"<p>To create a new dataset with settings, instantiate the <code>Settings</code> class and pass it to the <code>Dataset</code> class.</p> <pre><code>import argilla as rg\n\nsettings = rg.Settings(\n    guidelines=\"Select the sentiment of the prompt.\",\n    fields=[rg.TextField(name=\"prompt\", use_markdown=True)],\n    questions=[rg.LabelQuestion(name=\"sentiment\", labels=[\"positive\", \"negative\"])],\n)\n\ndataset = rg.Dataset(name=\"sentiment_analysis\", settings=settings)\n\n# Create the dataset on the server\ndataset.create()\n</code></pre> <p>To define the settings for fields, questions, metadata, or vectors, refer to the <code>rg.TextField</code>, <code>rg.LabelQuestion</code>, <code>rg.TermsMetadataProperty</code>, and <code>rg.VectorField</code> class documentation.</p>"},{"location":"reference/argilla/settings/settings/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla/settings/settings/#rgsettings_1","title":"<code>rg.Settings</code>","text":"<p>               Bases: <code>Resource</code></p> <p>Settings class for Argilla Datasets.</p> <p>This class is used to define the representation of a Dataset within the UI.</p> Source code in <code>src/argilla/settings/_resource.py</code> <pre><code>class Settings(Resource):\n    \"\"\"\n    Settings class for Argilla Datasets.\n\n    This class is used to define the representation of a Dataset within the UI.\n    \"\"\"\n\n    def __init__(\n        self,\n        fields: Optional[List[TextField]] = None,\n        questions: Optional[List[QuestionType]] = None,\n        vectors: Optional[List[VectorField]] = None,\n        metadata: Optional[List[MetadataType]] = None,\n        guidelines: Optional[str] = None,\n        allow_extra_metadata: bool = False,\n        _dataset: Optional[\"Dataset\"] = None,\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            fields (List[TextField]): A list of TextField objects that represent the fields in the Dataset.\n            questions (List[Union[LabelQuestion, MultiLabelQuestion, RankingQuestion, TextQuestion, RatingQuestion]]): A list of Question objects that represent the questions in the Dataset.\n            vectors (List[VectorField]): A list of VectorField objects that represent the vectors in the Dataset.\n            metadata (List[MetadataField]): A list of MetadataField objects that represent the metadata in the Dataset.\n            guidelines (str): A string containing the guidelines for the Dataset.\n            allow_extra_metadata (bool): A boolean that determines whether or not extra metadata is allowed in the Dataset. Defaults to False.\n        \"\"\"\n        super().__init__(client=_dataset._client if _dataset else None)\n\n        self.__questions = questions or []\n        self.__fields = SettingsProperties(self, fields)\n        self.__vectors = SettingsProperties(self, vectors)\n        self.__metadata = SettingsProperties(self, metadata)\n\n        self.__guidelines = self.__process_guidelines(guidelines)\n        self.__allow_extra_metadata = allow_extra_metadata\n\n        self._dataset = _dataset\n\n    #####################\n    # Properties        #\n    #####################\n\n    @property\n    def fields(self) -&gt; \"SettingsProperties\":\n        return self.__fields\n\n    @fields.setter\n    def fields(self, fields: List[TextField]):\n        self.__fields = SettingsProperties(self, fields)\n\n    @property\n    def questions(self) -&gt; List[QuestionType]:\n        return self.__questions\n\n    @questions.setter\n    def questions(self, questions: List[QuestionType]):\n        self.__questions = questions\n\n    @property\n    def vectors(self) -&gt; \"SettingsProperties\":\n        return self.__vectors\n\n    @vectors.setter\n    def vectors(self, vectors: List[VectorField]):\n        self.__vectors = SettingsProperties(self, vectors)\n\n    @property\n    def metadata(self) -&gt; \"SettingsProperties\":\n        return self.__metadata\n\n    @metadata.setter\n    def metadata(self, metadata: List[MetadataType]):\n        self.__metadata = SettingsProperties(self, metadata)\n\n    @property\n    def guidelines(self) -&gt; str:\n        return self.__guidelines\n\n    @guidelines.setter\n    def guidelines(self, guidelines: str):\n        self.__guidelines = self.__process_guidelines(guidelines)\n\n    @property\n    def allow_extra_metadata(self) -&gt; bool:\n        return self.__allow_extra_metadata\n\n    @allow_extra_metadata.setter\n    def allow_extra_metadata(self, value: bool):\n        self.__allow_extra_metadata = value\n\n    @property\n    def dataset(self) -&gt; \"Dataset\":\n        return self._dataset\n\n    @dataset.setter\n    def dataset(self, dataset: \"Dataset\"):\n        self._dataset = dataset\n        self._client = dataset._client\n\n    @cached_property\n    def schema(self) -&gt; dict:\n        schema_dict = {}\n\n        for field in self.fields:\n            schema_dict[field.name] = field\n\n        for question in self.questions:\n            schema_dict[question.name] = question\n\n        for vector in self.vectors:\n            schema_dict[vector.name] = vector\n\n        for metadata in self.metadata:\n            schema_dict[metadata.name] = metadata\n\n        return schema_dict\n\n    @cached_property\n    def schema_by_id(self) -&gt; Dict[UUID, Union[TextField, QuestionType, MetadataType, VectorField]]:\n        return {v.id: v for v in self.schema.values()}\n\n    def validate(self) -&gt; None:\n        self._validate_empty_settings()\n        self._validate_duplicate_names()\n\n    #####################\n    #  Public methods   #\n    #####################\n\n    def get(self) -&gt; \"Settings\":\n        self.fields = self._fetch_fields()\n        self.questions = self._fetch_questions()\n        self.vectors = self._fetch_vectors()\n        self.metadata = self._fetch_metadata()\n        self.__get_dataset_related_attributes()\n\n        self._update_last_api_call()\n        return self\n\n    def create(self) -&gt; \"Settings\":\n        self.validate()\n\n        self._update_dataset_related_attributes()\n        self.__fields.create()\n        self._create_questions()\n        self.__vectors.create()\n        self.__metadata.create()\n\n        self._update_last_api_call()\n        return self\n\n    def update(self) -&gt; \"Resource\":\n        self.validate()\n\n        self._update_dataset_related_attributes()\n        self.__fields.update()\n        self.__vectors.update()\n        self.__metadata.update()\n        # self.questions.update()\n\n        self._update_last_api_call()\n        return self\n\n    def question_by_name(self, question_name: str) -&gt; QuestionType:\n        for question in self.questions:\n            if question.name == question_name:\n                return question\n        raise ValueError(f\"Question with name {question_name} not found\")\n\n    def question_by_id(self, question_id: UUID) -&gt; QuestionType:\n        property = self.schema_by_id.get(question_id)\n        if isinstance(property, QuestionPropertyBase):\n            return property\n        raise ValueError(f\"Question with id {question_id} not found\")\n\n    def serialize(self):\n        try:\n            return {\n                \"guidelines\": self.guidelines,\n                \"questions\": self.__serialize_questions(self.questions),\n                \"fields\": self.__fields.serialize(),\n                \"vectors\": self.vectors.serialize(),\n                \"metadata\": self.metadata.serialize(),\n                \"allow_extra_metadata\": self.allow_extra_metadata,\n            }\n        except Exception as e:\n            raise ArgillaSerializeError(f\"Failed to serialize the settings. {e.__class__.__name__}\") from e\n\n    def to_json(self, path: Union[Path, str]) -&gt; None:\n        \"\"\"Save the settings to a file on disk\n\n        Parameters:\n            path (str): The path to save the settings to\n        \"\"\"\n        if not isinstance(path, Path):\n            path = Path(path)\n        if path.exists():\n            raise FileExistsError(f\"File {path} already exists\")\n        with open(path, \"w\") as file:\n            json.dump(self.serialize(), file)\n\n    @classmethod\n    def from_json(cls, path: Union[Path, str]) -&gt; \"Settings\":\n        \"\"\"Load the settings from a file on disk\"\"\"\n\n        with open(path, \"r\") as file:\n            settings_dict = json.load(file)\n\n        fields = settings_dict.get(\"fields\", [])\n        vectors = settings_dict.get(\"vectors\", [])\n        metadata = settings_dict.get(\"metadata\", [])\n        guidelines = settings_dict.get(\"guidelines\")\n        allow_extra_metadata = settings_dict.get(\"allow_extra_metadata\")\n\n        questions = [question_from_dict(question) for question in settings_dict.get(\"questions\", [])]\n        fields = [TextField.from_dict(field) for field in fields]\n        vectors = [VectorField.from_dict(vector) for vector in vectors]\n        metadata = [MetadataField.from_dict(metadata) for metadata in metadata]\n\n        return cls(\n            questions=questions,\n            fields=fields,\n            vectors=vectors,\n            metadata=metadata,\n            guidelines=guidelines,\n            allow_extra_metadata=allow_extra_metadata,\n        )\n\n    def __eq__(self, other: \"Settings\") -&gt; bool:\n        return self.serialize() == other.serialize()  # TODO: Create proper __eq__ methods for fields and questions\n\n    #####################\n    #  Repr Methods     #\n    #####################\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"Settings(guidelines={self.guidelines}, allow_extra_metadata={self.allow_extra_metadata}, \"\n            f\"fields={self.fields}, questions={self.questions}, vectors={self.vectors}, metadata={self.metadata})\"\n        )\n\n    #####################\n    #  Private methods  #\n    #####################\n\n    def _fetch_fields(self) -&gt; List[TextField]:\n        models = self._client.api.fields.list(dataset_id=self._dataset.id)\n        return [TextField.from_model(model) for model in models]\n\n    def _fetch_questions(self) -&gt; List[QuestionType]:\n        models = self._client.api.questions.list(dataset_id=self._dataset.id)\n        return [question_from_model(model) for model in models]\n\n    def _fetch_vectors(self) -&gt; List[VectorField]:\n        models = self.dataset._client.api.vectors.list(self.dataset.id)\n        return [VectorField.from_model(model) for model in models]\n\n    def _fetch_metadata(self) -&gt; List[MetadataType]:\n        models = self._client.api.metadata.list(dataset_id=self._dataset.id)\n        return [MetadataField.from_model(model) for model in models]\n\n    def __get_dataset_related_attributes(self):\n        # This flow may be a bit weird, but it's the only way to update the dataset related attributes\n        # Everything is point that we should have several settings-related endpoints in the API to handle this.\n        # POST /api/v1/datasets/{dataset_id}/settings\n        # {\n        #   \"guidelines\": ....,\n        #   \"allow_extra_metadata\": ....,\n        # }\n        # But this is not implemented yet, so we need to update the dataset model directly\n        dataset_model = self._client.api.datasets.get(self._dataset.id)\n\n        self.guidelines = dataset_model.guidelines\n        self.allow_extra_metadata = dataset_model.allow_extra_metadata\n\n    def _update_dataset_related_attributes(self):\n        # This flow may be a bit weird, but it's the only way to update the dataset related attributes\n        # Everything is point that we should have several settings-related endpoints in the API to handle this.\n        # POST /api/v1/datasets/{dataset_id}/settings\n        # {\n        #   \"guidelines\": ....,\n        #   \"allow_extra_metadata\": ....,\n        # }\n        # But this is not implemented yet, so we need to update the dataset model directly\n        dataset_model = DatasetModel(\n            id=self._dataset.id,\n            name=self._dataset.name,\n            guidelines=self.guidelines,\n            allow_extra_metadata=self.allow_extra_metadata,\n        )\n        self._client.api.datasets.update(dataset_model)\n\n    def _create_questions(self) -&gt; None:\n        for question in self.__questions:\n            try:\n                question_model = self._client.api.questions.create(\n                    dataset_id=self._dataset.id, question=question._model\n                )\n                question._model = question_model\n            except ArgillaAPIError as e:\n                raise SettingsError(f\"Failed to create question {question.name}\") from e\n\n    def _validate_empty_settings(self):\n        if not all([self.fields, self.questions]):\n            message = \"Fields and questions are required\"\n            raise SettingsError(message=message)\n\n    def _validate_duplicate_names(self) -&gt; None:\n        dataset_properties_by_name = {}\n\n        for properties in [self.fields, self.questions, self.vectors, self.metadata]:\n            for property in properties:\n                if property.name in dataset_properties_by_name:\n                    raise SettingsError(\n                        f\"names of dataset settings must be unique, \"\n                        f\"but the name {property.name!r} is used by {type(property).__name__!r} and {type(dataset_properties_by_name[property.name]).__name__!r} \"\n                    )\n                dataset_properties_by_name[property.name] = property\n\n    def __process_guidelines(self, guidelines):\n        if guidelines is None:\n            return guidelines\n\n        if not isinstance(guidelines, str):\n            raise SettingsError(\"Guidelines must be a string or a path to a file\")\n\n        if os.path.exists(guidelines):\n            with open(guidelines, \"r\") as file:\n                return file.read()\n\n        return guidelines\n\n    def __serialize_questions(self, questions: List[QuestionType]):\n        return [question.serialize() for question in questions]\n</code></pre>"},{"location":"reference/argilla/settings/settings/#src.argilla.settings._resource.Settings.__init__","title":"<code>__init__(fields=None, questions=None, vectors=None, metadata=None, guidelines=None, allow_extra_metadata=False, _dataset=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>fields</code> <code>List[TextField]</code> <p>A list of TextField objects that represent the fields in the Dataset.</p> <code>None</code> <code>questions</code> <code>List[Union[LabelQuestion, MultiLabelQuestion, RankingQuestion, TextQuestion, RatingQuestion]]</code> <p>A list of Question objects that represent the questions in the Dataset.</p> <code>None</code> <code>vectors</code> <code>List[VectorField]</code> <p>A list of VectorField objects that represent the vectors in the Dataset.</p> <code>None</code> <code>metadata</code> <code>List[MetadataField]</code> <p>A list of MetadataField objects that represent the metadata in the Dataset.</p> <code>None</code> <code>guidelines</code> <code>str</code> <p>A string containing the guidelines for the Dataset.</p> <code>None</code> <code>allow_extra_metadata</code> <code>bool</code> <p>A boolean that determines whether or not extra metadata is allowed in the Dataset. Defaults to False.</p> <code>False</code> Source code in <code>src/argilla/settings/_resource.py</code> <pre><code>def __init__(\n    self,\n    fields: Optional[List[TextField]] = None,\n    questions: Optional[List[QuestionType]] = None,\n    vectors: Optional[List[VectorField]] = None,\n    metadata: Optional[List[MetadataType]] = None,\n    guidelines: Optional[str] = None,\n    allow_extra_metadata: bool = False,\n    _dataset: Optional[\"Dataset\"] = None,\n) -&gt; None:\n    \"\"\"\n    Args:\n        fields (List[TextField]): A list of TextField objects that represent the fields in the Dataset.\n        questions (List[Union[LabelQuestion, MultiLabelQuestion, RankingQuestion, TextQuestion, RatingQuestion]]): A list of Question objects that represent the questions in the Dataset.\n        vectors (List[VectorField]): A list of VectorField objects that represent the vectors in the Dataset.\n        metadata (List[MetadataField]): A list of MetadataField objects that represent the metadata in the Dataset.\n        guidelines (str): A string containing the guidelines for the Dataset.\n        allow_extra_metadata (bool): A boolean that determines whether or not extra metadata is allowed in the Dataset. Defaults to False.\n    \"\"\"\n    super().__init__(client=_dataset._client if _dataset else None)\n\n    self.__questions = questions or []\n    self.__fields = SettingsProperties(self, fields)\n    self.__vectors = SettingsProperties(self, vectors)\n    self.__metadata = SettingsProperties(self, metadata)\n\n    self.__guidelines = self.__process_guidelines(guidelines)\n    self.__allow_extra_metadata = allow_extra_metadata\n\n    self._dataset = _dataset\n</code></pre>"},{"location":"reference/argilla/settings/settings/#src.argilla.settings._resource.Settings.from_json","title":"<code>from_json(path)</code>  <code>classmethod</code>","text":"<p>Load the settings from a file on disk</p> Source code in <code>src/argilla/settings/_resource.py</code> <pre><code>@classmethod\ndef from_json(cls, path: Union[Path, str]) -&gt; \"Settings\":\n    \"\"\"Load the settings from a file on disk\"\"\"\n\n    with open(path, \"r\") as file:\n        settings_dict = json.load(file)\n\n    fields = settings_dict.get(\"fields\", [])\n    vectors = settings_dict.get(\"vectors\", [])\n    metadata = settings_dict.get(\"metadata\", [])\n    guidelines = settings_dict.get(\"guidelines\")\n    allow_extra_metadata = settings_dict.get(\"allow_extra_metadata\")\n\n    questions = [question_from_dict(question) for question in settings_dict.get(\"questions\", [])]\n    fields = [TextField.from_dict(field) for field in fields]\n    vectors = [VectorField.from_dict(vector) for vector in vectors]\n    metadata = [MetadataField.from_dict(metadata) for metadata in metadata]\n\n    return cls(\n        questions=questions,\n        fields=fields,\n        vectors=vectors,\n        metadata=metadata,\n        guidelines=guidelines,\n        allow_extra_metadata=allow_extra_metadata,\n    )\n</code></pre>"},{"location":"reference/argilla/settings/settings/#src.argilla.settings._resource.Settings.to_json","title":"<code>to_json(path)</code>","text":"<p>Save the settings to a file on disk</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the settings to</p> required Source code in <code>src/argilla/settings/_resource.py</code> <pre><code>def to_json(self, path: Union[Path, str]) -&gt; None:\n    \"\"\"Save the settings to a file on disk\n\n    Parameters:\n        path (str): The path to save the settings to\n    \"\"\"\n    if not isinstance(path, Path):\n        path = Path(path)\n    if path.exists():\n        raise FileExistsError(f\"File {path} already exists\")\n    with open(path, \"w\") as file:\n        json.dump(self.serialize(), file)\n</code></pre>"},{"location":"reference/argilla/settings/vectors/","title":"Vectors","text":"<p>Vector fields in Argilla are used to define the vector form of a record that will be reviewed by a user.</p>"},{"location":"reference/argilla/settings/vectors/#usage-examples","title":"Usage Examples","text":"<p>To define a vector field, instantiate the <code>VectorField</code> class with a name and dimenstions, then pass it to the <code>vectors</code> parameter of the <code>Settings</code> class.</p> <pre><code>settings = rg.Settings(\n    fields=[\n        rg.TextField(name=\"text\"),\n    ],\n    vectors=[\n        rg.VectorField(\n            name=\"my_vector\",\n            dimension=768,\n            title=\"Document Embedding\",\n        ),\n    ],\n)\n</code></pre> <p>To add records with vectors, refer to the <code>rg.Vector</code> class documentation.</p>"},{"location":"reference/argilla/settings/vectors/#class-reference","title":"Class Reference","text":""},{"location":"reference/argilla/settings/vectors/#rgvectorfield","title":"<code>rg.VectorField</code>","text":"<p>               Bases: <code>Resource</code></p> <p>Vector field for use in Argilla <code>Dataset</code> <code>Settings</code></p> Source code in <code>src/argilla/settings/_vector.py</code> <pre><code>class VectorField(Resource):\n    \"\"\"Vector field for use in Argilla `Dataset` `Settings`\"\"\"\n\n    _model: VectorFieldModel\n    _api: VectorsAPI\n    _dataset: \"Dataset\"\n\n    def __init__(\n        self,\n        name: str,\n        dimensions: int,\n        title: Optional[str] = None,\n        _client: Optional[\"Argilla\"] = None,\n    ) -&gt; None:\n        \"\"\"Vector field for use in Argilla `Dataset` `Settings`\n\n        Parameters:\n            name (str): The name of the field\n            dimensions (int): The number of dimensions in the vector\n            title (Optional[str], optional): The title of the field. Defaults to None.\n        \"\"\"\n        client = _client or Argilla._get_default()\n        super().__init__(api=client.api.vectors, client=client)\n        self._model = VectorFieldModel(name=name, title=title, dimensions=dimensions)\n        self._dataset = None\n\n    @property\n    def name(self) -&gt; str:\n        return self._model.name\n\n    @name.setter\n    def name(self, value: str) -&gt; None:\n        self._model.name = value\n\n    @property\n    def title(self) -&gt; Optional[str]:\n        return self._model.title\n\n    @title.setter\n    def title(self, value: Optional[str]) -&gt; None:\n        self._model.title = value\n\n    @property\n    def dimensions(self) -&gt; int:\n        return self._model.dimensions\n\n    @dimensions.setter\n    def dimensions(self, value: int) -&gt; None:\n        self._model.dimensions = value\n\n    @property\n    def dataset(self) -&gt; \"Dataset\":\n        return self._dataset\n\n    @dataset.setter\n    def dataset(self, value: \"Dataset\") -&gt; None:\n        self._dataset = value\n        self._model.dataset_id = self._dataset.id\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}(name={self.name}, title={self.title}, dimensions={self.dimensions})\"\n\n    @classmethod\n    def from_model(cls, model: VectorFieldModel) -&gt; \"VectorField\":\n        instance = cls(name=model.name, dimensions=model.dimensions)\n        instance._model = model\n\n        return instance\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"VectorField\":\n        model = VectorFieldModel(**data)\n        return cls.from_model(model=model)\n</code></pre>"},{"location":"reference/argilla/settings/vectors/#src.argilla.settings._vector.VectorField.__init__","title":"<code>__init__(name, dimensions, title=None, _client=None)</code>","text":"<p>Vector field for use in Argilla <code>Dataset</code> <code>Settings</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the field</p> required <code>dimensions</code> <code>int</code> <p>The number of dimensions in the vector</p> required <code>title</code> <code>Optional[str]</code> <p>The title of the field. Defaults to None.</p> <code>None</code> Source code in <code>src/argilla/settings/_vector.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    dimensions: int,\n    title: Optional[str] = None,\n    _client: Optional[\"Argilla\"] = None,\n) -&gt; None:\n    \"\"\"Vector field for use in Argilla `Dataset` `Settings`\n\n    Parameters:\n        name (str): The name of the field\n        dimensions (int): The number of dimensions in the vector\n        title (Optional[str], optional): The title of the field. Defaults to None.\n    \"\"\"\n    client = _client or Argilla._get_default()\n    super().__init__(api=client.api.vectors, client=client)\n    self._model = VectorFieldModel(name=name, title=title, dimensions=dimensions)\n    self._dataset = None\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>These are the tutorials for the Argilla SDK. They provide step-by-step instructions for common tasks.</p> <ul> <li> <p>Text classification task</p> <p>Learn about a standard workflow to improve data quality for a text classification task.  How-to guide</p> </li> </ul>"},{"location":"tutorials/text_classification/","title":"Text classification task","text":"<p>In this tutorial, we will show a standard workflow for a text classification task, in this case, using SetFit and Argilla.</p> <p>We will follow these steps:</p> <ul> <li>Configure the Argilla dataset</li> <li>Add initial model suggestions</li> <li>Evaluate with Argilla</li> <li>Train your model</li> <li>Update the suggestions with the new model</li> </ul> <p>If you have already deployed Argilla Server, you can skip this step. Otherwise, you can quickly deploy it in two different ways:</p> <ul> <li>Remotely using a HF Space. \u26a0\ufe0f If persistent storage is not enabled, you will lose your data when the server is stopped.</li> </ul> <p>Note</p> <p>As this is a release candidate version, you'll need to manually change the version in the HF Space Files &gt; Dockerfile to <code>argilla/argilla-quickstart:v2.0.0rc2</code>.</p> <ul> <li>Locally using Docker: <code>docker run -d --name quickstart -p 6900:6900 argilla/argilla-quickstart:v2.0.0rc2</code></li> </ul> <p>To complete this tutorial, you need to install the Argilla SDK and a few third-party libraries via <code>pip</code>.</p> <pre><code>!pip install argilla --pre\n</code></pre> <pre><code>!pip install setfit==1.0.3 transformers==4.40.2\n</code></pre> <p>Let's make the required imports:</p> <pre><code>import argilla as rg\n\nfrom datasets import load_dataset, Dataset\nfrom setfit import SetFitModel, Trainer, get_templated_dataset, sample_dataset\n</code></pre> <p>You also need to connect to the Argilla server using the <code>api_url</code> and <code>api_key</code>.</p> <pre><code># Replace api_url with your url if using Docker\n# Replace api_key if you configured a custom API key\n# Uncomment the last line and set your HF_TOKEN if your space is private\nclient = rg.Argilla(\n    api_url=\"https://[your-owner-name]-[your_space_name].hf.space\",\n    api_key=\"owner.apikey\"\n    # headers={\"Authorization\": f\"Bearer {HF_TOKEN}\"}\n)\n</code></pre> <p>Now, we will need to configure the dataset. In the settings, we can specify the guidelines, fields, and questions. If needed, you can also add metadata and vectors. However, for our use case, we just need a text field and a label question.</p> <p>Note</p> <p>Check this how-to guide to know more about configuring and creating a dataset.</p> <pre><code>labels = [\"positive\", \"negative\"]\n\nsettings = rg.Settings(\n    guidelines=\"Classify the reviews as positive or negative.\",\n    fields=[\n        rg.TextField(\n            name=\"review\",\n            title=\"Text from the review\",\n            use_markdown=False,\n        ),\n    ],\n    questions=[\n        rg.LabelQuestion(\n            name=\"sentiment_label\",\n            title=\"In which category does this article fit?\",\n            labels=labels,\n        )\n    ],\n)\n</code></pre> <p>Let's create the dataset with the name and the defined settings:</p> <pre><code>dataset = rg.Dataset(\n    name=\"text_classification_dataset1\",\n    settings=settings,\n)\ndataset.create()\n</code></pre> <p>Even if we have created the dataset, it still lacks the information to be annotated (you can check it in the UI). We will use the <code>imdb</code> dataset from the Hugging Face Hub. Specifically, we will use 100 samples from the <code>train</code> split.</p> <pre><code>hf_dataset = load_dataset(\"imdb\", split=\"train[:100]\")\n</code></pre> <p>We will easily add them to the dataset using <code>log</code> and the mapping, where we indicate that the column <code>text</code> is the data that should be added to the field <code>review</code>.</p> <pre><code>dataset.records.log(records=hf_dataset, mapping={\"text\": \"review\"})\n</code></pre> <p>The next step is to add suggestions to the dataset. In our case, we will generate them using a zero-shot SetFit model. However, you can use a framework or technique of your choice.</p> <p>We will start by defining an example training set with the required labels: <code>positive</code> and <code>negative</code>. Using <code>get_templated_dataset</code> will create sentences from the default template: \"This sentence is {label}.\"</p> <pre><code>zero_ds = get_templated_dataset(\n    candidate_labels=labels,\n    sample_size=8,\n)\n</code></pre> <p>Now, we will prepare a function to train the SetFit model.</p> <p>Note</p> <p>For further customization, you can check the SetFit documentation.</p> <pre><code>def train_model(model_name, dataset):\n\n    model = SetFitModel.from_pretrained(model_name)\n\n    trainer = Trainer(\n        model=model,\n        train_dataset=dataset,\n    )\n\n    trainer.train()\n\n    return model\n</code></pre> <p>Let's train the model. We will use <code>TaylorAI/bge-micro-v2</code>, available in the Hugging Face Hub.</p> <pre><code>model = train_model(model_name=\"TaylorAI/bge-micro-v2\", dataset=zero_ds)\n</code></pre> <p>You can save it locally or push it to the Hub. And then, load it from there.</p> <pre><code># Save and load locally\n# model.save_pretrained(\"text_classification_model\")\n# model = SetFitModel.from_pretrained(\"text_classification_model\")\n\n# Push and load in HF\n# model.push_to_hub(\"[username]/text_classification_model\")\n# model = SetFitModel.from_pretrained(\"[username]/text_classification_model\")\n</code></pre> <p>It's time to make the predictions! We will set a function that uses the <code>predict</code> method to get the suggested label. The model will infer the label based on the text.</p> <pre><code>def predict(model, input, labels):\n\n    model.labels = labels\n\n    prediction = model.predict([input])\n\n    return prediction[0]\n</code></pre> <p>To update the records, we will need to retrieve them from the server and update them with the new suggestions. The <code>id</code> will always need to be provided as it is the records' identifier to update a record and avoid creating a new one.</p> <pre><code>data = dataset.records.to_list(flatten=True)\nupdated_data = [\n    {\n        \"sentiment_label\": predict(model, sample[\"review\"], labels),\n        \"id\": sample[\"id\"],\n    }\n    for sample in data\n]\ndataset.records.log(records=updated_data)\n</code></pre> <p>Voil\u00e0! We have added the suggestions to the dataset, and they will appear in the UI marked with a \u2728. </p> <p>Now, we can start the annotation process. Just open the dataset in the Argilla UI and start annotating the records. If the suggestions are correct, you can just click on <code>Submit</code>. Otherwise, you can select the correct label.</p> <p>Note</p> <p>Check this how-to guide to know more about annotating in the UI.</p> <p>After the annotation, we will have a robust dataset to train the main model. In our case, we will fine-tune using SetFit. However, you can select the one that best fits your requirements. So, let's start by retrieving the annotated records.</p> <p>Note</p> <p>Check this how-to guide to know more about filtering and querying in Argilla.</p> <pre><code>dataset = client.datasets(\"text_classification_dataset\")\n</code></pre> <pre><code>status_filter = rg.Query(filter = rg.Filter((\"status\", \"==\", \"submitted\")))\nsubmitted = list(dataset.records(status_filter))\n</code></pre> <p>As we have a single response per record, we can retrieve the selected label straightforwardly and create the training set with 8 samples per label. We selected 8 samples per label to have a balanced dataset for few-shot learning.</p> <pre><code>train_records = [{\n    \"text\" : r.fields[\"review\"],\n    \"label\" : r.responses.sentiment_label[0].value,\n    } for r in submitted\n]\ntrain_dataset = Dataset.from_list(train_records)\ntrain_dataset = sample_dataset(train_dataset, label_column=\"label\", num_samples=8)\n</code></pre> <p>We can train the model using our previous function, but this time with a high-quality human-annotated training set.</p> <pre><code>model = train_model(model_name=\"TaylorAI/bge-micro-v2\", dataset=train_dataset)\n</code></pre> <p>As the training data had a better-quality, we can expect a better model. So, we can update the remaining non-annotated records with the new model's suggestions.</p> <pre><code>data = dataset.records.to_list(flatten=True)\nupdated_data = [\n    {\n        \"sentiment_label\": predict(model, sample[\"review\"], labels),\n        \"id\": sample[\"id\"],\n    }\n    for sample in data\n]\ndataset.records.log(records=updated_data)\n</code></pre> <p>In this tutorial, we present an end-to-end example of a text classification task. This serves as the base, but it can be performed iteratively and seamlessly integrated into your workflow to ensure high-quality curation of your data and improved results.</p> <p>We started by configuring the dataset, adding records, and training a zero-shot SetFit model, as an example, to add suggestions. After the annotation process, we trained a new model with the annotated data and updated the remaining records with the new suggestions.</p>"},{"location":"tutorials/text_classification/#text-classification-task","title":"Text classification task","text":""},{"location":"tutorials/text_classification/#getting-started","title":"Getting started","text":""},{"location":"tutorials/text_classification/#run-the-argilla-server","title":"Run the Argilla server","text":""},{"location":"tutorials/text_classification/#set-up-the-environment","title":"Set up the environment","text":""},{"location":"tutorials/text_classification/#configure-and-create-the-argilla-dataset","title":"Configure and create the Argilla dataset","text":""},{"location":"tutorials/text_classification/#add-records","title":"Add records","text":""},{"location":"tutorials/text_classification/#add-initial-model-suggestions","title":"Add initial model suggestions","text":""},{"location":"tutorials/text_classification/#evaluate-with-argilla","title":"Evaluate with Argilla","text":""},{"location":"tutorials/text_classification/#train-your-model","title":"Train your model","text":""},{"location":"tutorials/text_classification/#conclusions","title":"Conclusions","text":""}]}